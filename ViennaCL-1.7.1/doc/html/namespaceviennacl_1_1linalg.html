<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Free open-source GPU-accelerated linear algebra and solver library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceviennacl_1_1linalg.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">viennacl::linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides all linear algebra operations which are not covered by operator overloads.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1cuda.html">cuda</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1cuda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds all CUDA compute kernels used by ViennaCL. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace holding implementation details for linear algebra routines. Usually not of interest for a library user. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1host__based"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html">host_based</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1host__based"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds all compute kernels with conventional host-based execution (buffers in CPU RAM). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1kernels"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1kernels.html">kernels</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1kernels"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the OpenCL kernels. Deprecated, will be moved to <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html" title="Holds all routines providing OpenCL linear algebra operations. ">viennacl::linalg::opencl</a> in future releases. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1opencl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html">opencl</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds all routines providing OpenCL linear algebra operations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1amg__coarse__problem__too__large__exception.html">amg_coarse_problem_too_large_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1amg__precond.html">amg_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AMG preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1amg__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1amg__precond_3_01compressed__matrix_3_01_numeric_t_00_01_alignment_v_01_4_01_4.html">amg_precond&lt; compressed_matrix&lt; NumericT, AlignmentV &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AMG preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1amg__precond_3_01compressed__matrix_3_01_numeric_t_00_01_alignment_v_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1amg__tag.html">amg_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for algebraic multigrid (AMG). Used to transport information from the user to the implementation.  <a href="classviennacl_1_1linalg_1_1amg__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1bicgstab__solver.html">bicgstab_solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the stabilized Bi-conjugate gradient solver. Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1bicgstab__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1block__ilu__precond.html">block_ilu_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block ILU preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1block__ilu__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1block__ilu__precond_3_01compressed__matrix_3_01_numeric_t_00_01_align1f935c0ddb2915c5703380de7539023a.html">block_ilu_precond&lt; compressed_matrix&lt; NumericT, AlignmentV &gt;, ILUTagT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1block__ilu__precond_3_01compressed__matrix_3_01_numeric_t_00_01_align1f935c0ddb2915c5703380de7539023a.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1cg__solver.html">cg_solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the conjugate gradient Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1cg__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1chow__patel__icc__precond.html">chow_patel_icc_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel Chow-Patel ILU preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1chow__patel__icc__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1chow__patel__icc__precond_3_01viennacl_1_1compressed__matrix_3_01_num12c156ca568277646db4ffa0c9da3134.html">chow_patel_icc_precond&lt; viennacl::compressed_matrix&lt; NumericT, AlignmentV &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel Chow-Patel ILU preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1chow__patel__icc__precond_3_01viennacl_1_1compressed__matrix_3_01_num12c156ca568277646db4ffa0c9da3134.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1chow__patel__ilu__precond.html">chow_patel_ilu_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel Chow-Patel ILU preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1chow__patel__ilu__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1chow__patel__ilu__precond_3_01viennacl_1_1compressed__matrix_3_01_num1d4c01a16bf6e4ce8c15fcd9140c68ca.html">chow_patel_ilu_precond&lt; viennacl::compressed_matrix&lt; NumericT, AlignmentV &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel Chow-Patel ILU preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1chow__patel__ilu__precond_3_01viennacl_1_1compressed__matrix_3_01_num1d4c01a16bf6e4ce8c15fcd9140c68ca.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1chow__patel__tag.html">chow_patel_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for incomplete LU and incomplete Cholesky factorization with static pattern (Parallel-ILU0, Parallel ICC0)  <a href="classviennacl_1_1linalg_1_1chow__patel__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1fspai__precond.html">fspai_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the Factored SParse Approximate Inverse Algorithm for a generic, uBLAS-compatible matrix type.  <a href="classviennacl_1_1linalg_1_1fspai__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1fspai__precond_3_01viennacl_1_1compressed__matrix_3_01_scalar_type_00e2257d431089a1252a9a2c07955b0dee.html">fspai_precond&lt; viennacl::compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the Factored SParse Approximate Inverse Algorithm for a ViennaCL <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a>.  <a href="classviennacl_1_1linalg_1_1fspai__precond_3_01viennacl_1_1compressed__matrix_3_01_scalar_type_00e2257d431089a1252a9a2c07955b0dee.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1gmres__solver.html">gmres_solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the solver GMRES. Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1gmres__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ichol0__precond.html">ichol0_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incomplete Cholesky preconditioner class with static pattern (ICHOL0), can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ichol0__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ichol0__precond_3_01compressed__matrix_3_01_numeric_t_00_01_alignment_v_01_4_01_4.html">ichol0_precond&lt; compressed_matrix&lt; NumericT, AlignmentV &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU0 preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ichol0__precond_3_01compressed__matrix_3_01_numeric_t_00_01_alignment_v_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ichol0__tag.html">ichol0_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for incomplete Cholesky factorization with static pattern (ILU0)  <a href="classviennacl_1_1linalg_1_1ichol0__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilu0__precond.html">ilu0_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU0 preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilu0__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilu0__precond_3_01viennacl_1_1compressed__matrix_3_01_numeric_t_00_01_alignment_v_01_4_01_4.html">ilu0_precond&lt; viennacl::compressed_matrix&lt; NumericT, AlignmentV &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU0 preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilu0__precond_3_01viennacl_1_1compressed__matrix_3_01_numeric_t_00_01_alignment_v_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilu0__tag.html">ilu0_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for incomplete LU factorization with static pattern (ILU0)  <a href="classviennacl_1_1linalg_1_1ilu0__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__precond.html">ilut_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilut__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__precond_3_01viennacl_1_1compressed__matrix_3_01_numeric_t_00_01_alignment_v_01_4_01_4.html">ilut_precond&lt; viennacl::compressed_matrix&lt; NumericT, AlignmentV &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilut__precond_3_01viennacl_1_1compressed__matrix_3_01_numeric_t_00_01_alignment_v_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html">ilut_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for incomplete LU factorization with threshold (ILUT)  <a href="classviennacl_1_1linalg_1_1ilut__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1jacobi__precond.html">jacobi_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines. Generic version for non-ViennaCL matrices.  <a href="classviennacl_1_1linalg_1_1jacobi__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1jacobi__precond_3_01_matrix_t_00_01true_01_4.html">jacobi_precond&lt; MatrixT, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1jacobi__precond_3_01_matrix_t_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1jacobi__tag.html">jacobi_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for a jacobi preconditioner.  <a href="classviennacl_1_1linalg_1_1jacobi__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1lanczos__tag.html">lanczos_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the lanczos algorithm.  <a href="classviennacl_1_1linalg_1_1lanczos__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">lower_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix.  <a href="structviennacl_1_1linalg_1_1lower__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1mixed__precision__cg__tag.html">mixed_precision_cg_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the conjugate gradient Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1mixed__precision__cg__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1nmf__config.html">nmf_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration class for the nonnegative-matrix-factorization algorithm. Specify tolerances, maximum iteration counts, etc., here.  <a href="classviennacl_1_1linalg_1_1nmf__config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">no_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the use of no preconditioner.  <a href="classviennacl_1_1linalg_1_1no__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1power__iter__tag.html">power_iter_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the power iteration algorithm.  <a href="classviennacl_1_1linalg_1_1power__iter__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1row__scaling.html">row_scaling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi-type preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines. This is a diagonal preconditioner with the diagonal entries being (configurable) row norms of the matrix.  <a href="classviennacl_1_1linalg_1_1row__scaling.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1row__scaling_3_01_matrix_type_00_01true_01_4.html">row_scaling&lt; MatrixType, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1row__scaling_3_01_matrix_type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1row__scaling__tag.html">row_scaling_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for a row scaling preconditioner which merely normalizes the equation system such that each row of the system matrix has unit norm.  <a href="classviennacl_1_1linalg_1_1row__scaling__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1spai__precond.html">spai_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the SParse Approximate Inverse Algorithm for a generic, uBLAS-compatible matrix type.  <a href="classviennacl_1_1linalg_1_1spai__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1spai__precond_3_01viennacl_1_1compressed__matrix_3_01_scalar_type_00_85d4c7cd827146fed2347215919b14e6.html">spai_precond&lt; viennacl::compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the SParse Approximate Inverse Algorithm for a ViennaCL <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a>.  <a href="classviennacl_1_1linalg_1_1spai__precond_3_01viennacl_1_1compressed__matrix_3_01_scalar_type_00_85d4c7cd827146fed2347215919b14e6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">unit_lower_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__lower__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">unit_upper_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__upper__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">upper_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix.  <a href="structviennacl_1_1linalg_1_1upper__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1938ef67659d8ba96e9b9517e680cccf"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">viennacl::linalg::detail::spai::spai_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1938ef67659d8ba96e9b9517e680cccf">spai_tag</a></td></tr>
<tr class="separator:a1938ef67659d8ba96e9b9517e680cccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87a5b5e7c60eee5c2e45f9ab21c935c"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html">viennacl::linalg::detail::spai::fspai_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab87a5b5e7c60eee5c2e45f9ab21c935c">fspai_tag</a></td></tr>
<tr class="separator:ab87a5b5e7c60eee5c2e45f9ab21c935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3ba810acdca541a5eada4560982a645c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3ba810acdca541a5eada4560982a645c">amg_coarsening_method</a> { <a class="el" href="namespaceviennacl_1_1linalg.html#a3ba810acdca541a5eada4560982a645ca5167faa7286ca297508f581b26a048dc">AMG_COARSENING_METHOD_ONEPASS</a> = 1, 
<a class="el" href="namespaceviennacl_1_1linalg.html#a3ba810acdca541a5eada4560982a645ca867e1cc6319da3a2d502c9878d27170d">AMG_COARSENING_METHOD_AGGREGATION</a>, 
<a class="el" href="namespaceviennacl_1_1linalg.html#a3ba810acdca541a5eada4560982a645ca0d4c883a9aa8a8514fb260ac404e3c8b">AMG_COARSENING_METHOD_MIS2_AGGREGATION</a>
 }</td></tr>
<tr class="memdesc:a3ba810acdca541a5eada4560982a645c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of coarsening methods for algebraic multigrid.  <a href="namespaceviennacl_1_1linalg.html#a3ba810acdca541a5eada4560982a645c">More...</a><br/></td></tr>
<tr class="separator:a3ba810acdca541a5eada4560982a645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9933216144a64dbd433ec02c95bbfdd7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9933216144a64dbd433ec02c95bbfdd7">amg_interpolation_method</a> { <a class="el" href="namespaceviennacl_1_1linalg.html#a9933216144a64dbd433ec02c95bbfdd7a48d5bb166d266affee4d526e8671bec2">AMG_INTERPOLATION_METHOD_DIRECT</a> = 1, 
<a class="el" href="namespaceviennacl_1_1linalg.html#a9933216144a64dbd433ec02c95bbfdd7a31dbd459c3ba8068280a6ec1bca00482">AMG_INTERPOLATION_METHOD_AGGREGATION</a>, 
<a class="el" href="namespaceviennacl_1_1linalg.html#a9933216144a64dbd433ec02c95bbfdd7afcffee5ed6e7ad032a9ffebe615b5932">AMG_INTERPOLATION_METHOD_SMOOTHED_AGGREGATION</a>
 }</td></tr>
<tr class="memdesc:a9933216144a64dbd433ec02c95bbfdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of interpolation methods for algebraic multigrid.  <a href="namespaceviennacl_1_1linalg.html#a9933216144a64dbd433ec02c95bbfdd7">More...</a><br/></td></tr>
<tr class="separator:a9933216144a64dbd433ec02c95bbfdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7b596f98d234d40fe9460d0077d1fcc3"><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:a7b596f98d234d40fe9460d0077d1fcc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7b596f98d234d40fe9460d0077d1fcc3">convolve_i</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;output)</td></tr>
<tr class="separator:a7b596f98d234d40fe9460d0077d1fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ab8924636e24b01c6bad13a7321343"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28ab8924636e24b01c6bad13a7321343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__element__binary.html">op_element_binary</a>&lt; <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a28ab8924636e24b01c6bad13a7321343">element_prod</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="separator:a28ab8924636e24b01c6bad13a7321343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3207a7759c34cfe4e961aabadd616a13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3207a7759c34cfe4e961aabadd616a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__element__binary.html">op_element_binary</a>&lt; <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3207a7759c34cfe4e961aabadd616a13">element_div</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="separator:a3207a7759c34cfe4e961aabadd616a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994b34490c41579a04fbd4f95ce00dd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a994b34490c41579a04fbd4f95ce00dd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a994b34490c41579a04fbd4f95ce00dd4">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a994b34490c41579a04fbd4f95ce00dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors - dispatcher interface.  <a href="#a994b34490c41579a04fbd4f95ce00dd4">More...</a><br/></td></tr>
<tr class="separator:a994b34490c41579a04fbd4f95ce00dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2674678361df8200d391360dc6b8631c"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a2674678361df8200d391360dc6b8631c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2674678361df8200d391360dc6b8631c">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a2674678361df8200d391360dc6b8631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c256ba255b9d600f2682f3c10ef1e8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a43c256ba255b9d600f2682f3c10ef1e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a43c256ba255b9d600f2682f3c10ef1e8">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a43c256ba255b9d600f2682f3c10ef1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b652a0b60f992dc7c2c89c8305c628"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename T &gt; </td></tr>
<tr class="memitem:a34b652a0b60f992dc7c2c89c8305c628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a34b652a0b60f992dc7c2c89c8305c628">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a34b652a0b60f992dc7c2c89c8305c628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e24897b81aa448d7ba7bcb4b7c0befa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e24897b81aa448d7ba7bcb4b7c0befa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e24897b81aa448d7ba7bcb4b7c0befa">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr class="memdesc:a6e24897b81aa448d7ba7bcb4b7c0befa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors with the final reduction step on the CPU - dispatcher interface.  <a href="#a6e24897b81aa448d7ba7bcb4b7c0befa">More...</a><br/></td></tr>
<tr class="separator:a6e24897b81aa448d7ba7bcb4b7c0befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be57ce7d327b479a4e9dc8bf0cb43ac"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a0be57ce7d327b479a4e9dc8bf0cb43ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0be57ce7d327b479a4e9dc8bf0cb43ac">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr class="separator:a0be57ce7d327b479a4e9dc8bf0cb43ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e83011f9d11da294199a39c8ca24af9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a6e83011f9d11da294199a39c8ca24af9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e83011f9d11da294199a39c8ca24af9">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr class="separator:a6e83011f9d11da294199a39c8ca24af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592732c3d41ad443d78d8976cdf511e4"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename S3 &gt; </td></tr>
<tr class="memitem:a592732c3d41ad443d78d8976cdf511e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a592732c3d41ad443d78d8976cdf511e4">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, S3 &amp;result)</td></tr>
<tr class="separator:a592732c3d41ad443d78d8976cdf511e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126a98d0d6306dcb6079dd242d7570d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6126a98d0d6306dcb6079dd242d7570d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6126a98d0d6306dcb6079dd242d7570d">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a6126a98d0d6306dcb6079dd242d7570d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector - dispatcher interface.  <a href="#a6126a98d0d6306dcb6079dd242d7570d">More...</a><br/></td></tr>
<tr class="separator:a6126a98d0d6306dcb6079dd242d7570d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2487c579ee752a9fcc31c12d0bddf604"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a2487c579ee752a9fcc31c12d0bddf604"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2487c579ee752a9fcc31c12d0bddf604">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a2487c579ee752a9fcc31c12d0bddf604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf0050426d4b7147d50588919f690da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcf0050426d4b7147d50588919f690da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abcf0050426d4b7147d50588919f690da">norm_1_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:abcf0050426d4b7147d50588919f690da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU.  <a href="#abcf0050426d4b7147d50588919f690da">More...</a><br/></td></tr>
<tr class="separator:abcf0050426d4b7147d50588919f690da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215de6e882e7e3ac0b62da887a88b827"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:a215de6e882e7e3ac0b62da887a88b827"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a215de6e882e7e3ac0b62da887a88b827">norm_1_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:a215de6e882e7e3ac0b62da887a88b827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a215de6e882e7e3ac0b62da887a88b827">More...</a><br/></td></tr>
<tr class="separator:a215de6e882e7e3ac0b62da887a88b827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf5182473bb609dedc9c85148553b55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aabf5182473bb609dedc9c85148553b55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aabf5182473bb609dedc9c85148553b55">norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:aabf5182473bb609dedc9c85148553b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - dispatcher interface.  <a href="#aabf5182473bb609dedc9c85148553b55">More...</a><br/></td></tr>
<tr class="separator:aabf5182473bb609dedc9c85148553b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cab21b7d6b7e0e73c2ca2c20170eafd"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a2cab21b7d6b7e0e73c2ca2c20170eafd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2cab21b7d6b7e0e73c2ca2c20170eafd">norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a2cab21b7d6b7e0e73c2ca2c20170eafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#a2cab21b7d6b7e0e73c2ca2c20170eafd">More...</a><br/></td></tr>
<tr class="separator:a2cab21b7d6b7e0e73c2ca2c20170eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029d42a0d83d6db9f4737ee3443cbeb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a029d42a0d83d6db9f4737ee3443cbeb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a029d42a0d83d6db9f4737ee3443cbeb0">norm_2_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a029d42a0d83d6db9f4737ee3443cbeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - dispatcher interface.  <a href="#a029d42a0d83d6db9f4737ee3443cbeb0">More...</a><br/></td></tr>
<tr class="separator:a029d42a0d83d6db9f4737ee3443cbeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7076e4aae076d5038c880273414dda"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:a6f7076e4aae076d5038c880273414dda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6f7076e4aae076d5038c880273414dda">norm_2_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:a6f7076e4aae076d5038c880273414dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a6f7076e4aae076d5038c880273414dda">More...</a><br/></td></tr>
<tr class="separator:a6f7076e4aae076d5038c880273414dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e31dfc478858db3fc0febbf9bf360d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e31dfc478858db3fc0febbf9bf360d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e31dfc478858db3fc0febbf9bf360d0">norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a6e31dfc478858db3fc0febbf9bf360d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a6e31dfc478858db3fc0febbf9bf360d0">More...</a><br/></td></tr>
<tr class="separator:a6e31dfc478858db3fc0febbf9bf360d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2940be20884af6f718f1ef1882e4b09e"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a2940be20884af6f718f1ef1882e4b09e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2940be20884af6f718f1ef1882e4b09e">norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a2940be20884af6f718f1ef1882e4b09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#a2940be20884af6f718f1ef1882e4b09e">More...</a><br/></td></tr>
<tr class="separator:a2940be20884af6f718f1ef1882e4b09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5a2876bc65af939fc449ec07f33e6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c5a2876bc65af939fc449ec07f33e6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6c5a2876bc65af939fc449ec07f33e6f">norm_inf_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a6c5a2876bc65af939fc449ec07f33e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector with final reduction on the CPU.  <a href="#a6c5a2876bc65af939fc449ec07f33e6f">More...</a><br/></td></tr>
<tr class="separator:a6c5a2876bc65af939fc449ec07f33e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79e3c0b81933fcd016f62ede5daa94b"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:aa79e3c0b81933fcd016f62ede5daa94b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa79e3c0b81933fcd016f62ede5daa94b">norm_inf_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:aa79e3c0b81933fcd016f62ede5daa94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#aa79e3c0b81933fcd016f62ede5daa94b">More...</a><br/></td></tr>
<tr class="separator:aa79e3c0b81933fcd016f62ede5daa94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ba2d9041f7c09bfb2f0ec65f8cf63c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4ba2d9041f7c09bfb2f0ec65f8cf63c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac4ba2d9041f7c09bfb2f0ec65f8cf63c">max_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:ac4ba2d9041f7c09bfb2f0ec65f8cf63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a454946f278e2e94199871f55c081a"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:ac7a454946f278e2e94199871f55c081a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac7a454946f278e2e94199871f55c081a">max_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:ac7a454946f278e2e94199871f55c081a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c55f3b63164f620aace12af5366cd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94c55f3b63164f620aace12af5366cd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a94c55f3b63164f620aace12af5366cd8">max_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a94c55f3b63164f620aace12af5366cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum of a vector with final reduction on the CPU.  <a href="#a94c55f3b63164f620aace12af5366cd8">More...</a><br/></td></tr>
<tr class="separator:a94c55f3b63164f620aace12af5366cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af754ca05f664675f759aca2de035bc7a"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:af754ca05f664675f759aca2de035bc7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af754ca05f664675f759aca2de035bc7a">max_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:af754ca05f664675f759aca2de035bc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#af754ca05f664675f759aca2de035bc7a">More...</a><br/></td></tr>
<tr class="separator:af754ca05f664675f759aca2de035bc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63df0f54d270c1f43f87f21305500f5e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63df0f54d270c1f43f87f21305500f5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a63df0f54d270c1f43f87f21305500f5e">min_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a63df0f54d270c1f43f87f21305500f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add42dc3329c401285f39cb6d6e0000e2"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:add42dc3329c401285f39cb6d6e0000e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#add42dc3329c401285f39cb6d6e0000e2">min_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:add42dc3329c401285f39cb6d6e0000e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0dc4f1adb29d19e1b55519024eeb4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a0dc4f1adb29d19e1b55519024eeb4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5a0dc4f1adb29d19e1b55519024eeb4f">min_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a5a0dc4f1adb29d19e1b55519024eeb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum of a vector with final reduction on the CPU.  <a href="#a5a0dc4f1adb29d19e1b55519024eeb4f">More...</a><br/></td></tr>
<tr class="separator:a5a0dc4f1adb29d19e1b55519024eeb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f228d570bffac37abb106970b08532"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:ad6f228d570bffac37abb106970b08532"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad6f228d570bffac37abb106970b08532">min_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:ad6f228d570bffac37abb106970b08532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#ad6f228d570bffac37abb106970b08532">More...</a><br/></td></tr>
<tr class="separator:ad6f228d570bffac37abb106970b08532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ec50ed65cf65aac0a0d01706370f39"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98ec50ed65cf65aac0a0d01706370f39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a98ec50ed65cf65aac0a0d01706370f39">sum_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a98ec50ed65cf65aac0a0d01706370f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4727940e3c347e78e154a9df15a8d74"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:ad4727940e3c347e78e154a9df15a8d74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad4727940e3c347e78e154a9df15a8d74">sum_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:ad4727940e3c347e78e154a9df15a8d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45afae73aac6a14d0b5c46053ff3b08b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45afae73aac6a14d0b5c46053ff3b08b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a45afae73aac6a14d0b5c46053ff3b08b">sum_cpu</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a45afae73aac6a14d0b5c46053ff3b08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of a vector with final reduction on the CPU.  <a href="#a45afae73aac6a14d0b5c46053ff3b08b">More...</a><br/></td></tr>
<tr class="separator:a45afae73aac6a14d0b5c46053ff3b08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd49659a7210abda3960382288a7160"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:a4fd49659a7210abda3960382288a7160"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4fd49659a7210abda3960382288a7160">sum_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:a4fd49659a7210abda3960382288a7160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a4fd49659a7210abda3960382288a7160">More...</a><br/></td></tr>
<tr class="separator:a4fd49659a7210abda3960382288a7160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d50400363dab7d4edef7d9f67954c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8d50400363dab7d4edef7d9f67954c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af8d50400363dab7d4edef7d9f67954c9">norm_frobenius_impl</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; T &gt; const &amp;A, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:af8d50400363dab7d4edef7d9f67954c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Frobenius norm of a matrix - dispatcher interface.  <a href="#af8d50400363dab7d4edef7d9f67954c9">More...</a><br/></td></tr>
<tr class="separator:af8d50400363dab7d4edef7d9f67954c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefc10657837355dd686f359e2f2bdd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acefc10657837355dd686f359e2f2bdd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acefc10657837355dd686f359e2f2bdd3">norm_frobenius_cpu</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; T &gt; const &amp;A, T &amp;result)</td></tr>
<tr class="memdesc:acefc10657837355dd686f359e2f2bdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Frobenius norm of a vector with final reduction on the CPU.  <a href="#acefc10657837355dd686f359e2f2bdd3">More...</a><br/></td></tr>
<tr class="separator:acefc10657837355dd686f359e2f2bdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ca8c9792940a5cf845c844495b2f49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94ca8c9792940a5cf845c844495b2f49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a94ca8c9792940a5cf845c844495b2f49">index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a94ca8c9792940a5cf845c844495b2f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#a94ca8c9792940a5cf845c844495b2f49">More...</a><br/></td></tr>
<tr class="separator:a94ca8c9792940a5cf845c844495b2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561f11b3404e4657b4e8dbc971488836"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a561f11b3404e4657b4e8dbc971488836"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a561f11b3404e4657b4e8dbc971488836">index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a561f11b3404e4657b4e8dbc971488836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a561f11b3404e4657b4e8dbc971488836">More...</a><br/></td></tr>
<tr class="separator:a561f11b3404e4657b4e8dbc971488836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc6db8d806f67c24f93eaaded84b853"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aafc6db8d806f67c24f93eaaded84b853"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aafc6db8d806f67c24f93eaaded84b853">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:aafc6db8d806f67c24f93eaaded84b853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#aafc6db8d806f67c24f93eaaded84b853">More...</a><br/></td></tr>
<tr class="separator:aafc6db8d806f67c24f93eaaded84b853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e5d39428cebc0a54a6ba2c10a3f73c"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ac3e5d39428cebc0a54a6ba2c10a3f73c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac3e5d39428cebc0a54a6ba2c10a3f73c">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;mat_trans, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ac3e5d39428cebc0a54a6ba2c10a3f73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#ac3e5d39428cebc0a54a6ba2c10a3f73c">More...</a><br/></td></tr>
<tr class="separator:ac3e5d39428cebc0a54a6ba2c10a3f73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a946e478e53f6464d1dedeb3a46c89"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:ae7a946e478e53f6464d1dedeb3a46c89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
SparseMatrixType, const <a class="el" href="classviennacl_1_1vector.html">vector</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae7a946e478e53f6464d1dedeb3a46c89">prod_impl</a> (const SparseMatrixType &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)</td></tr>
<tr class="separator:ae7a946e478e53f6464d1dedeb3a46c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989dc9f1224caf70090b16ba7e0caffb"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a989dc9f1224caf70090b16ba7e0caffb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a989dc9f1224caf70090b16ba7e0caffb">row_sum_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="separator:a989dc9f1224caf70090b16ba7e0caffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa27d986659389c74adfa0744590afc2"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aaa27d986659389c74adfa0744590afc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa27d986659389c74adfa0744590afc2">column_sum_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="separator:aaa27d986659389c74adfa0744590afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9b329b64ac782e6a5687ad2fc47a2a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT , typename PreconditionerT &gt; </td></tr>
<tr class="memitem:a6e9b329b64ac782e6a5687ad2fc47a2a"><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag, PreconditionerT const &amp;precond)</td></tr>
<tr class="separator:a6e9b329b64ac782e6a5687ad2fc47a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec0a2656d4cf6648f999bb2a99a332a"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename NumericT , typename PreconditionerT &gt; </td></tr>
<tr class="memitem:acec0a2656d4cf6648f999bb2a99a332a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acec0a2656d4cf6648f999bb2a99a332a">solve</a> (std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;A, std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag, PreconditionerT const &amp;precond)</td></tr>
<tr class="memdesc:acec0a2656d4cf6648f999bb2a99a332a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload for calling the preconditioned BiCGStab solver using types from the C++ STL.  <a href="#acec0a2656d4cf6648f999bb2a99a332a">More...</a><br/></td></tr>
<tr class="separator:acec0a2656d4cf6648f999bb2a99a332a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcecbbb0d1af0b546c1464c0b8445b61"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:abcecbbb0d1af0b546c1464c0b8445b61"><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abcecbbb0d1af0b546c1464c0b8445b61">solve</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:abcecbbb0d1af0b546c1464c0b8445b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for the unpreconditioned BiCGStab method.  <a href="#abcecbbb0d1af0b546c1464c0b8445b61">More...</a><br/></td></tr>
<tr class="separator:abcecbbb0d1af0b546c1464c0b8445b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d70c731aed90556e228b7f14ac3a52"><td class="memTemplParams" colspan="2">template&lt;typename VectorT &gt; </td></tr>
<tr class="memitem:a54d70c731aed90556e228b7f14ac3a52"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; typename VectorT::value_type &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a54d70c731aed90556e228b7f14ac3a52">bisect</a> (VectorT const &amp;alphas, VectorT const &amp;betas)</td></tr>
<tr class="memdesc:a54d70c731aed90556e228b7f14ac3a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the bisect-algorithm for the calculation of the eigenvalues of a tridiagonal matrix. Experimental - interface might change.  <a href="#a54d70c731aed90556e228b7f14ac3a52">More...</a><br/></td></tr>
<tr class="separator:a54d70c731aed90556e228b7f14ac3a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e162beeda5427abc31ad04af903f75"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a57e162beeda5427abc31ad04af903f75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a57e162beeda5427abc31ad04af903f75">bisect</a> (const std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;diagonal, const std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;superdiagonal, std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;eigenvalues)</td></tr>
<tr class="memdesc:a57e162beeda5427abc31ad04af903f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">bisect The bisection algorithm computes the eigevalues of a symmetric tridiagonal matrix.  <a href="#a57e162beeda5427abc31ad04af903f75">More...</a><br/></td></tr>
<tr class="separator:a57e162beeda5427abc31ad04af903f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b0d8c9704298545af9ec48ffb242eb"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a04b0d8c9704298545af9ec48ffb242eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a04b0d8c9704298545af9ec48ffb242eb">bisect</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;diagonal, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;superdiagonal, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;eigenvalues)</td></tr>
<tr class="memdesc:a04b0d8c9704298545af9ec48ffb242eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">bisect The bisection algorithm computes the eigevalues of a symmetric tridiagonal matrix.  <a href="#a04b0d8c9704298545af9ec48ffb242eb">More...</a><br/></td></tr>
<tr class="separator:a04b0d8c9704298545af9ec48ffb242eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fad8cb9d4b354019644518915c7f54f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT , typename PreconditionerT &gt; </td></tr>
<tr class="memitem:a2fad8cb9d4b354019644518915c7f54f"><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2fad8cb9d4b354019644518915c7f54f">solve</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag, PreconditionerT const &amp;precond)</td></tr>
<tr class="memdesc:a2fad8cb9d4b354019644518915c7f54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the preconditioned conjugate gradient solver, generic implementation for non-ViennaCL types.  <a href="#a2fad8cb9d4b354019644518915c7f54f">More...</a><br/></td></tr>
<tr class="separator:a2fad8cb9d4b354019644518915c7f54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e8d1aec0a1fac16ec0a9065b1434d7"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename NumericT , typename PreconditionerT &gt; </td></tr>
<tr class="memitem:a52e8d1aec0a1fac16ec0a9065b1434d7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a52e8d1aec0a1fac16ec0a9065b1434d7">solve</a> (std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;A, std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag, PreconditionerT const &amp;precond)</td></tr>
<tr class="memdesc:a52e8d1aec0a1fac16ec0a9065b1434d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload for calling the CG solver using types from the C++ STL.  <a href="#a52e8d1aec0a1fac16ec0a9065b1434d7">More...</a><br/></td></tr>
<tr class="separator:a52e8d1aec0a1fac16ec0a9065b1434d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0679942882efd21c540fac8e78a6d56a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:a0679942882efd21c540fac8e78a6d56a"><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0679942882efd21c540fac8e78a6d56a">solve</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:a0679942882efd21c540fac8e78a6d56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for the unpreconditioned CG method.  <a href="#a0679942882efd21c540fac8e78a6d56a">More...</a><br/></td></tr>
<tr class="separator:a0679942882efd21c540fac8e78a6d56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e5bca2a6154804234c62fb466d8a47"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:ae8e5bca2a6154804234c62fb466d8a47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae8e5bca2a6154804234c62fb466d8a47">prod_impl</a> (<a class="el" href="classviennacl_1_1circulant__matrix.html">viennacl::circulant_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ae8e5bca2a6154804234c62fb466d8a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class. ">circulant_matrix</a>.  <a href="#ae8e5bca2a6154804234c62fb466d8a47">More...</a><br/></td></tr>
<tr class="separator:ae8e5bca2a6154804234c62fb466d8a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92ae6061c4ac82fdea8230c9877badc"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ae92ae6061c4ac82fdea8230c9877badc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae92ae6061c4ac82fdea8230c9877badc">precondition</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, <a class="el" href="classviennacl_1_1linalg_1_1ilu0__tag.html">ilu0_tag</a> const &amp;)</td></tr>
<tr class="memdesc:ae92ae6061c4ac82fdea8230c9877badc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a ILU-preconditioner with static pattern. Optimized version for CSR matrices.  <a href="#ae92ae6061c4ac82fdea8230c9877badc">More...</a><br/></td></tr>
<tr class="separator:ae92ae6061c4ac82fdea8230c9877badc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabecdfbc7ea786184aa5044db47a14b7"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aabecdfbc7ea786184aa5044db47a14b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aabecdfbc7ea786184aa5044db47a14b7">precondition</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;L, <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;U, <a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html">ilut_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:aabecdfbc7ea786184aa5044db47a14b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a ILU-preconditioner with threshold. Optimized implementation for <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a>.  <a href="#aabecdfbc7ea786184aa5044db47a14b7">More...</a><br/></td></tr>
<tr class="separator:aabecdfbc7ea786184aa5044db47a14b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf06f61be9418e5817eed66004f9dd2b"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:adf06f61be9418e5817eed66004f9dd2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;B, SolverTagT)</td></tr>
<tr class="memdesc:adf06f61be9418e5817eed66004f9dd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notation)  <a href="#adf06f61be9418e5817eed66004f9dd2b">More...</a><br/></td></tr>
<tr class="separator:adf06f61be9418e5817eed66004f9dd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfff27023e7934e8fc91add06a00015"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:aacfff27023e7934e8fc91add06a00015"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aacfff27023e7934e8fc91add06a00015">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; proxy_B, SolverTagT)</td></tr>
<tr class="memdesc:aacfff27023e7934e8fc91add06a00015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for triangular systems with multiple transposed right hand sides, i.e. A \ B^T (MATLAB notation)  <a href="#aacfff27023e7934e8fc91add06a00015">More...</a><br/></td></tr>
<tr class="separator:aacfff27023e7934e8fc91add06a00015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf694e493220c997a56117180898e34d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:aaf694e493220c997a56117180898e34d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaf694e493220c997a56117180898e34d">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;B, SolverTagT)</td></tr>
<tr class="memdesc:aaf694e493220c997a56117180898e34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for transposed triangular systems with multiple right hand sides, i.e. A^T \ B (MATLAB notation)  <a href="#aaf694e493220c997a56117180898e34d">More...</a><br/></td></tr>
<tr class="separator:aaf694e493220c997a56117180898e34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46903287704fb77078a994bbe7450c3"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:ab46903287704fb77078a994bbe7450c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab46903287704fb77078a994bbe7450c3">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; const &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; proxy_B, SolverTagT)</td></tr>
<tr class="memdesc:ab46903287704fb77078a994bbe7450c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for transposed triangular systems with multiple transposed right hand sides, i.e. A^T \ B^T (MATLAB notation)  <a href="#ab46903287704fb77078a994bbe7450c3">More...</a><br/></td></tr>
<tr class="separator:ab46903287704fb77078a994bbe7450c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5dfe2ca91ca582638c39016c0a208e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:a1c5dfe2ca91ca582638c39016c0a208e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1c5dfe2ca91ca582638c39016c0a208e">solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;B, SolverTagT tag)</td></tr>
<tr class="memdesc:a1c5dfe2ca91ca582638c39016c0a208e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for C = solve(A, B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a>  <a href="#a1c5dfe2ca91ca582638c39016c0a208e">More...</a><br/></td></tr>
<tr class="separator:a1c5dfe2ca91ca582638c39016c0a208e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e8ed654f145cb91cd73e759603683c"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:ac8e8ed654f145cb91cd73e759603683c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac8e8ed654f145cb91cd73e759603683c">solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy, SolverTagT tag)</td></tr>
<tr class="memdesc:ac8e8ed654f145cb91cd73e759603683c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for C = solve(A, B^T, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a>  <a href="#ac8e8ed654f145cb91cd73e759603683c">More...</a><br/></td></tr>
<tr class="separator:ac8e8ed654f145cb91cd73e759603683c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a61b45de1633dab2c70d4e0f7d6b58e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:a3a61b45de1633dab2c70d4e0f7d6b58e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3a61b45de1633dab2c70d4e0f7d6b58e">solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;B, SolverTagT tag)</td></tr>
<tr class="memdesc:a3a61b45de1633dab2c70d4e0f7d6b58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a>  <a href="#a3a61b45de1633dab2c70d4e0f7d6b58e">More...</a><br/></td></tr>
<tr class="separator:a3a61b45de1633dab2c70d4e0f7d6b58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff7d3cc1ecf2686dcb0795d188ecdf0"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:a8ff7d3cc1ecf2686dcb0795d188ecdf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8ff7d3cc1ecf2686dcb0795d188ecdf0">solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy_A, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy_B, SolverTagT tag)</td></tr>
<tr class="memdesc:a8ff7d3cc1ecf2686dcb0795d188ecdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a>  <a href="#a8ff7d3cc1ecf2686dcb0795d188ecdf0">More...</a><br/></td></tr>
<tr class="separator:a8ff7d3cc1ecf2686dcb0795d188ecdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09afb0da48b9fe60af6bd01f59e31f50"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:a09afb0da48b9fe60af6bd01f59e31f50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a09afb0da48b9fe60af6bd01f59e31f50">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, SolverTagT const &amp;tag)</td></tr>
<tr class="memdesc:a09afb0da48b9fe60af6bd01f59e31f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a triangular system. Matlab notation A \ b.  <a href="#a09afb0da48b9fe60af6bd01f59e31f50">More...</a><br/></td></tr>
<tr class="separator:a09afb0da48b9fe60af6bd01f59e31f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2d1656abbdd59e83cb335f22f94743"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:adf2d1656abbdd59e83cb335f22f94743"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adf2d1656abbdd59e83cb335f22f94743">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, SolverTagT const &amp;tag)</td></tr>
<tr class="memdesc:adf2d1656abbdd59e83cb335f22f94743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a triangular system with transposed system matrix.. Matlab notation A' \ b.  <a href="#adf2d1656abbdd59e83cb335f22f94743">More...</a><br/></td></tr>
<tr class="separator:adf2d1656abbdd59e83cb335f22f94743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d7887a8badaa283e9522d63a611a56"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ae6d7887a8badaa283e9522d63a611a56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae6d7887a8badaa283e9522d63a611a56">solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:ae6d7887a8badaa283e9522d63a611a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for result = solve(mat, vec, upper_tag()); for an upper triangular solve.  <a href="#ae6d7887a8badaa283e9522d63a611a56">More...</a><br/></td></tr>
<tr class="separator:ae6d7887a8badaa283e9522d63a611a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76b5c350f25569a8c503ab102289dfa"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ac76b5c350f25569a8c503ab102289dfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac76b5c350f25569a8c503ab102289dfa">solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:ac76b5c350f25569a8c503ab102289dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for result = solve(mat, vec, upper_tag()); for an upper triangular solve with unit diagonal.  <a href="#ac76b5c350f25569a8c503ab102289dfa">More...</a><br/></td></tr>
<tr class="separator:ac76b5c350f25569a8c503ab102289dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b295af009d30ee10ba558b5cae9fcfa"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a7b295af009d30ee10ba558b5cae9fcfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7b295af009d30ee10ba558b5cae9fcfa">solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:a7b295af009d30ee10ba558b5cae9fcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for result = solve(mat, vec, upper_tag()); for a lower triangular solve.  <a href="#a7b295af009d30ee10ba558b5cae9fcfa">More...</a><br/></td></tr>
<tr class="separator:a7b295af009d30ee10ba558b5cae9fcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b19fc27005f6e13a9ee981965a5e97"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a87b19fc27005f6e13a9ee981965a5e97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a87b19fc27005f6e13a9ee981965a5e97">solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:a87b19fc27005f6e13a9ee981965a5e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for result = solve(mat, vec, upper_tag()); for a lower triangular solve with unit diagonal.  <a href="#a87b19fc27005f6e13a9ee981965a5e97">More...</a><br/></td></tr>
<tr class="separator:a87b19fc27005f6e13a9ee981965a5e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c2e482814cd46a9dc139af45d5977e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SolverTagT &gt; </td></tr>
<tr class="memitem:ac0c2e482814cd46a9dc139af45d5977e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac0c2e482814cd46a9dc139af45d5977e">solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, SolverTagT const &amp;tag)</td></tr>
<tr class="memdesc:ac0c2e482814cd46a9dc139af45d5977e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a>  <a href="#ac0c2e482814cd46a9dc139af45d5977e">More...</a><br/></td></tr>
<tr class="separator:ac0c2e482814cd46a9dc139af45d5977e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08098ec11a08f2989e4bdd69006e528"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:ae08098ec11a08f2989e4bdd69006e528"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae08098ec11a08f2989e4bdd69006e528">direct</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;in, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;out, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> stride, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> batch_num, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> sign=<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>(-1), <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a> data_order=<a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a>)</td></tr>
<tr class="memdesc:ae08098ec11a08f2989e4bdd69006e528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct 1D algorithm for computing Fourier transformation.  <a href="#ae08098ec11a08f2989e4bdd69006e528">More...</a><br/></td></tr>
<tr class="separator:ae08098ec11a08f2989e4bdd69006e528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af306ba22f2e1a5617990d7756fce3a18"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:af306ba22f2e1a5617990d7756fce3a18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af306ba22f2e1a5617990d7756fce3a18">direct</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; const &amp;in, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; &amp;out, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> stride, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> batch_num, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> sign=<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>(-1), <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a> data_order=<a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a>)</td></tr>
<tr class="memdesc:af306ba22f2e1a5617990d7756fce3a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct 2D algorithm for computing Fourier transformation.  <a href="#af306ba22f2e1a5617990d7756fce3a18">More...</a><br/></td></tr>
<tr class="separator:af306ba22f2e1a5617990d7756fce3a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e762eac66a1c45136f2beb12f8eea6"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a81e762eac66a1c45136f2beb12f8eea6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a81e762eac66a1c45136f2beb12f8eea6">reorder</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;in, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> stride, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> bits_datasize, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> batch_num, <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a> data_order=<a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a>)</td></tr>
<tr class="separator:a81e762eac66a1c45136f2beb12f8eea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824a7dd4e1dd0dd3a7698b1f1bffc431"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a824a7dd4e1dd0dd3a7698b1f1bffc431"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a824a7dd4e1dd0dd3a7698b1f1bffc431">radix2</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; &amp;in, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> stride, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> batch_num, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> sign=<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>(-1), <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a> data_order=<a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a>)</td></tr>
<tr class="memdesc:a824a7dd4e1dd0dd3a7698b1f1bffc431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radix-2 1D algorithm for computing Fourier transformation.  <a href="#a824a7dd4e1dd0dd3a7698b1f1bffc431">More...</a><br/></td></tr>
<tr class="separator:a824a7dd4e1dd0dd3a7698b1f1bffc431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dd345e5bec9894f6272e04b1f08602"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a61dd345e5bec9894f6272e04b1f08602"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a61dd345e5bec9894f6272e04b1f08602">radix2</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;in, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> stride, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> batch_num, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> sign=<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>(-1), <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a> data_order=<a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a>)</td></tr>
<tr class="memdesc:a61dd345e5bec9894f6272e04b1f08602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radix-2 2D algorithm for computing Fourier transformation.  <a href="#a61dd345e5bec9894f6272e04b1f08602">More...</a><br/></td></tr>
<tr class="separator:a61dd345e5bec9894f6272e04b1f08602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da8975bfe53f8a05145c8b44410ab27"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a4da8975bfe53f8a05145c8b44410ab27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4da8975bfe53f8a05145c8b44410ab27">bluestein</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;in, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;out, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a>)</td></tr>
<tr class="memdesc:a4da8975bfe53f8a05145c8b44410ab27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bluestein's algorithm for computing Fourier transformation.  <a href="#a4da8975bfe53f8a05145c8b44410ab27">More...</a><br/></td></tr>
<tr class="separator:a4da8975bfe53f8a05145c8b44410ab27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89501246ebdf434e5181cfa83116cb1"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:ad89501246ebdf434e5181cfa83116cb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad89501246ebdf434e5181cfa83116cb1">multiply_complex</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;input1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;input2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;output)</td></tr>
<tr class="memdesc:ad89501246ebdf434e5181cfa83116cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutiply two complex vectors and store result in output.  <a href="#ad89501246ebdf434e5181cfa83116cb1">More...</a><br/></td></tr>
<tr class="separator:ad89501246ebdf434e5181cfa83116cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867024b8e563104417fc09e675a1e931"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a867024b8e563104417fc09e675a1e931"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a867024b8e563104417fc09e675a1e931">normalize</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;input)</td></tr>
<tr class="memdesc:a867024b8e563104417fc09e675a1e931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize vector on with his own size.  <a href="#a867024b8e563104417fc09e675a1e931">More...</a><br/></td></tr>
<tr class="separator:a867024b8e563104417fc09e675a1e931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae829451e793471ca5e8751cf89fec950"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:ae829451e793471ca5e8751cf89fec950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae829451e793471ca5e8751cf89fec950">transpose</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; &amp;input)</td></tr>
<tr class="memdesc:ae829451e793471ca5e8751cf89fec950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace_transpose matrix.  <a href="#ae829451e793471ca5e8751cf89fec950">More...</a><br/></td></tr>
<tr class="separator:ae829451e793471ca5e8751cf89fec950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c67f0718cac71823eed6758492defda"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a3c67f0718cac71823eed6758492defda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3c67f0718cac71823eed6758492defda">transpose</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; const &amp;input, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; &amp;output)</td></tr>
<tr class="memdesc:a3c67f0718cac71823eed6758492defda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose matrix.  <a href="#a3c67f0718cac71823eed6758492defda">More...</a><br/></td></tr>
<tr class="separator:a3c67f0718cac71823eed6758492defda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46594affa4b4f500660ea741cc1582a"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ab46594affa4b4f500660ea741cc1582a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab46594affa4b4f500660ea741cc1582a">real_to_complex</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;in, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;out, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> size)</td></tr>
<tr class="memdesc:ab46594affa4b4f500660ea741cc1582a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create complex vector from real vector (even elements(2*k) = real part, odd elements(2*k+1) = imaginary part)  <a href="#ab46594affa4b4f500660ea741cc1582a">More...</a><br/></td></tr>
<tr class="separator:ab46594affa4b4f500660ea741cc1582a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f767da9ec63fd7e37c1fae58dc2727"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a45f767da9ec63fd7e37c1fae58dc2727"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a45f767da9ec63fd7e37c1fae58dc2727">complex_to_real</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;in, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;out, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> size)</td></tr>
<tr class="memdesc:a45f767da9ec63fd7e37c1fae58dc2727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create real vector from complex vector (even elements(2*k) = real part, odd elements(2*k+1) = imaginary part)  <a href="#a45f767da9ec63fd7e37c1fae58dc2727">More...</a><br/></td></tr>
<tr class="separator:a45f767da9ec63fd7e37c1fae58dc2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65decb368dc002ff34334fa0918add2b"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a65decb368dc002ff34334fa0918add2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a65decb368dc002ff34334fa0918add2b">reverse</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;in)</td></tr>
<tr class="memdesc:a65decb368dc002ff34334fa0918add2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse vector to oposite order and save it in input vector.  <a href="#a65decb368dc002ff34334fa0918add2b">More...</a><br/></td></tr>
<tr class="separator:a65decb368dc002ff34334fa0918add2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c0a087d090d74573763d9dd48c9074"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT , typename PreconditionerT &gt; </td></tr>
<tr class="memitem:af6c0a087d090d74573763d9dd48c9074"><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af6c0a087d090d74573763d9dd48c9074">solve</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a> const &amp;tag, PreconditionerT const &amp;precond)</td></tr>
<tr class="separator:af6c0a087d090d74573763d9dd48c9074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c979c1bdf04f724d1b32c7789b563d"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename NumericT , typename PreconditionerT &gt; </td></tr>
<tr class="memitem:a70c979c1bdf04f724d1b32c7789b563d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a70c979c1bdf04f724d1b32c7789b563d">solve</a> (std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;A, std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a> const &amp;tag, PreconditionerT const &amp;precond)</td></tr>
<tr class="memdesc:a70c979c1bdf04f724d1b32c7789b563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload for calling the preconditioned BiCGStab solver using types from the C++ STL.  <a href="#a70c979c1bdf04f724d1b32c7789b563d">More...</a><br/></td></tr>
<tr class="separator:a70c979c1bdf04f724d1b32c7789b563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34f2a4be7c82ecf4fd10e05ecc24273"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:ac34f2a4be7c82ecf4fd10e05ecc24273"><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac34f2a4be7c82ecf4fd10e05ecc24273">solve</a> (MatrixT const &amp;A, VectorT const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:ac34f2a4be7c82ecf4fd10e05ecc24273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for the unpreconditioned GMRES method.  <a href="#ac34f2a4be7c82ecf4fd10e05ecc24273">More...</a><br/></td></tr>
<tr class="separator:ac34f2a4be7c82ecf4fd10e05ecc24273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df39ef1d7dacadae32160d335ffa44"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:ab7df39ef1d7dacadae32160d335ffa44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab7df39ef1d7dacadae32160d335ffa44">prod_impl</a> (<a class="el" href="classviennacl_1_1hankel__matrix.html">viennacl::hankel_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ab7df39ef1d7dacadae32160d335ffa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class. ">hankel_matrix</a>.  <a href="#ab7df39ef1d7dacadae32160d335ffa44">More...</a><br/></td></tr>
<tr class="separator:ab7df39ef1d7dacadae32160d335ffa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674c204660f61ec3c8b881fe86ef1dfd"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a674c204660f61ec3c8b881fe86ef1dfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a674c204660f61ec3c8b881fe86ef1dfd">precondition</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, <a class="el" href="classviennacl_1_1linalg_1_1ichol0__tag.html">ichol0_tag</a> const &amp;)</td></tr>
<tr class="memdesc:a674c204660f61ec3c8b881fe86ef1dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a ILU-preconditioner with static pattern. Optimized version for CSR matrices.  <a href="#a674c204660f61ec3c8b881fe86ef1dfd">More...</a><br/></td></tr>
<tr class="separator:a674c204660f61ec3c8b881fe86ef1dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe38139ef1b1fa4581104998c73ec424"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:afe38139ef1b1fa4581104998c73ec424"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afe38139ef1b1fa4581104998c73ec424">extract_L</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;L)</td></tr>
<tr class="memdesc:afe38139ef1b1fa4581104998c73ec424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the lower triangular part L from A.  <a href="#afe38139ef1b1fa4581104998c73ec424">More...</a><br/></td></tr>
<tr class="separator:afe38139ef1b1fa4581104998c73ec424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d5695fc60367c6d3240ba6d693c015"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad3d5695fc60367c6d3240ba6d693c015"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad3d5695fc60367c6d3240ba6d693c015">icc_scale</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;L)</td></tr>
<tr class="memdesc:ad3d5695fc60367c6d3240ba6d693c015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the values extracted from A such that A' = DAD has unit diagonal. Updates values from A in L accordingly.  <a href="#ad3d5695fc60367c6d3240ba6d693c015">More...</a><br/></td></tr>
<tr class="separator:ad3d5695fc60367c6d3240ba6d693c015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fb87042a449e9544121d6f3e004fd0"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a15fb87042a449e9544121d6f3e004fd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a15fb87042a449e9544121d6f3e004fd0">icc_chow_patel_sweep</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;L, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;aij_L)</td></tr>
<tr class="memdesc:a15fb87042a449e9544121d6f3e004fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs one nonlinear relaxation step in the Chow-Patel-ICC (cf. Algorithm 3 in paper, but for L rather than U)  <a href="#a15fb87042a449e9544121d6f3e004fd0">More...</a><br/></td></tr>
<tr class="separator:a15fb87042a449e9544121d6f3e004fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61379d44e4a0d7a05f0b327424796ca1"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a61379d44e4a0d7a05f0b327424796ca1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a61379d44e4a0d7a05f0b327424796ca1">extract_LU</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;L, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;U)</td></tr>
<tr class="memdesc:a61379d44e4a0d7a05f0b327424796ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the lower triangular part L and the upper triangular part U from A.  <a href="#a61379d44e4a0d7a05f0b327424796ca1">More...</a><br/></td></tr>
<tr class="separator:a61379d44e4a0d7a05f0b327424796ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dd52d566f9dbb5fad53131f294fd6e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aa9dd52d566f9dbb5fad53131f294fd6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa9dd52d566f9dbb5fad53131f294fd6e">ilu_scale</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;L, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;U)</td></tr>
<tr class="memdesc:aa9dd52d566f9dbb5fad53131f294fd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the values extracted from A such that A' = DAD has unit diagonal. Updates values from A in L and U accordingly.  <a href="#aa9dd52d566f9dbb5fad53131f294fd6e">More...</a><br/></td></tr>
<tr class="separator:aa9dd52d566f9dbb5fad53131f294fd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba9a2427b8985f9e6f8cb507346df5c"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a6ba9a2427b8985f9e6f8cb507346df5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6ba9a2427b8985f9e6f8cb507346df5c">ilu_transpose</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;B)</td></tr>
<tr class="memdesc:a6ba9a2427b8985f9e6f8cb507346df5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposition B &lt;- A^T, where the aij-vector is permuted in the same way as the value array in A when assigned to B.  <a href="#a6ba9a2427b8985f9e6f8cb507346df5c">More...</a><br/></td></tr>
<tr class="separator:a6ba9a2427b8985f9e6f8cb507346df5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ab7c38b6358aa7c3b71b4a0bb4b55f"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a81ab7c38b6358aa7c3b71b4a0bb4b55f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a81ab7c38b6358aa7c3b71b4a0bb4b55f">ilu_chow_patel_sweep</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;L, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;aij_L, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;U_trans, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;aij_U_trans)</td></tr>
<tr class="memdesc:a81ab7c38b6358aa7c3b71b4a0bb4b55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs one nonlinear relaxation step in the Chow-Patel-ILU (cf. Algorithm 2 in paper)  <a href="#a81ab7c38b6358aa7c3b71b4a0bb4b55f">More...</a><br/></td></tr>
<tr class="separator:a81ab7c38b6358aa7c3b71b4a0bb4b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f852e45ca5d5a753db43033bf4444b"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad9f852e45ca5d5a753db43033bf4444b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad9f852e45ca5d5a753db43033bf4444b">ilu_form_neumann_matrix</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;R, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;diag_R)</td></tr>
<tr class="memdesc:ad9f852e45ca5d5a753db43033bf4444b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the lower triangular part L and the upper triangular part U from A.  <a href="#ad9f852e45ca5d5a753db43033bf4444b">More...</a><br/></td></tr>
<tr class="separator:ad9f852e45ca5d5a753db43033bf4444b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35950c4374eb3be08a03d852508c01a"><td class="memTemplParams" colspan="2">template&lt;typename VectorT1 , typename VectorT2 &gt; </td></tr>
<tr class="memitem:ab35950c4374eb3be08a03d852508c01a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a><br class="typebreak"/>
&lt; VectorT1 &gt;::type &gt;::value, <br class="typebreak"/>
typename VectorT1::value_type &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab35950c4374eb3be08a03d852508c01a">inner_prod</a> (VectorT1 const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, VectorT2 const &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="separator:ab35950c4374eb3be08a03d852508c01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad273e72f4a44fcd9802e3609d06af5e6"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad273e72f4a44fcd9802e3609d06af5e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad273e72f4a44fcd9802e3609d06af5e6">inner_prod</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;vector2)</td></tr>
<tr class="separator:ad273e72f4a44fcd9802e3609d06af5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c12bee75a1dff46f0bd4b48abca2a5"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename NumericT &gt; </td></tr>
<tr class="memitem:ae4c12bee75a1dff46f0bd4b48abca2a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; LHS, RHS, OP &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae4c12bee75a1dff46f0bd4b48abca2a5">inner_prod</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;vector2)</td></tr>
<tr class="separator:ae4c12bee75a1dff46f0bd4b48abca2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71bae6daf6dc8a5803071f79565582a"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:ac71bae6daf6dc8a5803071f79565582a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; LHS, RHS, OP &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac71bae6daf6dc8a5803071f79565582a">inner_prod</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vector2)</td></tr>
<tr class="separator:ac71bae6daf6dc8a5803071f79565582a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac998ca060d47ba7c4b8bc1a994060ac"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr class="memitem:aac998ca060d47ba7c4b8bc1a994060ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; LHS1, RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; LHS2, RHS2, OP2 &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aac998ca060d47ba7c4b8bc1a994060ac">inner_prod</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vector2)</td></tr>
<tr class="separator:aac998ca060d47ba7c4b8bc1a994060ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9ef35327424393d599467538882522"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a3d9ef35327424393d599467538882522"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3d9ef35327424393d599467538882522">inner_prod</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;x, <a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;y_tuple)</td></tr>
<tr class="separator:a3d9ef35327424393d599467538882522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aba6fa27cb6e14b04f527c64a10196"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad5aba6fa27cb6e14b04f527c64a10196"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad5aba6fa27cb6e14b04f527c64a10196">pipelined_cg_vector_update</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;p, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;r, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;Ap, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> beta, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;inner_prod_buffer)</td></tr>
<tr class="memdesc:ad5aba6fa27cb6e14b04f527c64a10196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a joint vector update operation needed for an efficient pipelined CG algorithm.  <a href="#ad5aba6fa27cb6e14b04f527c64a10196">More...</a><br/></td></tr>
<tr class="separator:ad5aba6fa27cb6e14b04f527c64a10196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cde61c393aa96dbf2fe6f32462b18c0"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a1cde61c393aa96dbf2fe6f32462b18c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1cde61c393aa96dbf2fe6f32462b18c0">pipelined_cg_prod</a> (MatrixT const &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;p, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;Ap, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;inner_prod_buffer)</td></tr>
<tr class="memdesc:a1cde61c393aa96dbf2fe6f32462b18c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a joint vector update operation needed for an efficient pipelined CG algorithm.  <a href="#a1cde61c393aa96dbf2fe6f32462b18c0">More...</a><br/></td></tr>
<tr class="separator:a1cde61c393aa96dbf2fe6f32462b18c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f4ef640389f9a074761824cb29ac43"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a53f4ef640389f9a074761824cb29ac43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a53f4ef640389f9a074761824cb29ac43">pipelined_bicgstab_update_s</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;s, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;r, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;Ap, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;inner_prod_buffer, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> buffer_chunk_size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> buffer_chunk_offset)</td></tr>
<tr class="memdesc:a53f4ef640389f9a074761824cb29ac43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a joint vector update operation needed for an efficient pipelined CG algorithm.  <a href="#a53f4ef640389f9a074761824cb29ac43">More...</a><br/></td></tr>
<tr class="separator:a53f4ef640389f9a074761824cb29ac43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793be26a151c2fa6c7478143cdc75bfe"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a793be26a151c2fa6c7478143cdc75bfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a793be26a151c2fa6c7478143cdc75bfe">pipelined_bicgstab_vector_update</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;p, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> omega, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;s, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;residual, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;As, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> beta, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;Ap, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;r0star, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;inner_prod_buffer, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> buffer_chunk_size)</td></tr>
<tr class="memdesc:a793be26a151c2fa6c7478143cdc75bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a joint vector update operation needed for an efficient pipelined BiCGStab algorithm.  <a href="#a793be26a151c2fa6c7478143cdc75bfe">More...</a><br/></td></tr>
<tr class="separator:a793be26a151c2fa6c7478143cdc75bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c2c1f1a8eb05b116d9b1274243b38"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:ab66c2c1f1a8eb05b116d9b1274243b38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab66c2c1f1a8eb05b116d9b1274243b38">pipelined_bicgstab_prod</a> (MatrixT const &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;p, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;Ap, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;r0star, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;inner_prod_buffer, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> buffer_chunk_size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> buffer_chunk_offset)</td></tr>
<tr class="memdesc:ab66c2c1f1a8eb05b116d9b1274243b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a joint vector update operation needed for an efficient pipelined CG algorithm.  <a href="#ab66c2c1f1a8eb05b116d9b1274243b38">More...</a><br/></td></tr>
<tr class="separator:ab66c2c1f1a8eb05b116d9b1274243b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca868298580acb7df97aff002bf6867"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaca868298580acb7df97aff002bf6867"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaca868298580acb7df97aff002bf6867">pipelined_gmres_normalize_vk</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v_k, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;residual, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;R_buffer, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> offset_in_R, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;inner_prod_buffer, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;r_dot_vk_buffer, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> buffer_chunk_size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> buffer_chunk_offset)</td></tr>
<tr class="memdesc:aaca868298580acb7df97aff002bf6867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a vector normalization needed for an efficient pipelined GMRES algorithm.  <a href="#aaca868298580acb7df97aff002bf6867">More...</a><br/></td></tr>
<tr class="separator:aaca868298580acb7df97aff002bf6867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e6e73c2c27a83fa958ca25e468b8ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26e6e73c2c27a83fa958ca25e468b8ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a26e6e73c2c27a83fa958ca25e468b8ad">pipelined_gmres_gram_schmidt_stage1</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;device_krylov_basis, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> v_k_size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> v_k_internal_size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> k, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vi_in_vk_buffer, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> buffer_chunk_size)</td></tr>
<tr class="memdesc:a26e6e73c2c27a83fa958ca25e468b8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first reduction stage for multiple inner products &lt;v_i, v_k&gt;, i=0..k-1.  <a href="#a26e6e73c2c27a83fa958ca25e468b8ad">More...</a><br/></td></tr>
<tr class="separator:a26e6e73c2c27a83fa958ca25e468b8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b768f9d8385b980d2e5e9073d09530"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39b768f9d8385b980d2e5e9073d09530"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a39b768f9d8385b980d2e5e9073d09530">pipelined_gmres_gram_schmidt_stage2</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;device_krylov_basis, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> v_k_size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> v_k_internal_size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> k, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vi_in_vk_buffer, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;R_buffer, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> krylov_dim, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;inner_prod_buffer, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> buffer_chunk_size)</td></tr>
<tr class="memdesc:a39b768f9d8385b980d2e5e9073d09530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the second reduction stage for multiple inner products &lt;v_i, v_k&gt;, i=0..k-1, then updates v_k -= &lt;v_i, v_k&gt; v_i and computes the first reduction stage for ||v_k||.  <a href="#a39b768f9d8385b980d2e5e9073d09530">More...</a><br/></td></tr>
<tr class="separator:a39b768f9d8385b980d2e5e9073d09530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8783d68cc82f47d4862d7bb77bed2bab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8783d68cc82f47d4862d7bb77bed2bab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8783d68cc82f47d4862d7bb77bed2bab">pipelined_gmres_update_result</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;result, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;residual, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;krylov_basis, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> v_k_size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> v_k_internal_size, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;coefficients, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> k)</td></tr>
<tr class="memdesc:a8783d68cc82f47d4862d7bb77bed2bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes x += eta_0 r + sum_{i=1}^{k-1} eta_i v_{i-1}.  <a href="#a8783d68cc82f47d4862d7bb77bed2bab">More...</a><br/></td></tr>
<tr class="separator:a8783d68cc82f47d4862d7bb77bed2bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa475e03dfe776021e91f5a66f9319"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename T &gt; </td></tr>
<tr class="memitem:a6faa475e03dfe776021e91f5a66f9319"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6faa475e03dfe776021e91f5a66f9319">pipelined_gmres_prod</a> (MatrixType const &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;p, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;Ap, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;inner_prod_buffer)</td></tr>
<tr class="memdesc:a6faa475e03dfe776021e91f5a66f9319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a joint vector update operation needed for an efficient pipelined GMRES algorithm.  <a href="#a6faa475e03dfe776021e91f5a66f9319">More...</a><br/></td></tr>
<tr class="separator:a6faa475e03dfe776021e91f5a66f9319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5002a88fa4cc3fbe65a904797a0ecba"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename DenseMatrixT &gt; </td></tr>
<tr class="memitem:af5002a88fa4cc3fbe65a904797a0ecba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; typename MatrixT::value_type &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af5002a88fa4cc3fbe65a904797a0ecba">eig</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, DenseMatrixT &amp;eigenvectors_A, <a class="el" href="classviennacl_1_1linalg_1_1lanczos__tag.html">lanczos_tag</a> const &amp;tag, bool compute_eigenvectors=true)</td></tr>
<tr class="memdesc:af5002a88fa4cc3fbe65a904797a0ecba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the calculation of eigenvalues using lanczos (with and without reorthogonalization).  <a href="#af5002a88fa4cc3fbe65a904797a0ecba">More...</a><br/></td></tr>
<tr class="separator:af5002a88fa4cc3fbe65a904797a0ecba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afda6c5b14466eaec9b3bd9db81d988"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:a7afda6c5b14466eaec9b3bd9db81d988"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; typename MatrixT::value_type &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7afda6c5b14466eaec9b3bd9db81d988">eig</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="classviennacl_1_1linalg_1_1lanczos__tag.html">lanczos_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:a7afda6c5b14466eaec9b3bd9db81d988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the calculation of eigenvalues using lanczos (with and without reorthogonalization).  <a href="#a7afda6c5b14466eaec9b3bd9db81d988">More...</a><br/></td></tr>
<tr class="separator:a7afda6c5b14466eaec9b3bd9db81d988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1050039fb153ae8ad818390a30f96bc4"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a1050039fb153ae8ad818390a30f96bc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1050039fb153ae8ad818390a30f96bc4">lu_factorize</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a1050039fb153ae8ad818390a30f96bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU factorization of a row-major dense matrix.  <a href="#a1050039fb153ae8ad818390a30f96bc4">More...</a><br/></td></tr>
<tr class="separator:a1050039fb153ae8ad818390a30f96bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d79dbd3e481d712806e161aba77d3d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a81d79dbd3e481d712806e161aba77d3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a81d79dbd3e481d712806e161aba77d3d">lu_factorize</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1column__major.html">viennacl::column_major</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a81d79dbd3e481d712806e161aba77d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU factorization of a column-major dense matrix.  <a href="#a81d79dbd3e481d712806e161aba77d3d">More...</a><br/></td></tr>
<tr class="separator:a81d79dbd3e481d712806e161aba77d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118a9164bc965f8ec728eda73a5e2450"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , unsigned int AlignmentV1, unsigned int AlignmentV2&gt; </td></tr>
<tr class="memitem:a118a9164bc965f8ec728eda73a5e2450"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a118a9164bc965f8ec728eda73a5e2450">lu_substitute</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F1, AlignmentV1 &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F2, AlignmentV2 &gt; &amp;B)</td></tr>
<tr class="memdesc:a118a9164bc965f8ec728eda73a5e2450"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU substitution for the system LU = rhs.  <a href="#a118a9164bc965f8ec728eda73a5e2450">More...</a><br/></td></tr>
<tr class="separator:a118a9164bc965f8ec728eda73a5e2450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76316cf22830919c49106c45d28480af"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , unsigned int MatAlignmentV, unsigned int VecAlignmentV&gt; </td></tr>
<tr class="memitem:a76316cf22830919c49106c45d28480af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a76316cf22830919c49106c45d28480af">lu_substitute</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, MatAlignmentV &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, VecAlignmentV &gt; &amp;vec)</td></tr>
<tr class="memdesc:a76316cf22830919c49106c45d28480af"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU substitution for the system LU = rhs.  <a href="#a76316cf22830919c49106c45d28480af">More...</a><br/></td></tr>
<tr class="separator:a76316cf22830919c49106c45d28480af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871e1a8fb109d90254a628d1f3af7067"><td class="memTemplParams" colspan="2">template&lt;typename DestNumericT , typename SrcNumericT &gt; </td></tr>
<tr class="memitem:a871e1a8fb109d90254a628d1f3af7067"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a871e1a8fb109d90254a628d1f3af7067">convert</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; DestNumericT &gt; &amp;dest, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SrcNumericT &gt; const &amp;src)</td></tr>
<tr class="separator:a871e1a8fb109d90254a628d1f3af7067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88c948ebe30524e225cb523fe6f6cd7"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SizeT , typename DistanceT &gt; </td></tr>
<tr class="memitem:ad88c948ebe30524e225cb523fe6f6cd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad88c948ebe30524e225cb523fe6f6cd7">trans</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, SizeT, DistanceT &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, SizeT, DistanceT &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;temp_trans)</td></tr>
<tr class="separator:ad88c948ebe30524e225cb523fe6f6cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3c6c86f630026ed266c2d4f807deb9"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename ScalarType1 &gt; </td></tr>
<tr class="memitem:a8c3c6c86f630026ed266c2d4f807deb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8c3c6c86f630026ed266c2d4f807deb9">am</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;mat2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr class="separator:a8c3c6c86f630026ed266c2d4f807deb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca65d04ae5521b0f34c5bbeae136b1a"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr class="memitem:aaca65d04ae5521b0f34c5bbeae136b1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaca65d04ae5521b0f34c5bbeae136b1a">ambm</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;mat2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;mat3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr class="separator:aaca65d04ae5521b0f34c5bbeae136b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21deecdfe93a77e1d341934ff816cb9e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr class="memitem:a21deecdfe93a77e1d341934ff816cb9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a21deecdfe93a77e1d341934ff816cb9e">ambm_m</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;mat2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;mat3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr class="separator:a21deecdfe93a77e1d341934ff816cb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9f99d60acd232ba5c8819dabeb75d4"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aef9f99d60acd232ba5c8819dabeb75d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aef9f99d60acd232ba5c8819dabeb75d4">matrix_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> s, bool clear=false)</td></tr>
<tr class="separator:aef9f99d60acd232ba5c8819dabeb75d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad385d79ae0f63ce7b1305d5e5a0fc908"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad385d79ae0f63ce7b1305d5e5a0fc908"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad385d79ae0f63ce7b1305d5e5a0fc908">matrix_diagonal_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> s)</td></tr>
<tr class="separator:ad385d79ae0f63ce7b1305d5e5a0fc908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608ba0810205864e44796cf4713184ee"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a608ba0810205864e44796cf4713184ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a608ba0810205864e44796cf4713184ee">matrix_diag_from_vector</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;v, int k, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A)</td></tr>
<tr class="memdesc:a608ba0810205864e44796cf4713184ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatcher interface for A = diag(v, k)  <a href="#a608ba0810205864e44796cf4713184ee">More...</a><br/></td></tr>
<tr class="separator:a608ba0810205864e44796cf4713184ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b883c28e757f86ae3e6f1382fe04df9"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a7b883c28e757f86ae3e6f1382fe04df9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7b883c28e757f86ae3e6f1382fe04df9">matrix_diag_to_vector</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, int k, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a7b883c28e757f86ae3e6f1382fe04df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatcher interface for v = diag(A, k)  <a href="#a7b883c28e757f86ae3e6f1382fe04df9">More...</a><br/></td></tr>
<tr class="separator:a7b883c28e757f86ae3e6f1382fe04df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262adb1cc047128ec5e104da68f2755f"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a262adb1cc047128ec5e104da68f2755f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a262adb1cc047128ec5e104da68f2755f">matrix_row</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, unsigned int i, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;v)</td></tr>
<tr class="separator:a262adb1cc047128ec5e104da68f2755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf3f49df1848ac5fa35e8ba6d59df19"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aaaf3f49df1848ac5fa35e8ba6d59df19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaaf3f49df1848ac5fa35e8ba6d59df19">matrix_column</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, unsigned int j, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;v)</td></tr>
<tr class="separator:aaaf3f49df1848ac5fa35e8ba6d59df19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee54e81505baf1ad693923f931cf977f"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename ScalarType &gt; </td></tr>
<tr class="memitem:aee54e81505baf1ad693923f931cf977f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aee54e81505baf1ad693923f931cf977f">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;C, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> alpha, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> beta)</td></tr>
<tr class="memdesc:aee54e81505baf1ad693923f931cf977f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#aee54e81505baf1ad693923f931cf977f">More...</a><br/></td></tr>
<tr class="separator:aee54e81505baf1ad693923f931cf977f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cb0e6f13312518b9feeb79641d68db"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename ScalarType &gt; </td></tr>
<tr class="memitem:ad4cb0e6f13312518b9feeb79641d68db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad4cb0e6f13312518b9feeb79641d68db">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;C, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> alpha, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> beta)</td></tr>
<tr class="memdesc:ad4cb0e6f13312518b9feeb79641d68db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#ad4cb0e6f13312518b9feeb79641d68db">More...</a><br/></td></tr>
<tr class="separator:ad4cb0e6f13312518b9feeb79641d68db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259294962bcc11782615f4860324d223"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename ScalarType &gt; </td></tr>
<tr class="memitem:a259294962bcc11782615f4860324d223"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a259294962bcc11782615f4860324d223">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;C, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> alpha, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> beta)</td></tr>
<tr class="memdesc:a259294962bcc11782615f4860324d223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a259294962bcc11782615f4860324d223">More...</a><br/></td></tr>
<tr class="separator:a259294962bcc11782615f4860324d223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab441eef21bb94768f6a8113ff2fdee"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename ScalarType &gt; </td></tr>
<tr class="memitem:abab441eef21bb94768f6a8113ff2fdee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abab441eef21bb94768f6a8113ff2fdee">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;C, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> alpha, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> beta)</td></tr>
<tr class="memdesc:abab441eef21bb94768f6a8113ff2fdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#abab441eef21bb94768f6a8113ff2fdee">More...</a><br/></td></tr>
<tr class="separator:abab441eef21bb94768f6a8113ff2fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276ca58ba0ee040e4fd8c2b95d0a2674"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr class="memitem:a276ca58ba0ee040e4fd8c2b95d0a2674"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a276ca58ba0ee040e4fd8c2b95d0a2674">element_op</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; T &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; T &gt;, OP &gt; const &amp;proxy)</td></tr>
<tr class="memdesc:a276ca58ba0ee040e4fd8c2b95d0a2674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the element-wise operation A = B .* C and A = B ./ C for matrices (using MATLAB syntax). Don't use this function directly, use <a class="el" href="namespaceviennacl_1_1linalg.html#a28ab8924636e24b01c6bad13a7321343">element_prod()</a> and <a class="el" href="namespaceviennacl_1_1linalg.html#a3207a7759c34cfe4e961aabadd616a13">element_div()</a>.  <a href="#a276ca58ba0ee040e4fd8c2b95d0a2674">More...</a><br/></td></tr>
<tr class="separator:a276ca58ba0ee040e4fd8c2b95d0a2674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b166d4b1b136b020820db3d7572b0d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a80b166d4b1b136b020820db3d7572b0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a80b166d4b1b136b020820db3d7572b0d">outer_prod</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec2)</td></tr>
<tr class="memdesc:a80b166d4b1b136b020820db3d7572b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a proxy class for the operation mat += vec1 * vec2^T, i.e. a rank 1 update.  <a href="#a80b166d4b1b136b020820db3d7572b0d">More...</a><br/></td></tr>
<tr class="separator:a80b166d4b1b136b020820db3d7572b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b132454748512537e1db081c5dcc11d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr class="memitem:a9b132454748512537e1db081c5dcc11d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9b132454748512537e1db081c5dcc11d">scaled_rank_1_update</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat1, S1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec2)</td></tr>
<tr class="memdesc:a9b132454748512537e1db081c5dcc11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update.  <a href="#a9b132454748512537e1db081c5dcc11d">More...</a><br/></td></tr>
<tr class="separator:a9b132454748512537e1db081c5dcc11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb0d10b3784c0eec40296cd94f1bd38"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename VectorType &gt; </td></tr>
<tr class="memitem:a9bb0d10b3784c0eec40296cd94f1bd38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9bb0d10b3784c0eec40296cd94f1bd38">bidiag_pack</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, VectorType &amp;dh, VectorType &amp;sh)</td></tr>
<tr class="memdesc:a9bb0d10b3784c0eec40296cd94f1bd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores the diagonal and the superdiagonal of a matrix in two vectors.  <a href="#a9bb0d10b3784c0eec40296cd94f1bd38">More...</a><br/></td></tr>
<tr class="separator:a9bb0d10b3784c0eec40296cd94f1bd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aec751d37dbd7b6d45ea9340fa8a317"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE &gt; </td></tr>
<tr class="memitem:a0aec751d37dbd7b6d45ea9340fa8a317"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0aec751d37dbd7b6d45ea9340fa8a317">copy_vec</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE &gt; &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SCALARTYPE &gt; &amp;V, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> row_start, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> col_start, bool copy_col)</td></tr>
<tr class="memdesc:a0aec751d37dbd7b6d45ea9340fa8a317"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies a row or a column from a matrix to a vector.  <a href="#a0aec751d37dbd7b6d45ea9340fa8a317">More...</a><br/></td></tr>
<tr class="separator:a0aec751d37dbd7b6d45ea9340fa8a317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706c4d0b456ec669c3a8c2eea8cc3fc4"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a706c4d0b456ec669c3a8c2eea8cc3fc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a706c4d0b456ec669c3a8c2eea8cc3fc4">house_update_A_left</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;D, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> start)</td></tr>
<tr class="memdesc:a706c4d0b456ec669c3a8c2eea8cc3fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function applies a householder transformation to a matrix. A &lt;- P * A with a householder reflection P.  <a href="#a706c4d0b456ec669c3a8c2eea8cc3fc4">More...</a><br/></td></tr>
<tr class="separator:a706c4d0b456ec669c3a8c2eea8cc3fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c93371a5e45fe498bf1dc4dd475497"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a34c93371a5e45fe498bf1dc4dd475497"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a34c93371a5e45fe498bf1dc4dd475497">house_update_A_right</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;D)</td></tr>
<tr class="memdesc:a34c93371a5e45fe498bf1dc4dd475497"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function applies a householder transformation to a matrix: A &lt;- A * P with a householder reflection P.  <a href="#a34c93371a5e45fe498bf1dc4dd475497">More...</a><br/></td></tr>
<tr class="separator:a34c93371a5e45fe498bf1dc4dd475497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58751eae7fc9a4af532b447728880ab"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ab58751eae7fc9a4af532b447728880ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab58751eae7fc9a4af532b447728880ab">house_update_QL</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;Q, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;D, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> A_size1)</td></tr>
<tr class="memdesc:ab58751eae7fc9a4af532b447728880ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the matrix Q, which is needed for the computation of the eigenvectors.  <a href="#ab58751eae7fc9a4af532b447728880ab">More...</a><br/></td></tr>
<tr class="separator:ab58751eae7fc9a4af532b447728880ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c5bc49dfdc3c85b101694cca8d23cb"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a22c5bc49dfdc3c85b101694cca8d23cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a22c5bc49dfdc3c85b101694cca8d23cb">givens_next</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;Q, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;tmp1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;tmp2, int l, int m)</td></tr>
<tr class="memdesc:a22c5bc49dfdc3c85b101694cca8d23cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the matrix Q. It is part of the tql2 algorithm.  <a href="#a22c5bc49dfdc3c85b101694cca8d23cb">More...</a><br/></td></tr>
<tr class="separator:a22c5bc49dfdc3c85b101694cca8d23cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd5b21910a692a78c547b22b9157c2e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:adfd5b21910a692a78c547b22b9157c2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adfd5b21910a692a78c547b22b9157c2e">max</a> (std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:adfd5b21910a692a78c547b22b9157c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3174c1f0846b0f4801e203b2048f12de"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a3174c1f0846b0f4801e203b2048f12de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__max.html">viennacl::op_max</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3174c1f0846b0f4801e203b2048f12de">max</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:a3174c1f0846b0f4801e203b2048f12de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554dda7695e02807c9f56029c192bc73"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a554dda7695e02807c9f56029c192bc73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__max.html">viennacl::op_max</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a554dda7695e02807c9f56029c192bc73">max</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr class="separator:a554dda7695e02807c9f56029c192bc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a4445a6d0f1d75e7157cdc23239027"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ae0a4445a6d0f1d75e7157cdc23239027"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae0a4445a6d0f1d75e7157cdc23239027">min</a> (std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:ae0a4445a6d0f1d75e7157cdc23239027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae602a9321e77bce6adb827a2514de278"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:ae602a9321e77bce6adb827a2514de278"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__min.html">viennacl::op_min</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae602a9321e77bce6adb827a2514de278">min</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:ae602a9321e77bce6adb827a2514de278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5057d08504cc799dd77dfd596499bffc"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a5057d08504cc799dd77dfd596499bffc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__min.html">viennacl::op_min</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5057d08504cc799dd77dfd596499bffc">min</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:a5057d08504cc799dd77dfd596499bffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae51ad7f1972ca14eeedc59f08b12b8"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:acae51ad7f1972ca14eeedc59f08b12b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__min.html">viennacl::op_min</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acae51ad7f1972ca14eeedc59f08b12b8">min</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr class="separator:acae51ad7f1972ca14eeedc59f08b12b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727542f4624926e74ff52ea5c75d546f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a727542f4624926e74ff52ea5c75d546f"><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a727542f4624926e74ff52ea5c75d546f">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1mixed__precision__cg__tag.html">mixed_precision_cg_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:a727542f4624926e74ff52ea5c75d546f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the conjugate gradient solver without preconditioner.  <a href="#a727542f4624926e74ff52ea5c75d546f">More...</a><br/></td></tr>
<tr class="separator:a727542f4624926e74ff52ea5c75d546f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5579a603f93ad9fb66d8ebc358d7d5a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:ab5579a603f93ad9fb66d8ebc358d7d5a"><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab5579a603f93ad9fb66d8ebc358d7d5a">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1mixed__precision__cg__tag.html">mixed_precision_cg_tag</a> const &amp;tag, <a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>)</td></tr>
<tr class="separator:ab5579a603f93ad9fb66d8ebc358d7d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1682d7a829cecf20106e407aed749a49"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a1682d7a829cecf20106e407aed749a49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1682d7a829cecf20106e407aed749a49">nmf</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;V, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;W, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;H, <a class="el" href="classviennacl_1_1linalg_1_1nmf__config.html">viennacl::linalg::nmf_config</a> const &amp;conf)</td></tr>
<tr class="memdesc:a1682d7a829cecf20106e407aed749a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nonnegative matrix factorization (approximation) algorithm as suggested by Lee and Seung. Factorizes a matrix V with nonnegative entries into matrices W and H such that ||V - W*H|| is minimized.  <a href="#a1682d7a829cecf20106e407aed749a49">More...</a><br/></td></tr>
<tr class="separator:a1682d7a829cecf20106e407aed749a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efad0d090dde0c127fa8b25a73836e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a2efad0d090dde0c127fa8b25a73836e4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2efad0d090dde0c127fa8b25a73836e4">norm_1</a> (std::vector&lt; T, A &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:a2efad0d090dde0c127fa8b25a73836e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18799037aaa2e6b5e1778cdf203a0274"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a18799037aaa2e6b5e1778cdf203a0274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__norm__1.html">viennacl::op_norm_1</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a18799037aaa2e6b5e1778cdf203a0274">norm_1</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr class="separator:a18799037aaa2e6b5e1778cdf203a0274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b81d05ed5510a3142a5f29e8b2525f"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:ab5b81d05ed5510a3142a5f29e8b2525f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__norm__1.html">viennacl::op_norm_1</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab5b81d05ed5510a3142a5f29e8b2525f">norm_1</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr class="separator:ab5b81d05ed5510a3142a5f29e8b2525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46f15d01c01f92a153b3f555a15096b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ae46f15d01c01f92a153b3f555a15096b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">norm_2</a> (std::vector&lt; T, A &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:ae46f15d01c01f92a153b3f555a15096b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb24aada7fa315529db8931ed08cd5b"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:abdb24aada7fa315529db8931ed08cd5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__norm__2.html">viennacl::op_norm_2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abdb24aada7fa315529db8931ed08cd5b">norm_2</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;v)</td></tr>
<tr class="separator:abdb24aada7fa315529db8931ed08cd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a22bc2566ec601883db764cf08950c9"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a2a22bc2566ec601883db764cf08950c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__norm__2.html">viennacl::op_norm_2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2a22bc2566ec601883db764cf08950c9">norm_2</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr class="separator:a2a22bc2566ec601883db764cf08950c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67813d48ed274df9fc19e6aad99fc761"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a67813d48ed274df9fc19e6aad99fc761"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__norm__frobenius.html">op_norm_frobenius</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a67813d48ed274df9fc19e6aad99fc761">norm_frobenius</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A)</td></tr>
<tr class="separator:a67813d48ed274df9fc19e6aad99fc761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4de9152d556e89d823eb47a683ead11"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ae4de9152d556e89d823eb47a683ead11"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae4de9152d556e89d823eb47a683ead11">norm_inf</a> (std::vector&lt; T, A &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:ae4de9152d556e89d823eb47a683ead11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3097c09e7f5ec6aa812420965f147f69"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a3097c09e7f5ec6aa812420965f147f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__norm__inf.html">viennacl::op_norm_inf</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3097c09e7f5ec6aa812420965f147f69">norm_inf</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:a3097c09e7f5ec6aa812420965f147f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ac490ffc6af2faebcc33724bba120e"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:af6ac490ffc6af2faebcc33724bba120e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__norm__inf.html">viennacl::op_norm_inf</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af6ac490ffc6af2faebcc33724bba120e">norm_inf</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr class="separator:af6ac490ffc6af2faebcc33724bba120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54e2b8a6ab1f2105fcbb8e3db7af0cf"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:ad54e2b8a6ab1f2105fcbb8e3db7af0cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; typename MatrixT::value_type &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad54e2b8a6ab1f2105fcbb8e3db7af0cf">eig</a> (MatrixT const &amp;A, <a class="el" href="classviennacl_1_1linalg_1_1power__iter__tag.html">power_iter_tag</a> const &amp;tag, VectorT &amp;eigenvec)</td></tr>
<tr class="memdesc:ad54e2b8a6ab1f2105fcbb8e3db7af0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the calculation of the largest eigenvalue (in modulus) and the associated eigenvector using power iteration.  <a href="#ad54e2b8a6ab1f2105fcbb8e3db7af0cf">More...</a><br/></td></tr>
<tr class="separator:ad54e2b8a6ab1f2105fcbb8e3db7af0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83ef1714ec827c54aeea62f6ccfb0f7"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:aa83ef1714ec827c54aeea62f6ccfb0f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a><br class="typebreak"/>
&lt; typename MatrixT::value_type &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa83ef1714ec827c54aeea62f6ccfb0f7">eig</a> (MatrixT const &amp;A, <a class="el" href="classviennacl_1_1linalg_1_1power__iter__tag.html">power_iter_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:aa83ef1714ec827c54aeea62f6ccfb0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the calculation of eigenvalues using power iteration. Does not return the eigenvector.  <a href="#aa83ef1714ec827c54aeea62f6ccfb0f7">More...</a><br/></td></tr>
<tr class="separator:aa83ef1714ec827c54aeea62f6ccfb0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18d10f8a90e38bd9ff43c650fc670ef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A1 , typename A2 , typename VectorT &gt; </td></tr>
<tr class="memitem:aa18d10f8a90e38bd9ff43c650fc670ef"><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">prod</a> (std::vector&lt; std::vector&lt; T, A1 &gt;, A2 &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr class="separator:aa18d10f8a90e38bd9ff43c650fc670ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8191b8e2833645bf9a50cf0385bf84"><td class="memTemplParams" colspan="2">template&lt;typename KEY , typename DATA , typename COMPARE , typename AMAP , typename AVEC , typename VectorT &gt; </td></tr>
<tr class="memitem:a4a8191b8e2833645bf9a50cf0385bf84"><td class="memTemplItemLeft" align="right" valign="top">VectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4a8191b8e2833645bf9a50cf0385bf84">prod</a> (std::vector&lt; std::map&lt; KEY, DATA, COMPARE, AMAP &gt;, AVEC &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr class="separator:a4a8191b8e2833645bf9a50cf0385bf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf28b182155a8036335d473bf5fa67"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a9dbf28b182155a8036335d473bf5fa67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__mat__mat__prod.html">viennacl::op_mat_mat_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9dbf28b182155a8036335d473bf5fa67">prod</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;B)</td></tr>
<tr class="separator:a9dbf28b182155a8036335d473bf5fa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5214077835c189277d6eca907530c673"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename LhsT , typename RhsT , typename OpT &gt; </td></tr>
<tr class="memitem:a5214077835c189277d6eca907530c673"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LhsT, const RhsT, OpT &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__mat__mat__prod.html">viennacl::op_mat_mat_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5214077835c189277d6eca907530c673">prod</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT, const RhsT, OpT &gt; const &amp;B)</td></tr>
<tr class="separator:a5214077835c189277d6eca907530c673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf365675ae14ac0ed16d1f0b065be399"><td class="memTemplParams" colspan="2">template&lt;typename LhsT , typename RhsT , typename OpT , typename NumericT &gt; </td></tr>
<tr class="memitem:acf365675ae14ac0ed16d1f0b065be399"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LhsT, const RhsT, OpT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__mat__mat__prod.html">viennacl::op_mat_mat_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acf365675ae14ac0ed16d1f0b065be399">prod</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT, const RhsT, OpT &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;B)</td></tr>
<tr class="separator:acf365675ae14ac0ed16d1f0b065be399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c5997b7fae26a1abfcd0d4d9fe630b"><td class="memTemplParams" colspan="2">template&lt;typename LhsT1 , typename RhsT1 , typename OpT1 , typename LhsT2 , typename RhsT2 , typename OpT2 &gt; </td></tr>
<tr class="memitem:a02c5997b7fae26a1abfcd0d4d9fe630b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LhsT1, const RhsT1, <br class="typebreak"/>
OpT1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LhsT2, const RhsT2, <br class="typebreak"/>
OpT2 &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__mat__mat__prod.html">viennacl::op_mat_mat_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a02c5997b7fae26a1abfcd0d4d9fe630b">prod</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT1, const RhsT1, OpT1 &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT2, const RhsT2, OpT2 &gt; const &amp;B)</td></tr>
<tr class="separator:a02c5997b7fae26a1abfcd0d4d9fe630b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edeb4f4249dd1b38b4dbc33b0d2c30f"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a7edeb4f4249dd1b38b4dbc33b0d2c30f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7edeb4f4249dd1b38b4dbc33b0d2c30f">prod</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;x)</td></tr>
<tr class="separator:a7edeb4f4249dd1b38b4dbc33b0d2c30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad411899e5dba6c80530c432eb9ff14a9"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr class="memitem:ad411899e5dba6c80530c432eb9ff14a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad411899e5dba6c80530c432eb9ff14a9">prod</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;x)</td></tr>
<tr class="separator:ad411899e5dba6c80530c432eb9ff14a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9bd2539edadb395c980ac9deeb97e0"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:adb9bd2539edadb395c980ac9deeb97e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adb9bd2539edadb395c980ac9deeb97e0">prod</a> (<a class="el" href="classviennacl_1_1matrix__range.html">viennacl::matrix_range</a>&lt; MatrixT &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;x)</td></tr>
<tr class="separator:adb9bd2539edadb395c980ac9deeb97e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e1429628379a8912c4e580d03c8c72"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:aa0e1429628379a8912c4e580d03c8c72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa0e1429628379a8912c4e580d03c8c72">prod</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">viennacl::matrix_slice</a>&lt; MatrixT &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;x)</td></tr>
<tr class="separator:aa0e1429628379a8912c4e580d03c8c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960045016584f346ad635d81be790619"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename LhsT , typename RhsT , typename OpT &gt; </td></tr>
<tr class="memitem:a960045016584f346ad635d81be790619"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LhsT, const RhsT, OpT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a960045016584f346ad635d81be790619">prod</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT, const RhsT, OpT &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;x)</td></tr>
<tr class="separator:a960045016584f346ad635d81be790619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9a28b9f21ece1b0d1d25b3c5760678"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename LhsT , typename RhsT , typename OpT &gt; </td></tr>
<tr class="memitem:a2d9a28b9f21ece1b0d1d25b3c5760678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LhsT, const RhsT, OpT &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2d9a28b9f21ece1b0d1d25b3c5760678">prod</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LhsT, const RhsT, OpT &gt; const &amp;x)</td></tr>
<tr class="separator:a2d9a28b9f21ece1b0d1d25b3c5760678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98b74abb405df7fa2184e27f0fd9b62"><td class="memTemplParams" colspan="2">template&lt;typename LhsT1 , typename RhsT1 , typename OpT1 , typename LhsT2 , typename RhsT2 , typename OpT2 &gt; </td></tr>
<tr class="memitem:ae98b74abb405df7fa2184e27f0fd9b62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LhsT1, const RhsT1, <br class="typebreak"/>
OpT1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LhsT2, const RhsT2, <br class="typebreak"/>
OpT2 &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae98b74abb405df7fa2184e27f0fd9b62">prod</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT1, const RhsT1, OpT1 &gt; const &amp;A, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LhsT2, const RhsT2, OpT2 &gt; const &amp;x)</td></tr>
<tr class="separator:ae98b74abb405df7fa2184e27f0fd9b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bba0146e669e012bb7c7380ce780a25"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename SCALARTYPE &gt; </td></tr>
<tr class="memitem:a3bba0146e669e012bb7c7380ce780a25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const SparseMatrixType, <br class="typebreak"/>
const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3bba0146e669e012bb7c7380ce780a25">prod</a> (const SparseMatrixType &amp;sp_mat, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; SCALARTYPE &gt; &amp;d_mat)</td></tr>
<tr class="separator:a3bba0146e669e012bb7c7380ce780a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f953a28fd0726963616efc7c6502be"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename SCALARTYPE &gt; </td></tr>
<tr class="memitem:ae2f953a28fd0726963616efc7c6502be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const SparseMatrixType, <br class="typebreak"/>
const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; SCALARTYPE &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae2f953a28fd0726963616efc7c6502be">prod</a> (const SparseMatrixType &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; SCALARTYPE &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; const &amp;B)</td></tr>
<tr class="separator:ae2f953a28fd0726963616efc7c6502be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481c6668b16471330cbb8dc667ea777d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a481c6668b16471330cbb8dc667ea777d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a481c6668b16471330cbb8dc667ea777d">prod</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;B)</td></tr>
<tr class="memdesc:a481c6668b16471330cbb8dc667ea777d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix-matrix product with <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> objects.  <a href="#a481c6668b16471330cbb8dc667ea777d">More...</a><br/></td></tr>
<tr class="separator:a481c6668b16471330cbb8dc667ea777d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f5c8c3c3de21c082ccf1db28cf5189"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , typename NumericT &gt; </td></tr>
<tr class="memitem:a77f5c8c3c3de21c082ccf1db28cf5189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
SparseMatrixType, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a77f5c8c3c3de21c082ccf1db28cf5189">prod</a> (const SparseMatrixType &amp;A, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a77f5c8c3c3de21c082ccf1db28cf5189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic matrix-vector product with user-provided sparse matrix type.  <a href="#a77f5c8c3c3de21c082ccf1db28cf5189">More...</a><br/></td></tr>
<tr class="separator:a77f5c8c3c3de21c082ccf1db28cf5189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe64190e92ee58ad753947142204d0f9"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE &gt; </td></tr>
<tr class="memitem:abe64190e92ee58ad753947142204d0f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abe64190e92ee58ad753947142204d0f9">qr_method_nsm</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;Q, std::vector&lt; SCALARTYPE &gt; &amp;D, std::vector&lt; SCALARTYPE &gt; &amp;E)</td></tr>
<tr class="separator:abe64190e92ee58ad753947142204d0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cbe06645207f9b3054e8725269cc71"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE &gt; </td></tr>
<tr class="memitem:a51cbe06645207f9b3054e8725269cc71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a51cbe06645207f9b3054e8725269cc71">qr_method_sym</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;Q, std::vector&lt; SCALARTYPE &gt; &amp;D)</td></tr>
<tr class="separator:a51cbe06645207f9b3054e8725269cc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec312fb569dcc41351adb8aeacbea571"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE &gt; </td></tr>
<tr class="memitem:aec312fb569dcc41351adb8aeacbea571"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aec312fb569dcc41351adb8aeacbea571">qr_method_sym</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;Q, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;D)</td></tr>
<tr class="separator:aec312fb569dcc41351adb8aeacbea571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fc8bf8f5a20c576b7ddbad32d3e56d"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a76fc8bf8f5a20c576b7ddbad32d3e56d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a76fc8bf8f5a20c576b7ddbad32d3e56d">recoverQ</a> (MatrixType const &amp;A, VectorType const &amp;betas, MatrixType &amp;Q, MatrixType &amp;R)</td></tr>
<tr class="separator:a76fc8bf8f5a20c576b7ddbad32d3e56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf77bb0fe92ef09522d0458ee9df03db"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType1 , typename VectorType2 &gt; </td></tr>
<tr class="memitem:adf77bb0fe92ef09522d0458ee9df03db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adf77bb0fe92ef09522d0458ee9df03db">inplace_qr_apply_trans_Q</a> (MatrixType const &amp;A, VectorType1 const &amp;betas, VectorType2 &amp;b)</td></tr>
<tr class="memdesc:adf77bb0fe92ef09522d0458ee9df03db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Q^T b, where Q is an implicit orthogonal matrix defined via its Householder reflectors stored in A.  <a href="#adf77bb0fe92ef09522d0458ee9df03db">More...</a><br/></td></tr>
<tr class="separator:adf77bb0fe92ef09522d0458ee9df03db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa926ae9008c3343c337f2aa5a90e8734"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , unsigned int ALIGNMENT, typename VectorType1 , unsigned int A2&gt; </td></tr>
<tr class="memitem:aa926ae9008c3343c337f2aa5a90e8734"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa926ae9008c3343c337f2aa5a90e8734">inplace_qr_apply_trans_Q</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; T, F, ALIGNMENT &gt; const &amp;A, VectorType1 const &amp;betas, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr class="separator:aa926ae9008c3343c337f2aa5a90e8734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f573386903bae3a5379ab4cbfc5e2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:a83f573386903bae3a5379ab4cbfc5e2d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a83f573386903bae3a5379ab4cbfc5e2d">inplace_qr</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; T, F, ALIGNMENT &gt; &amp;A, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> block_size=16)</td></tr>
<tr class="memdesc:a83f573386903bae3a5379ab4cbfc5e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of inplace-QR factorization of a ViennaCL matrix A.  <a href="#a83f573386903bae3a5379ab4cbfc5e2d">More...</a><br/></td></tr>
<tr class="separator:a83f573386903bae3a5379ab4cbfc5e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9728d85f4f7307ed9096524de8c77cdc"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a9728d85f4f7307ed9096524de8c77cdc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
MatrixType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9728d85f4f7307ed9096524de8c77cdc">inplace_qr</a> (MatrixType &amp;A, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> block_size=16)</td></tr>
<tr class="memdesc:a9728d85f4f7307ed9096524de8c77cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of inplace-QR factorization for a general Boost.uBLAS compatible matrix A.  <a href="#a9728d85f4f7307ed9096524de8c77cdc">More...</a><br/></td></tr>
<tr class="separator:a9728d85f4f7307ed9096524de8c77cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2573d0a189f441a1ee62209ef7c1cfa"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 &gt; </td></tr>
<tr class="memitem:ab2573d0a189f441a1ee62209ef7c1cfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab2573d0a189f441a1ee62209ef7c1cfa">as</a> (S1 &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>, S2 const &amp;<a class="el" href="global__variables_8cpp.html#a8163feae57063e5c0bb2e640ff4e8c7a">s2</a>, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr class="memdesc:ab2573d0a189f441a1ee62209ef7c1cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the generic operation s1 = s2 @ alpha, where s1 and s2 are GPU scalars, @ denotes multiplication or division, and alpha is either a GPU or a CPU scalar.  <a href="#ab2573d0a189f441a1ee62209ef7c1cfa">More...</a><br/></td></tr>
<tr class="separator:ab2573d0a189f441a1ee62209ef7c1cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc6e11ec77f197ac82ec2b2580b672"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr class="memitem:a04dc6e11ec77f197ac82ec2b2580b672"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a04dc6e11ec77f197ac82ec2b2580b672">asbs</a> (S1 &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>, S2 const &amp;<a class="el" href="global__variables_8cpp.html#a8163feae57063e5c0bb2e640ff4e8c7a">s2</a>, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr class="memdesc:a04dc6e11ec77f197ac82ec2b2580b672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the generic operation s1 = s2 @ alpha + s3 @ beta, where s1, s2 and s3 are GPU scalars, @ denotes multiplication or division, and alpha, beta are either a GPU or a CPU scalar.  <a href="#a04dc6e11ec77f197ac82ec2b2580b672">More...</a><br/></td></tr>
<tr class="separator:a04dc6e11ec77f197ac82ec2b2580b672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e0b6945112135e1e023cd9da9c8805"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr class="memitem:a02e0b6945112135e1e023cd9da9c8805"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a02e0b6945112135e1e023cd9da9c8805">asbs_s</a> (S1 &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>, S2 const &amp;<a class="el" href="global__variables_8cpp.html#a8163feae57063e5c0bb2e640ff4e8c7a">s2</a>, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr class="memdesc:a02e0b6945112135e1e023cd9da9c8805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the generic operation s1 += s2 @ alpha + s3 @ beta, where s1, s2 and s3 are GPU scalars, @ denotes multiplication or division, and alpha, beta are either a GPU or a CPU scalar.  <a href="#a02e0b6945112135e1e023cd9da9c8805">More...</a><br/></td></tr>
<tr class="separator:a02e0b6945112135e1e023cd9da9c8805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376a98ceee0ab85880a4b5a9c343d802"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 &gt; </td></tr>
<tr class="memitem:a376a98ceee0ab85880a4b5a9c343d802"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a376a98ceee0ab85880a4b5a9c343d802">swap</a> (S1 &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>, S2 &amp;<a class="el" href="global__variables_8cpp.html#a8163feae57063e5c0bb2e640ff4e8c7a">s2</a>)</td></tr>
<tr class="memdesc:a376a98ceee0ab85880a4b5a9c343d802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two scalars.  <a href="#a376a98ceee0ab85880a4b5a9c343d802">More...</a><br/></td></tr>
<tr class="separator:a376a98ceee0ab85880a4b5a9c343d802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ecc092e443847d1968d9d2cef07eda"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class ScalarType &gt; </td></tr>
<tr class="memitem:ac4ecc092e443847d1968d9d2cef07eda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac4ecc092e443847d1968d9d2cef07eda">prod_impl</a> (const SparseMatrixType &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;vec, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> alpha, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;result, <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> beta)</td></tr>
<tr class="memdesc:ac4ecc092e443847d1968d9d2cef07eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication involving a sparse matrix type.  <a href="#ac4ecc092e443847d1968d9d2cef07eda">More...</a><br/></td></tr>
<tr class="separator:ac4ecc092e443847d1968d9d2cef07eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6448c1d1c0cdb1010a146c0238c8d20"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class ScalarType &gt; </td></tr>
<tr class="memitem:ac6448c1d1c0cdb1010a146c0238c8d20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac6448c1d1c0cdb1010a146c0238c8d20">prod_impl</a> (const SparseMatrixType &amp;sp_mat, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ac6448c1d1c0cdb1010a146c0238c8d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication first matrix being sparse.  <a href="#ac6448c1d1c0cdb1010a146c0238c8d20">More...</a><br/></td></tr>
<tr class="separator:ac6448c1d1c0cdb1010a146c0238c8d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ddf85f2f61d198160ffd13bf7aebac"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class ScalarType &gt; </td></tr>
<tr class="memitem:a07ddf85f2f61d198160ffd13bf7aebac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a07ddf85f2f61d198160ffd13bf7aebac">prod_impl</a> (const SparseMatrixType &amp;sp_mat, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a07ddf85f2f61d198160ffd13bf7aebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication first matrix being sparse, and the second transposed.  <a href="#a07ddf85f2f61d198160ffd13bf7aebac">More...</a><br/></td></tr>
<tr class="separator:a07ddf85f2f61d198160ffd13bf7aebac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac371515668e3ef88cd49a4adba597e94"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ac371515668e3ef88cd49a4adba597e94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac371515668e3ef88cd49a4adba597e94">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;B, <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;C)</td></tr>
<tr class="memdesc:ac371515668e3ef88cd49a4adba597e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out sparse_matrix-sparse_matrix multiplication for CSR matrices.  <a href="#ac371515668e3ef88cd49a4adba597e94">More...</a><br/></td></tr>
<tr class="separator:ac371515668e3ef88cd49a4adba597e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd904fcd01a99005ca9f83f3c696b41"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class ScalarType , typename SOLVERTAG &gt; </td></tr>
<tr class="memitem:a2cd904fcd01a99005ca9f83f3c696b41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2cd904fcd01a99005ca9f83f3c696b41">inplace_solve</a> (const SparseMatrixType &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;vec, SOLVERTAG tag)</td></tr>
<tr class="memdesc:a2cd904fcd01a99005ca9f83f3c696b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out triangular inplace solves.  <a href="#a2cd904fcd01a99005ca9f83f3c696b41">More...</a><br/></td></tr>
<tr class="separator:a2cd904fcd01a99005ca9f83f3c696b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02babae1af157516bd1e92d28c711957"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class ScalarType , typename SOLVERTAG &gt; </td></tr>
<tr class="memitem:a02babae1af157516bd1e92d28c711957"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a02babae1af157516bd1e92d28c711957">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const SparseMatrixType, const SparseMatrixType, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;vec, SOLVERTAG tag)</td></tr>
<tr class="memdesc:a02babae1af157516bd1e92d28c711957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out transposed triangular inplace solves.  <a href="#a02babae1af157516bd1e92d28c711957">More...</a><br/></td></tr>
<tr class="separator:a02babae1af157516bd1e92d28c711957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4117795095db49147ba7305d3e0a1af5"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a4117795095db49147ba7305d3e0a1af5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__sum.html">viennacl::op_sum</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4117795095db49147ba7305d3e0a1af5">sum</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;x)</td></tr>
<tr class="memdesc:a4117795095db49147ba7305d3e0a1af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface function for computing the sum of all elements of a vector.  <a href="#a4117795095db49147ba7305d3e0a1af5">More...</a><br/></td></tr>
<tr class="separator:a4117795095db49147ba7305d3e0a1af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cf85f2a992e09305f5f8c0db4bc6bc"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:af6cf85f2a992e09305f5f8c0db4bc6bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__sum.html">viennacl::op_sum</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af6cf85f2a992e09305f5f8c0db4bc6bc">sum</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;x)</td></tr>
<tr class="memdesc:af6cf85f2a992e09305f5f8c0db4bc6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface function for computing the sum of all elements of a vector specified by a vector operation.  <a href="#af6cf85f2a992e09305f5f8c0db4bc6bc">More...</a><br/></td></tr>
<tr class="separator:af6cf85f2a992e09305f5f8c0db4bc6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3e422a3d27609f0c036badc34e6479"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a9c3e422a3d27609f0c036badc34e6479"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__row__sum.html">viennacl::op_row_sum</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9c3e422a3d27609f0c036badc34e6479">row_sum</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A)</td></tr>
<tr class="memdesc:a9c3e422a3d27609f0c036badc34e6479"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface function for computing the sum of all elements of each row of a matrix.  <a href="#a9c3e422a3d27609f0c036badc34e6479">More...</a><br/></td></tr>
<tr class="separator:a9c3e422a3d27609f0c036badc34e6479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f57091ab11e083e3663039a3f40b32"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a34f57091ab11e083e3663039a3f40b32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__row__sum.html">viennacl::op_row_sum</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a34f57091ab11e083e3663039a3f40b32">row_sum</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;A)</td></tr>
<tr class="memdesc:a34f57091ab11e083e3663039a3f40b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface function for computing the sum of all elements of each row of a matrix specified by a matrix operation.  <a href="#a34f57091ab11e083e3663039a3f40b32">More...</a><br/></td></tr>
<tr class="separator:a34f57091ab11e083e3663039a3f40b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a09e3195c87a9c70c0e2d106766bc10"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a6a09e3195c87a9c70c0e2d106766bc10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a><br class="typebreak"/>
&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__col__sum.html">viennacl::op_col_sum</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6a09e3195c87a9c70c0e2d106766bc10">column_sum</a> (<a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;A)</td></tr>
<tr class="memdesc:a6a09e3195c87a9c70c0e2d106766bc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface function for computing the sum of all elements of each column of a matrix.  <a href="#a6a09e3195c87a9c70c0e2d106766bc10">More...</a><br/></td></tr>
<tr class="separator:a6a09e3195c87a9c70c0e2d106766bc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2133d21998c98d91050e556c72cdd8"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:adb2133d21998c98d91050e556c72cdd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__col__sum.html">viennacl::op_col_sum</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adb2133d21998c98d91050e556c72cdd8">column_sum</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;A)</td></tr>
<tr class="memdesc:adb2133d21998c98d91050e556c72cdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface function for computing the sum of all elements of each column of a matrix specified by a matrix operation.  <a href="#adb2133d21998c98d91050e556c72cdd8">More...</a><br/></td></tr>
<tr class="separator:adb2133d21998c98d91050e556c72cdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd4119fc5dfef5c067af3b46bd86191"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:a7dd4119fc5dfef5c067af3b46bd86191"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7dd4119fc5dfef5c067af3b46bd86191">svd</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, ALIGNMENT &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, ALIGNMENT &gt; &amp;QL, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, ALIGNMENT &gt; &amp;QR)</td></tr>
<tr class="memdesc:a7dd4119fc5dfef5c067af3b46bd86191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the singular value decomposition of a matrix A. Experimental in 1.3.x.  <a href="#a7dd4119fc5dfef5c067af3b46bd86191">More...</a><br/></td></tr>
<tr class="separator:a7dd4119fc5dfef5c067af3b46bd86191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45beece755553455daea6973a60043d"><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:ae45beece755553455daea6973a60043d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae45beece755553455daea6973a60043d">prod_impl</a> (const <a class="el" href="classviennacl_1_1toeplitz__matrix.html">viennacl::toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr class="memdesc:ae45beece755553455daea6973a60043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class. ">toeplitz_matrix</a>.  <a href="#ae45beece755553455daea6973a60043d">More...</a><br/></td></tr>
<tr class="separator:ae45beece755553455daea6973a60043d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528690f82b77f9fc12ee90038ee404ea"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename VectorType &gt; </td></tr>
<tr class="memitem:a528690f82b77f9fc12ee90038ee404ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a528690f82b77f9fc12ee90038ee404ea">tql1</a> (<a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> n, VectorType &amp;d, VectorType &amp;e)</td></tr>
<tr class="separator:a528690f82b77f9fc12ee90038ee404ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe3eb20d4dcda794259fd6a6d30afb6"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename VectorType , typename F &gt; </td></tr>
<tr class="memitem:a3fe3eb20d4dcda794259fd6a6d30afb6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3fe3eb20d4dcda794259fd6a6d30afb6">tql2</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE, F &gt; &amp;Q, VectorType &amp;d, VectorType &amp;e)</td></tr>
<tr class="separator:a3fe3eb20d4dcda794259fd6a6d30afb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b4f1d927a4df6416192cc8e69ed8aa"><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:a64b4f1d927a4df6416192cc8e69ed8aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a64b4f1d927a4df6416192cc8e69ed8aa">prod_impl</a> (const <a class="el" href="classviennacl_1_1vandermonde__matrix.html">viennacl::vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr class="memdesc:a64b4f1d927a4df6416192cc8e69ed8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class. ">vandermonde_matrix</a>.  <a href="#a64b4f1d927a4df6416192cc8e69ed8aa">More...</a><br/></td></tr>
<tr class="separator:a64b4f1d927a4df6416192cc8e69ed8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251d7c95cbf8be55cb8bddf55125b6eb"><td class="memTemplParams" colspan="2">template&lt;typename DestNumericT , typename SrcNumericT &gt; </td></tr>
<tr class="memitem:a251d7c95cbf8be55cb8bddf55125b6eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a251d7c95cbf8be55cb8bddf55125b6eb">convert</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; DestNumericT &gt; &amp;dest, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; SrcNumericT &gt; const &amp;src)</td></tr>
<tr class="separator:a251d7c95cbf8be55cb8bddf55125b6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e91b53adcd3948768cf55be0858f8c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 &gt; </td></tr>
<tr class="memitem:a63e91b53adcd3948768cf55be0858f8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a63e91b53adcd3948768cf55be0858f8c">av</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr class="separator:a63e91b53adcd3948768cf55be0858f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13999d03d7afcfb56ffb08dc87c03d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr class="memitem:ae13999d03d7afcfb56ffb08dc87c03d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae13999d03d7afcfb56ffb08dc87c03d4">avbv</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr class="separator:ae13999d03d7afcfb56ffb08dc87c03d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473a4f8052c5c01059b65274b5031c53"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr class="memitem:a473a4f8052c5c01059b65274b5031c53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a473a4f8052c5c01059b65274b5031c53">avbv_v</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_alpha, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> len_beta, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr class="separator:a473a4f8052c5c01059b65274b5031c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ac2cb73f99d27607fdce761323d892"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4ac2cb73f99d27607fdce761323d892"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab4ac2cb73f99d27607fdce761323d892">vector_assign</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, const T &amp;alpha, bool up_to_internal_size=false)</td></tr>
<tr class="memdesc:ab4ac2cb73f99d27607fdce761323d892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a constant value to a vector (-range/-slice)  <a href="#ab4ac2cb73f99d27607fdce761323d892">More...</a><br/></td></tr>
<tr class="separator:ab4ac2cb73f99d27607fdce761323d892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad345204a9420f9dd57bbad0b16fc40d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad345204a9420f9dd57bbad0b16fc40d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad345204a9420f9dd57bbad0b16fc40d9">vector_swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2)</td></tr>
<tr class="memdesc:ad345204a9420f9dd57bbad0b16fc40d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two vectors, data is copied.  <a href="#ad345204a9420f9dd57bbad0b16fc40d9">More...</a><br/></td></tr>
<tr class="separator:ad345204a9420f9dd57bbad0b16fc40d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e78e9d4c4c2757e900f9d72d3991d0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr class="memitem:a88e78e9d4c4c2757e900f9d72d3991d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a88e78e9d4c4c2757e900f9d72d3991d0">element_op</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, OP &gt; const &amp;proxy)</td></tr>
<tr class="memdesc:a88e78e9d4c4c2757e900f9d72d3991d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax)  <a href="#a88e78e9d4c4c2757e900f9d72d3991d0">More...</a><br/></td></tr>
<tr class="separator:a88e78e9d4c4c2757e900f9d72d3991d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af170246b8ee051270ea2c9fbd141d832"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af170246b8ee051270ea2c9fbd141d832"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af170246b8ee051270ea2c9fbd141d832">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;x, <a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; T &gt; const &amp;y_tuple, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:af170246b8ee051270ea2c9fbd141d832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner products &lt;x, y1&gt;, &lt;x, y2&gt;, ..., &lt;x, y_N&gt; and writes the result to a (sub-)vector.  <a href="#af170246b8ee051270ea2c9fbd141d832">More...</a><br/></td></tr>
<tr class="separator:af170246b8ee051270ea2c9fbd141d832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c58051a4819c96e29cd360e784c68f"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:a94c58051a4819c96e29cd360e784c68f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a94c58051a4819c96e29cd360e784c68f">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:a94c58051a4819c96e29cd360e784c68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#a94c58051a4819c96e29cd360e784c68f">More...</a><br/></td></tr>
<tr class="separator:a94c58051a4819c96e29cd360e784c68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c305a065383fb331678a1a968f1118f"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a7c305a065383fb331678a1a968f1118f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7c305a065383fb331678a1a968f1118f">max_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a7c305a065383fb331678a1a968f1118f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum of a vector with final reduction on the CPU.  <a href="#a7c305a065383fb331678a1a968f1118f">More...</a><br/></td></tr>
<tr class="separator:a7c305a065383fb331678a1a968f1118f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a314ab7003c20ec35e22eda0965511"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename NumericT &gt; </td></tr>
<tr class="memitem:a73a314ab7003c20ec35e22eda0965511"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a73a314ab7003c20ec35e22eda0965511">max_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a73a314ab7003c20ec35e22eda0965511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a73a314ab7003c20ec35e22eda0965511">More...</a><br/></td></tr>
<tr class="separator:a73a314ab7003c20ec35e22eda0965511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f5df131ed2c04914ea120f1808c6d2"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a18f5df131ed2c04914ea120f1808c6d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a18f5df131ed2c04914ea120f1808c6d2">min_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a18f5df131ed2c04914ea120f1808c6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum of a vector with final reduction on the CPU.  <a href="#a18f5df131ed2c04914ea120f1808c6d2">More...</a><br/></td></tr>
<tr class="separator:a18f5df131ed2c04914ea120f1808c6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39b63615f03a2d316593075f9060b2d"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename NumericT &gt; </td></tr>
<tr class="memitem:ad39b63615f03a2d316593075f9060b2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad39b63615f03a2d316593075f9060b2d">min_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad39b63615f03a2d316593075f9060b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#ad39b63615f03a2d316593075f9060b2d">More...</a><br/></td></tr>
<tr class="separator:ad39b63615f03a2d316593075f9060b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4362cfc81d9d44c6cb84eb4c809babd0"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a4362cfc81d9d44c6cb84eb4c809babd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4362cfc81d9d44c6cb84eb4c809babd0">sum_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a4362cfc81d9d44c6cb84eb4c809babd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of a vector with final reduction on the device (GPU, etc.)  <a href="#a4362cfc81d9d44c6cb84eb4c809babd0">More...</a><br/></td></tr>
<tr class="separator:a4362cfc81d9d44c6cb84eb4c809babd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2257c033c8155745f3b0fa5de168c4dd"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename NumericT &gt; </td></tr>
<tr class="memitem:a2257c033c8155745f3b0fa5de168c4dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2257c033c8155745f3b0fa5de168c4dd">sum_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a2257c033c8155745f3b0fa5de168c4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a2257c033c8155745f3b0fa5de168c4dd">More...</a><br/></td></tr>
<tr class="separator:a2257c033c8155745f3b0fa5de168c4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbacf04789215a3a748eca63743d50af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbacf04789215a3a748eca63743d50af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acbacf04789215a3a748eca63743d50af">plane_rotation</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2, T alpha, T beta)</td></tr>
<tr class="memdesc:acbacf04789215a3a748eca63743d50af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a plane rotation of two vectors.  <a href="#acbacf04789215a3a748eca63743d50af">More...</a><br/></td></tr>
<tr class="separator:acbacf04789215a3a748eca63743d50af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cad03793f02f934964c26739fe85a0"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a36cad03793f02f934964c26739fe85a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a36cad03793f02f934964c26739fe85a0">inclusive_scan</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec2)</td></tr>
<tr class="memdesc:a36cad03793f02f934964c26739fe85a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements an inclusive scan.  <a href="#a36cad03793f02f934964c26739fe85a0">More...</a><br/></td></tr>
<tr class="separator:a36cad03793f02f934964c26739fe85a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc54859fae3c2b2b70913519f089e3e7"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:acc54859fae3c2b2b70913519f089e3e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acc54859fae3c2b2b70913519f089e3e7">inclusive_scan</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec)</td></tr>
<tr class="memdesc:acc54859fae3c2b2b70913519f089e3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an in-place inclusive scan of a vector.  <a href="#acc54859fae3c2b2b70913519f089e3e7">More...</a><br/></td></tr>
<tr class="separator:acc54859fae3c2b2b70913519f089e3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1b00757223e6feecf70a8657a9f096"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a7f1b00757223e6feecf70a8657a9f096"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7f1b00757223e6feecf70a8657a9f096">exclusive_scan</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec2)</td></tr>
<tr class="memdesc:a7f1b00757223e6feecf70a8657a9f096"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements an exclusive scan.  <a href="#a7f1b00757223e6feecf70a8657a9f096">More...</a><br/></td></tr>
<tr class="separator:a7f1b00757223e6feecf70a8657a9f096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60eecbc22625098b609f65633b409e2"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad60eecbc22625098b609f65633b409e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad60eecbc22625098b609f65633b409e2">exclusive_scan</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec)</td></tr>
<tr class="memdesc:ad60eecbc22625098b609f65633b409e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace exclusive scan of a vector.  <a href="#ad60eecbc22625098b609f65633b409e2">More...</a><br/></td></tr>
<tr class="separator:ad60eecbc22625098b609f65633b409e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5b5cb81b46208cae772a5e0813f02517"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5b5cb81b46208cae772a5e0813f02517">SVD_HOUSEHOLDER_UPDATE_QR_KERNEL</a> = &quot;house_update_QR&quot;</td></tr>
<tr class="separator:a5b5cb81b46208cae772a5e0813f02517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349e6e78f95ef631a5f2736158766739"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a349e6e78f95ef631a5f2736158766739">SVD_MATRIX_TRANSPOSE_KERNEL</a> = &quot;transpose_inplace&quot;</td></tr>
<tr class="separator:a349e6e78f95ef631a5f2736158766739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05717ddd22894376e780b075d59616ed"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a05717ddd22894376e780b075d59616ed">SVD_INVERSE_SIGNS_KERNEL</a> = &quot;inverse_signs&quot;</td></tr>
<tr class="separator:a05717ddd22894376e780b075d59616ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bedacb51ec9b425baf52ee7f68bdba"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a15bedacb51ec9b425baf52ee7f68bdba">SVD_GIVENS_PREV_KERNEL</a> = &quot;givens_prev&quot;</td></tr>
<tr class="separator:a15bedacb51ec9b425baf52ee7f68bdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8477d884683dafc7e6ca04f2e02a1d1f"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8477d884683dafc7e6ca04f2e02a1d1f">SVD_FINAL_ITER_UPDATE_KERNEL</a> = &quot;final_iter_update&quot;</td></tr>
<tr class="separator:a8477d884683dafc7e6ca04f2e02a1d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a439370108ddfa59c2fcb4136b13c8d"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3a439370108ddfa59c2fcb4136b13c8d">SVD_UPDATE_QR_COLUMN_KERNEL</a> = &quot;update_qr_column&quot;</td></tr>
<tr class="separator:a3a439370108ddfa59c2fcb4136b13c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e62fa452895c889f7bad9700300994d"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8e62fa452895c889f7bad9700300994d">SVD_HOUSEHOLDER_UPDATE_A_LEFT_KERNEL</a> = &quot;house_update_A_left&quot;</td></tr>
<tr class="separator:a8e62fa452895c889f7bad9700300994d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace85ea4095e9e7404b6f77b767ac000f"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ace85ea4095e9e7404b6f77b767ac000f">SVD_HOUSEHOLDER_UPDATE_A_RIGHT_KERNEL</a> = &quot;house_update_A_right&quot;</td></tr>
<tr class="separator:ace85ea4095e9e7404b6f77b767ac000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a5ce1f7230502c9d1ee87dcc24c8b4"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a04a5ce1f7230502c9d1ee87dcc24c8b4">SVD_HOUSEHOLDER_UPDATE_QL_KERNEL</a> = &quot;house_update_QL&quot;</td></tr>
<tr class="separator:a04a5ce1f7230502c9d1ee87dcc24c8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides all linear algebra operations which are not covered by operator overloads. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab87a5b5e7c60eee5c2e45f9ab21c935c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html">viennacl::linalg::detail::spai::fspai_tag</a> <a class="el" href="namespaceviennacl_1_1linalg.html#ab87a5b5e7c60eee5c2e45f9ab21c935c">viennacl::linalg::fspai_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="spai_8hpp_source.html#l00067">67</a> of file <a class="el" href="spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1938ef67659d8ba96e9b9517e680cccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">viennacl::linalg::detail::spai::spai_tag</a> <a class="el" href="namespaceviennacl_1_1linalg.html#a1938ef67659d8ba96e9b9517e680cccf">viennacl::linalg::spai_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="spai_8hpp_source.html#l00066">66</a> of file <a class="el" href="spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a3ba810acdca541a5eada4560982a645c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceviennacl_1_1linalg.html#a3ba810acdca541a5eada4560982a645c">viennacl::linalg::amg_coarsening_method</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of coarsening methods for algebraic multigrid. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3ba810acdca541a5eada4560982a645ca5167faa7286ca297508f581b26a048dc"></a>AMG_COARSENING_METHOD_ONEPASS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3ba810acdca541a5eada4560982a645ca867e1cc6319da3a2d502c9878d27170d"></a>AMG_COARSENING_METHOD_AGGREGATION&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3ba810acdca541a5eada4560982a645ca0d4c883a9aa8a8514fb260ac404e3c8b"></a>AMG_COARSENING_METHOD_MIS2_AGGREGATION&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="amg__base_8hpp_source.html#l00046">46</a> of file <a class="el" href="amg__base_8hpp_source.html">amg_base.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9933216144a64dbd433ec02c95bbfdd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceviennacl_1_1linalg.html#a9933216144a64dbd433ec02c95bbfdd7">viennacl::linalg::amg_interpolation_method</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of interpolation methods for algebraic multigrid. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9933216144a64dbd433ec02c95bbfdd7a48d5bb166d266affee4d526e8671bec2"></a>AMG_INTERPOLATION_METHOD_DIRECT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9933216144a64dbd433ec02c95bbfdd7a31dbd459c3ba8068280a6ec1bca00482"></a>AMG_INTERPOLATION_METHOD_AGGREGATION&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9933216144a64dbd433ec02c95bbfdd7afcffee5ed6e7ad032a9ffebe615b5932"></a>AMG_INTERPOLATION_METHOD_SMOOTHED_AGGREGATION&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="amg__base_8hpp_source.html#l00054">54</a> of file <a class="el" href="amg__base_8hpp_source.html">amg_base.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8c3c6c86f630026ed266c2d4f807deb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename ScalarType1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::am </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00111">111</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaca65d04ae5521b0f34c5bbeae136b1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename ScalarType1 , typename ScalarType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ambm </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00139">139</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21deecdfe93a77e1d341934ff816cb9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename ScalarType1 , typename ScalarType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ambm_m </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00174">174</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2573d0a189f441a1ee62209ef7c1cfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename S2 , typename ScalarType1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::value &gt;::type viennacl::linalg::as </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for the generic operation s1 = s2 @ alpha, where s1 and s2 are GPU scalars, @ denotes multiplication or division, and alpha is either a GPU or a CPU scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first (GPU) scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second (GPU) scalar </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar alpha in the operation </td></tr>
    <tr><td class="paramname">len_alpha</td><td>If alpha is obtained from summing over a small GPU vector (e.g. the final summation after a multi-group reduction), then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>If true, then s2 / alpha instead of s2 * alpha is computed </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>If true, then (-alpha) is used instead of alpha </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="scalar__operations_8hpp_source.html#l00065">65</a> of file <a class="el" href="scalar__operations_8hpp_source.html">scalar_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04dc6e11ec77f197ac82ec2b2580b672"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::value &gt;::type viennacl::linalg::asbs </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for the generic operation s1 = s2 @ alpha + s3 @ beta, where s1, s2 and s3 are GPU scalars, @ denotes multiplication or division, and alpha, beta are either a GPU or a CPU scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first (GPU) scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second (GPU) scalar </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar alpha in the operation </td></tr>
    <tr><td class="paramname">len_alpha</td><td>If alpha is a small GPU vector, which needs to be summed in order to obtain the final scalar, then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>If true, then s2 / alpha instead of s2 * alpha is computed </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>If true, then (-alpha) is used instead of alpha </td></tr>
    <tr><td class="paramname">s3</td><td>The third (GPU) scalar </td></tr>
    <tr><td class="paramname">beta</td><td>The scalar beta in the operation </td></tr>
    <tr><td class="paramname">len_beta</td><td>If beta is obtained from summing over a small GPU vector (e.g. the final summation after a multi-group reduction), then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_beta</td><td>If true, then s2 / beta instead of s2 * beta is computed </td></tr>
    <tr><td class="paramname">flip_sign_beta</td><td>If true, then (-beta) is used instead of beta </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="scalar__operations_8hpp_source.html#l00114">114</a> of file <a class="el" href="scalar__operations_8hpp_source.html">scalar_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02e0b6945112135e1e023cd9da9c8805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::value &gt;::type viennacl::linalg::asbs_s </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for the generic operation s1 += s2 @ alpha + s3 @ beta, where s1, s2 and s3 are GPU scalars, @ denotes multiplication or division, and alpha, beta are either a GPU or a CPU scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first (GPU) scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second (GPU) scalar </td></tr>
    <tr><td class="paramname">alpha</td><td>The scalar alpha in the operation </td></tr>
    <tr><td class="paramname">len_alpha</td><td>If alpha is a small GPU vector, which needs to be summed in order to obtain the final scalar, then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>If true, then s2 / alpha instead of s2 * alpha is computed </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>If true, then (-alpha) is used instead of alpha </td></tr>
    <tr><td class="paramname">s3</td><td>The third (GPU) scalar </td></tr>
    <tr><td class="paramname">beta</td><td>The scalar beta in the operation </td></tr>
    <tr><td class="paramname">len_beta</td><td>If beta is obtained from summing over a small GPU vector (e.g. the final summation after a multi-group reduction), then supply the length of the array here </td></tr>
    <tr><td class="paramname">reciprocal_beta</td><td>If true, then s2 / beta instead of s2 * beta is computed </td></tr>
    <tr><td class="paramname">flip_sign_beta</td><td>If true, then (-beta) is used instead of beta </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="scalar__operations_8hpp_source.html#l00170">170</a> of file <a class="el" href="scalar__operations_8hpp_source.html">scalar_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63e91b53adcd3948768cf55be0858f8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ScalarType1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::av </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00078">78</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae13999d03d7afcfb56ffb08dc87c03d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::avbv </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00107">107</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a473a4f8052c5c01059b65274b5031c53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::avbv_v </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00144">144</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bb0d10b3784c0eec40296cd94f1bd38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::bidiag_pack </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>sh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stores the diagonal and the superdiagonal of a matrix in two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix from which the vectors will be extracted of. </td></tr>
    <tr><td class="paramname">dh</td><td>The vector in which the diagonal of the matrix will be stored in. </td></tr>
    <tr><td class="paramname">sh</td><td>The vector in which the superdiagonal of the matrix will be stored in. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00901">901</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57e162beeda5427abc31ad04af903f75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viennacl::linalg::bisect </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>superdiagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bisect The bisection algorithm computes the eigevalues of a symmetric tridiagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagonal</td><td>diagonal elements of the matrix </td></tr>
    <tr><td class="paramname">superdiagonal</td><td>superdiagonal elements of the matrix </td></tr>
    <tr><td class="paramname">eigenvalues</td><td>Vectors with the eigenvalues in ascending order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return false if any errors occured</dd></dl>
<p>overloaded function template: std::vectors as parameters </p>

<p>Definition at line <a class="el" href="bisect__gpu_8hpp_source.html#l00060">60</a> of file <a class="el" href="bisect__gpu_8hpp_source.html">bisect_gpu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54d70c731aed90556e228b7f14ac3a52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;typename VectorT::value_type&gt;::type &gt; viennacl::linalg::bisect </td>
          <td>(</td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>alphas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>betas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the bisect-algorithm for the calculation of the eigenvalues of a tridiagonal matrix. Experimental - interface might change. </p>
<p>Refer to "Calculation of the Eigenvalues of a Symmetric Tridiagonal Matrix by the Method of Bisection" in the Handbook Series Linear Algebra, contributed by Barth, Martin, and Wilkinson. <a href="http://www.maths.ed.ac.uk/~aar/papers/bamawi.pdf">http://www.maths.ed.ac.uk/~aar/papers/bamawi.pdf</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alphas</td><td>Elements of the main diagonal </td></tr>
    <tr><td class="paramname">betas</td><td>Elements of the secondary diagonal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the eigenvalues of the tridiagonal matrix defined by alpha and beta </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bisect_8cpp-example.html#a3">bisect.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="bisect_8hpp_source.html#l00078">78</a> of file <a class="el" href="bisect_8hpp_source.html">bisect.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04b0d8c9704298545af9ec48ffb242eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viennacl::linalg::bisect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>superdiagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bisect The bisection algorithm computes the eigevalues of a symmetric tridiagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagonal</td><td>diagonal elements of the matrix </td></tr>
    <tr><td class="paramname">superdiagonal</td><td>superdiagonal elements of the matrix </td></tr>
    <tr><td class="paramname">eigenvalues</td><td>Vectors with the eigenvalues in ascending order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return false if any errors occured</dd></dl>
<p>overloaded function template: viennacl::vectors as parameters </p>

<p>Definition at line <a class="el" href="bisect__gpu_8hpp_source.html#l00122">122</a> of file <a class="el" href="bisect__gpu_8hpp_source.html">bisect_gpu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4da8975bfe53f8a05145c8b44410ab27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::bluestein </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bluestein's algorithm for computing Fourier transformation. </p>
<p>Currently, Works only for sizes of input data which less than 2^16. Uses a lot of additional memory, but should be fast for any size of data. Serial implementation has something about o(n * lg n) complexity </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fft_8cpp-example.html#a9">fft.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00235">235</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a09e3195c87a9c70c0e2d106766bc10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__col__sum.html">viennacl::op_col_sum</a> &gt; viennacl::linalg::column_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User interface function for computing the sum of all elements of each column of a matrix. </p>

<p>Definition at line <a class="el" href="sum_8hpp_source.html#l00109">109</a> of file <a class="el" href="sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb2133d21998c98d91050e556c72cdd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LHS, const RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__col__sum.html">viennacl::op_col_sum</a>&gt; viennacl::linalg::column_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User interface function for computing the sum of all elements of each column of a matrix specified by a matrix operation. </p>
<p>Typical use case: vector&lt;double&gt; my_sums = <a class="el" href="namespaceviennacl_1_1linalg.html#a6a09e3195c87a9c70c0e2d106766bc10" title="User interface function for computing the sum of all elements of each column of a matrix...">viennacl::linalg::column_sum</a>(A + B); </p>

<p>Definition at line <a class="el" href="sum_8hpp_source.html#l00124">124</a> of file <a class="el" href="sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa27d986659389c74adfa0744590afc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::column_sum_impl </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00686">686</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a45f767da9ec63fd7e37c1fae58dc2727"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::complex_to_real </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create real vector from complex vector (even elements(2*k) = real part, odd elements(2*k+1) = imaginary part) </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fft_8cpp-example.html#a11">fft.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00421">421</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a251d7c95cbf8be55cb8bddf55125b6eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DestNumericT , typename SrcNumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::convert </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; DestNumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SrcNumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00051">51</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a871e1a8fb109d90254a628d1f3af7067"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DestNumericT , typename SrcNumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::convert </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; DestNumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; SrcNumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00054">54</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b596f98d234d40fe9460d0077d1fcc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::convolve_i </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>input2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0aec751d37dbd7b6d45ea9340fa8a317"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::copy_vec </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>row_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>col_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies a row or a column from a matrix to a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix where to copy from. </td></tr>
    <tr><td class="paramname">V</td><td>The vector to fill with data. </td></tr>
    <tr><td class="paramname">row_start</td><td>The number of the first row to copy. </td></tr>
    <tr><td class="paramname">col_start</td><td>The number of the first column to copy. </td></tr>
    <tr><td class="paramname">copy_col</td><td>Set to TRUE to copy a column, FALSE to copy a row. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00942">942</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae08098ec11a08f2989e4bdd69006e528"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>batch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>sign</em> = <code><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a>&#160;</td>
          <td class="paramname"><em>data_order</em> = <code><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct 1D algorithm for computing Fourier transformation. </p>
<p>Works on any sizes of data. Serial implementation has o(n^2) complexity </p>

<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00051">51</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af306ba22f2e1a5617990d7756fce3a18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>batch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>sign</em> = <code><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a>&#160;</td>
          <td class="paramname"><em>data_order</em> = <code><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct 2D algorithm for computing Fourier transformation. </p>
<p>Works on any sizes of data. Serial implementation has o(n^2) complexity </p>

<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00089">89</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad54e2b8a6ab1f2105fcbb8e3db7af0cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;typename MatrixT::value_type&gt;::type viennacl::linalg::eig </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">power_iter_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>eigenvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the calculation of the largest eigenvalue (in modulus) and the associated eigenvector using power iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">tag</td><td>Tag with termination factor </td></tr>
    <tr><td class="paramname">eigenvec</td><td>Vector which holds the associated eigenvector once the routine completes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the largest eigenvalue computed by the power iteration method </dd></dl>

<p>Definition at line <a class="el" href="power__iter_8hpp_source.html#l00074">74</a> of file <a class="el" href="power__iter_8hpp_source.html">power_iter.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa83ef1714ec827c54aeea62f6ccfb0f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;typename MatrixT::value_type&gt;::type viennacl::linalg::eig </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">power_iter_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the calculation of eigenvalues using power iteration. Does not return the eigenvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">tag</td><td>Tag with termination factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the largest eigenvalue computed by the power iteration method </dd></dl>

<p>Definition at line <a class="el" href="power__iter_8hpp_source.html#l00119">119</a> of file <a class="el" href="power__iter_8hpp_source.html">power_iter.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5002a88fa4cc3fbe65a904797a0ecba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename DenseMatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;typename MatrixT::value_type&gt;::type &gt; viennacl::linalg::eig </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseMatrixT &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lanczos_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_eigenvectors</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the calculation of eigenvalues using lanczos (with and without reorthogonalization). </p>
<p>Implementation of Lanczos with partial reorthogonalization is implemented separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">eigenvectors_A</td><td>A dense matrix in which the eigenvectors of A will be stored. Both row- and column-major matrices are supported. </td></tr>
    <tr><td class="paramname">tag</td><td>Tag with several options for the lanczos algorithm </td></tr>
    <tr><td class="paramname">compute_eigenvectors</td><td>Boolean flag. If true, eigenvectors are computed. Otherwise the routine returns after calculating eigenvalues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the n largest eigenvalues (n defined in the <a class="el" href="classviennacl_1_1linalg_1_1lanczos__tag.html" title="A tag for the lanczos algorithm. ">lanczos_tag</a>) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lanczos_8cpp-example.html#a7">lanczos.cpp</a>, and <a class="el" href="power-iter_8cpp-example.html#a6">power-iter.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="lanczos_8hpp_source.html#l00452">452</a> of file <a class="el" href="lanczos_8hpp_source.html">lanczos.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7afda6c5b14466eaec9b3bd9db81d988"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="structviennacl_1_1result__of_1_1cpu__value__type.html">viennacl::result_of::cpu_value_type</a>&lt;typename MatrixT::value_type&gt;::type &gt; viennacl::linalg::eig </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lanczos_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the calculation of eigenvalues using lanczos (with and without reorthogonalization). </p>
<p>Implementation of Lanczos with partial reorthogonalization is implemented separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">tag</td><td>Tag with several options for the lanczos algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the n largest eigenvalues (n defined in the <a class="el" href="classviennacl_1_1linalg_1_1lanczos__tag.html" title="A tag for the lanczos algorithm. ">lanczos_tag</a>) </dd></dl>

<p>Definition at line <a class="el" href="lanczos_8hpp_source.html#l00505">505</a> of file <a class="el" href="lanczos_8hpp_source.html">lanczos.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3207a7759c34cfe4e961aabadd616a13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, <a class="el" href="structviennacl_1_1op__element__binary.html">op_element_binary</a>&lt;<a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; &gt; viennacl::linalg::element_div </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a88e78e9d4c4c2757e900f9d72d3991d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::element_op </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The result vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">proxy</td><td>The proxy object holding v2, v3 and the operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00255">255</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a276ca58ba0ee040e4fd8c2b95d0a2674"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::element_op </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; T &gt;, const matrix_base&lt; T &gt;, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the element-wise operation A = B .* C and A = B ./ C for matrices (using MATLAB syntax). Don't use this function directly, use <a class="el" href="namespaceviennacl_1_1linalg.html#a28ab8924636e24b01c6bad13a7321343">element_prod()</a> and <a class="el" href="namespaceviennacl_1_1linalg.html#a3207a7759c34cfe4e961aabadd616a13">element_div()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The result matrix (or -range, or -slice) </td></tr>
    <tr><td class="paramname">proxy</td><td>The proxy object holding B, C, and the operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00702">702</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28ab8924636e24b01c6bad13a7321343"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, <a class="el" href="structviennacl_1_1op__element__binary.html">op_element_binary</a>&lt;<a class="el" href="structviennacl_1_1op__prod.html">op_prod</a>&gt; &gt; viennacl::linalg::element_prod </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f1b00757223e6feecf70a8657a9f096"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements an exclusive scan. </p>
<p>Given an element vector (x_0, x_1, ..., x_{n-1}), this routine computes (0, x_0, x_0 + x_1, ..., x_0 + x_1 + ... + x_{n-2})</p>
<p>The two vectors either need to be the same (in-place), or reside in distinct memory regions. Partial overlaps of vec1 and vec2 are not allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Input vector. </td></tr>
    <tr><td class="paramname">vec2</td><td>The output vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01240">1240</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad60eecbc22625098b609f65633b409e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inplace exclusive scan of a vector. </p>
<p>Given an element vector (x_0, x_1, ..., x_{n-1}), this routine overwrites the input vector with (0, x_0, x_0 + x_1, ..., x_0 + x_1 + ... + x_{n-2}) </p>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01273">1273</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe38139ef1b1fa4581104998c73ec424"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::extract_L </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the lower triangular part L from A. </p>
<p>Diagonal of L is stored explicitly in order to enable better code reuse. </p>

<p>Definition at line <a class="el" href="ilu__operations_8hpp_source.html#l00056">56</a> of file <a class="el" href="ilu__operations_8hpp_source.html">ilu_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61379d44e4a0d7a05f0b327424796ca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::extract_LU </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the lower triangular part L and the upper triangular part U from A. </p>
<p>Diagonals of L and U are stored explicitly in order to enable better code reuse. </p>

<p>Definition at line <a class="el" href="ilu__operations_8hpp_source.html#l00156">156</a> of file <a class="el" href="ilu__operations_8hpp_source.html">ilu_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22c5bc49dfdc3c85b101694cca8d23cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::givens_next </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the matrix Q. It is part of the tql2 algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>The matrix to be updated. </td></tr>
    <tr><td class="paramname">tmp1</td><td>Vector with data from the tql2 algorithm. </td></tr>
    <tr><td class="paramname">tmp2</td><td>Vector with data from the tql2 algorithm. </td></tr>
    <tr><td class="paramname">l</td><td>Data from the tql2 algorithm. </td></tr>
    <tr><td class="paramname">m</td><td>Data from the tql2 algorithm. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01092">1092</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a706c4d0b456ec669c3a8c2eea8cc3fc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::house_update_A_left </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function applies a householder transformation to a matrix. A &lt;- P * A with a householder reflection P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be updated. </td></tr>
    <tr><td class="paramname">D</td><td>The normalized householder vector. </td></tr>
    <tr><td class="paramname">start</td><td>The repetition counter. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00981">981</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34c93371a5e45fe498bf1dc4dd475497"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::house_update_A_right </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function applies a householder transformation to a matrix: A &lt;- A * P with a householder reflection P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be updated. </td></tr>
    <tr><td class="paramname">D</td><td>The normalized householder vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01018">1018</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab58751eae7fc9a4af532b447728880ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::house_update_QL </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>A_size1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the matrix Q, which is needed for the computation of the eigenvectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>The matrix to be updated. </td></tr>
    <tr><td class="paramname">D</td><td>The householder vector. </td></tr>
    <tr><td class="paramname">A_size1</td><td>size1 of matrix A </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01053">1053</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15fb87042a449e9544121d6f3e004fd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::icc_chow_patel_sweep </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aij_L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs one nonlinear relaxation step in the Chow-Patel-ICC (cf. Algorithm 3 in paper, but for L rather than U) </p>
<p>We use a fully synchronous (Jacobi-like) variant, because asynchronous methods as described in the paper are a nightmare to debug (and particularly funny if they sometimes fail, sometimes not)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Factor L to be updated for the incomplete Cholesky factorization </td></tr>
    <tr><td class="paramname">aij_L</td><td>Lower triangular potion from system matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ilu__operations_8hpp_source.html#l00121">121</a> of file <a class="el" href="ilu__operations_8hpp_source.html">ilu_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3d5695fc60367c6d3240ba6d693c015"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::icc_scale </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the values extracted from A such that A' = DAD has unit diagonal. Updates values from A in L accordingly. </p>
<p>Since A should not be modified (const-correctness), updates are in L. </p>

<p>Definition at line <a class="el" href="ilu__operations_8hpp_source.html#l00087">87</a> of file <a class="el" href="ilu__operations_8hpp_source.html">ilu_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81ab7c38b6358aa7c3b71b4a0bb4b55f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilu_chow_patel_sweep </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>aij_L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>aij_U_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs one nonlinear relaxation step in the Chow-Patel-ILU (cf. Algorithm 2 in paper) </p>
<p>We use a fully synchronous (Jacobi-like) variant, because asynchronous methods as described in the paper are a nightmare to debug (and particularly funny if they sometimes fail, sometimes not)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lower-triangular matrix L in LU factorization </td></tr>
    <tr><td class="paramname">aij_L</td><td>Lower-triangular matrix L from A </td></tr>
    <tr><td class="paramname">U_trans</td><td>Upper-triangular matrix U in CSC-storage, which is the same as U^trans in CSR-storage </td></tr>
    <tr><td class="paramname">aij_U_trans</td><td>Upper-triangular matrix from A in CSC-storage, which is the same as U^trans in CSR-storage </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ilu__operations_8hpp_source.html#l00272">272</a> of file <a class="el" href="ilu__operations_8hpp_source.html">ilu_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9f852e45ca5d5a753db43033bf4444b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilu_form_neumann_matrix </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>diag_R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the lower triangular part L and the upper triangular part U from A. </p>
<p>Diagonals of L and U are stored explicitly in order to enable better code reuse. </p>

<p>Definition at line <a class="el" href="ilu__operations_8hpp_source.html#l00305">305</a> of file <a class="el" href="ilu__operations_8hpp_source.html">ilu_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9dd52d566f9dbb5fad53131f294fd6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilu_scale </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the values extracted from A such that A' = DAD has unit diagonal. Updates values from A in L and U accordingly. </p>
<p>Since A should not be modified (const-correctness), updates are in L and U. </p>

<p>Definition at line <a class="el" href="ilu__operations_8hpp_source.html#l00188">188</a> of file <a class="el" href="ilu__operations_8hpp_source.html">ilu_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ba9a2427b8985f9e6f8cb507346df5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilu_transpose </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposition B &lt;- A^T, where the aij-vector is permuted in the same way as the value array in A when assigned to B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input matrix to be transposed </td></tr>
    <tr><td class="paramname">B</td><td>Output matrix containing the transposed matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ilu__operations_8hpp_source.html#l00220">220</a> of file <a class="el" href="ilu__operations_8hpp_source.html">ilu_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36cad03793f02f934964c26739fe85a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements an inclusive scan. </p>
<p>Given an element vector (x_0, x_1, ..., x_{n-1}), this routine computes (x_0, x_0 + x_1, ..., x_0 + x_1 + ... + x_{n-1})</p>
<p>The two vectors either need to be the same (in-place), or reside in distinct memory regions. Partial overlaps of vec1 and vec2 are not allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Input vector. </td></tr>
    <tr><td class="paramname">vec2</td><td>The output vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01190">1190</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc54859fae3c2b2b70913519f089e3e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements an in-place inclusive scan of a vector. </p>
<p>Given an input element vector (x_0, x_1, ..., x_{n-1}), this routine overwrites the vector with (x_0, x_0 + x_1, ..., x_0 + x_1 + ... + x_{n-1}) </p>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01223">1223</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94ca8c9792940a5cf845c844495b2f49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> viennacl::linalg::index_norm_inf </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the index of the first entry that is equal to the supremum-norm in modulus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. Note that the result must be a CPU scalar </dd></dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00845">845</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a561f11b3404e4657b4e8dbc971488836"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> viennacl::linalg::index_norm_inf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00871">871</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab35950c4374eb3be08a03d852508c01a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorT1 , typename VectorT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT1 &gt;::type &gt;::value, typename VectorT1::value_type&gt;::type viennacl::linalg::inner_prod </td>
          <td>(</td>
          <td class="paramtype">VectorT1 const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT2 const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="blas1_8cpp-example.html#a8">blas1.cpp</a>, and <a class="el" href="lanczos_8cpp-example.html#a13">lanczos.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="inner__prod_8hpp_source.html#l00100">100</a> of file <a class="el" href="inner__prod_8hpp_source.html">inner_prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad273e72f4a44fcd9802e3609d06af5e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt; viennacl::linalg::inner_prod </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inner__prod_8hpp_source.html#l00116">116</a> of file <a class="el" href="inner__prod_8hpp_source.html">inner_prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4c12bee75a1dff46f0bd4b48abca2a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;LHS, RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt; viennacl::linalg::inner_prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inner__prod_8hpp_source.html#l00131">131</a> of file <a class="el" href="inner__prod_8hpp_source.html">inner_prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac71bae6daf6dc8a5803071f79565582a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;LHS, RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt; viennacl::linalg::inner_prod </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inner__prod_8hpp_source.html#l00145">145</a> of file <a class="el" href="inner__prod_8hpp_source.html">inner_prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac998ca060d47ba7c4b8bc1a994060ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;LHS1, RHS1, OP1&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;LHS2, RHS2, OP2&gt;, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt; viennacl::linalg::inner_prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inner__prod_8hpp_source.html#l00160">160</a> of file <a class="el" href="inner__prod_8hpp_source.html">inner_prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d9ef35327424393d599467538882522"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a> &gt; viennacl::linalg::inner_prod </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_tuple&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y_tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inner__prod_8hpp_source.html#l00173">173</a> of file <a class="el" href="inner__prod_8hpp_source.html">inner_prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e24897b81aa448d7ba7bcb4b7c0befa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inner_prod_cpu </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inner product of two vectors with the final reduction step on the CPU - dispatcher interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar (on the gpu) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00459">459</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0be57ce7d327b479a4e9dc8bf0cb43ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inner_prod_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00489">489</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e83011f9d11da294199a39c8ca24af9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inner_prod_cpu </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00500">500</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a592732c3d41ad443d78d8976cdf511e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename S3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inner_prod_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00512">512</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af170246b8ee051270ea2c9fbd141d832"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inner_prod_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_tuple&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inner products &lt;x, y1&gt;, &lt;x, y2&gt;, ..., &lt;x, y_N&gt; and writes the result to a (sub-)vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The common vector </td></tr>
    <tr><td class="paramname">y_tuple</td><td>A collection of vector, all of the same size. </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar (on the gpu). Needs to match the number of elements in y_tuple </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00530">530</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a994b34490c41579a04fbd4f95ce00dd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inner_prod_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inner product of two vectors - dispatcher interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar (on the gpu) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00387">387</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2674678361df8200d391360dc6b8631c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inner_prod_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00417">417</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43c256ba255b9d600f2682f3c10ef1e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inner_prod_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00428">428</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34b652a0b60f992dc7c2c89c8305c628"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inner_prod_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00440">440</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83f573386903bae3a5379ab4cbfc5e2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , unsigned int ALIGNMENT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; viennacl::linalg::inplace_qr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; T, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of inplace-QR factorization of a ViennaCL matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense ViennaCL matrix to be factored </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="least-squares_8cpp-example.html#a6">least-squares.cpp</a>, and <a class="el" href="qr_8cpp-example.html#a5">qr.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="qr_8hpp_source.html#l00647">647</a> of file <a class="el" href="qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9728d85f4f7307ed9096524de8c77cdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MatrixType::value_type&gt; viennacl::linalg::inplace_qr </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of inplace-QR factorization for a general Boost.uBLAS compatible matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense compatible to Boost.uBLAS </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="qr_8hpp_source.html#l00658">658</a> of file <a class="el" href="qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf77bb0fe92ef09522d0458ee9df03db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType1 , typename VectorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_qr_apply_trans_Q </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType1 const &amp;&#160;</td>
          <td class="paramname"><em>betas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Q^T b, where Q is an implicit orthogonal matrix defined via its Householder reflectors stored in A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A matrix holding the Householder reflectors in the lower triangular part. Typically obtained from calling <a class="el" href="namespaceviennacl_1_1linalg.html#a83f573386903bae3a5379ab4cbfc5e2d" title="Overload of inplace-QR factorization of a ViennaCL matrix A. ">inplace_qr()</a> on the original matrix </td></tr>
    <tr><td class="paramname">betas</td><td>The scalars beta_i for each Householder reflector (I - beta_i v_i v_i^T) </td></tr>
    <tr><td class="paramname">b</td><td>The vector b to which the result Q^T b is directly written to </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="least-squares_8cpp-example.html#a7">least-squares.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="qr_8hpp_source.html#l00608">608</a> of file <a class="el" href="qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa926ae9008c3343c337f2aa5a90e8734"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , unsigned int ALIGNMENT, typename VectorType1 , unsigned int A2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_qr_apply_trans_Q </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; T, F, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType1 const &amp;&#160;</td>
          <td class="paramname"><em>betas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; T, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr_8hpp_source.html#l00628">628</a> of file <a class="el" href="qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf06f61be9418e5817eed66004f9dd2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="blas2_8cpp-example.html#a14">blas2.cpp</a>, and <a class="el" href="least-squares_8cpp-example.html#a16">least-squares.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00217">217</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aacfff27023e7934e8fc91add06a00015"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct inplace solver for triangular systems with multiple transposed right hand sides, i.e. A \ B^T (MATLAB notation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The proxy for the transposed matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00230">230</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf694e493220c997a56117180898e34d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct inplace solver for transposed triangular systems with multiple right hand sides, i.e. A^T \ B (MATLAB notation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">B</td><td>The matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00251">251</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cd904fcd01a99005ca9f83f3c696b41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType , class ScalarType , typename SOLVERTAG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value&gt;::type viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out triangular inplace solves. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag (<a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html" title="A tag class representing a lower triangular matrix. ">lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html" title="A tag class representing a lower triangular matrix with unit diagonal. ">unit_lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html" title="A tag class representing an upper triangular matrix with unit diagonal. ">unit_upper_tag</a>, or <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html" title="A tag class representing an upper triangular matrix. ">upper_tag</a>) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sparse__matrix__operations_8hpp_source.html#l00258">258</a> of file <a class="el" href="sparse__matrix__operations_8hpp_source.html">sparse_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab46903287704fb77078a994bbe7450c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct inplace solver for transposed triangular systems with multiple transposed right hand sides, i.e. A^T \ B^T (MATLAB notation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The transposed matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00271">271</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02babae1af157516bd1e92d28c711957"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType , class ScalarType , typename SOLVERTAG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value&gt;::type viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const SparseMatrixType, const SparseMatrixType, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out transposed triangular inplace solves. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag (<a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html" title="A tag class representing a lower triangular matrix. ">lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html" title="A tag class representing a lower triangular matrix with unit diagonal. ">unit_lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html" title="A tag class representing an upper triangular matrix with unit diagonal. ">unit_upper_tag</a>, or <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html" title="A tag class representing an upper triangular matrix. ">upper_tag</a>) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sparse__matrix__operations_8hpp_source.html#l00296">296</a> of file <a class="el" href="sparse__matrix__operations_8hpp_source.html">sparse_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09afb0da48b9fe60af6bd01f59e31f50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inplace solution of a triangular system. Matlab notation A \ b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The system matrix (a dense matrix for which only the respective triangular form is used) </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The tag (either <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html" title="A tag class representing a lower triangular matrix. ">lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html" title="A tag class representing a lower triangular matrix with unit diagonal. ">unit_lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html" title="A tag class representing an upper triangular matrix. ">upper_tag</a>, or <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html" title="A tag class representing an upper triangular matrix with unit diagonal. ">unit_upper_tag</a>) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00453">453</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf2d1656abbdd59e83cb335f22f94743"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inplace solution of a triangular system with transposed system matrix.. Matlab notation A' \ b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The transposed system matrix (a dense matrix for which only the respective triangular form is used) </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The tag (either <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html" title="A tag class representing a lower triangular matrix. ">lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html" title="A tag class representing a lower triangular matrix with unit diagonal. ">unit_lower_tag</a>, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html" title="A tag class representing an upper triangular matrix. ">upper_tag</a>, or <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html" title="A tag class representing an upper triangular matrix with unit diagonal. ">unit_upper_tag</a>) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00468">468</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1050039fb153ae8ad818390a30f96bc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_factorize </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU factorization of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="blas2_8cpp-example.html#a15">blas2.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="lu_8hpp_source.html#l00042">42</a> of file <a class="el" href="lu_8hpp_source.html">lu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81d79dbd3e481d712806e161aba77d3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_factorize </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1column__major.html">viennacl::column_major</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU factorization of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lu_8hpp_source.html#l00118">118</a> of file <a class="el" href="lu_8hpp_source.html">lu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a118a9164bc965f8ec728eda73a5e2450"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename F1 , typename F2 , unsigned int AlignmentV1, unsigned int AlignmentV2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_substitute </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F1, AlignmentV1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F2, AlignmentV2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU substitution for the system LU = rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="blas2_8cpp-example.html#a16">blas2.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="lu_8hpp_source.html#l00201">201</a> of file <a class="el" href="lu_8hpp_source.html">lu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76316cf22830919c49106c45d28480af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename F , unsigned int MatAlignmentV, unsigned int VecAlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_substitute </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, MatAlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, VecAlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU substitution for the system LU = rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lu_8hpp_source.html#l00216">216</a> of file <a class="el" href="lu_8hpp_source.html">lu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef9f99d60acd232ba5c8819dabeb75d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::matrix_assign </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00208">208</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaaf3f49df1848ac5fa35e8ba6d59df19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::matrix_column </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00337">337</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a608ba0810205864e44796cf4713184ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::matrix_diag_from_vector </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatcher interface for A = diag(v, k) </p>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00261">261</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b883c28e757f86ae3e6f1382fe04df9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::matrix_diag_to_vector </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatcher interface for v = diag(A, k) </p>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00287">287</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad385d79ae0f63ce7b1305d5e5a0fc908"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::matrix_diagonal_assign </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00234">234</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a262adb1cc047128ec5e104da68f2755f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::matrix_row </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00312">312</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adfd5b21910a692a78c547b22b9157c2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> viennacl::linalg::max </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maxmin_8hpp_source.html#l00047">47</a> of file <a class="el" href="maxmin_8hpp_source.html">maxmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3174c1f0846b0f4801e203b2048f12de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, <a class="el" href="structviennacl_1_1op__max.html">viennacl::op_max</a> &gt; viennacl::linalg::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maxmin_8hpp_source.html#l00067">67</a> of file <a class="el" href="maxmin_8hpp_source.html">maxmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a554dda7695e02807c9f56029c192bc73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__max.html">viennacl::op_max</a>&gt; viennacl::linalg::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maxmin_8hpp_source.html#l00080">80</a> of file <a class="el" href="maxmin_8hpp_source.html">maxmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94c55f3b63164f620aace12af5366cd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::max_cpu </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum of a vector with final reduction on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00928">928</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af754ca05f664675f759aca2de035bc7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::max_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00958">958</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4ba2d9041f7c09bfb2f0ec65f8cf63c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::max_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7a454946f278e2e94199871f55c081a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::max_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7c305a065383fb331678a1a968f1118f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::max_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum of a vector with final reduction on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00885">885</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73a314ab7003c20ec35e22eda0965511"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::max_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00915">915</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0a4445a6d0f1d75e7157cdc23239027"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> viennacl::linalg::min </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maxmin_8hpp_source.html#l00091">91</a> of file <a class="el" href="maxmin_8hpp_source.html">maxmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae602a9321e77bce6adb827a2514de278"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, <a class="el" href="structviennacl_1_1op__min.html">viennacl::op_min</a> &gt; viennacl::linalg::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maxmin_8hpp_source.html#l00111">111</a> of file <a class="el" href="maxmin_8hpp_source.html">maxmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5057d08504cc799dd77dfd596499bffc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, <a class="el" href="structviennacl_1_1op__min.html">viennacl::op_min</a> &gt; viennacl::linalg::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maxmin_8hpp_source.html#l00123">123</a> of file <a class="el" href="maxmin_8hpp_source.html">maxmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acae51ad7f1972ca14eeedc59f08b12b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__min.html">viennacl::op_min</a>&gt; viennacl::linalg::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maxmin_8hpp_source.html#l00136">136</a> of file <a class="el" href="maxmin_8hpp_source.html">maxmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a0dc4f1adb29d19e1b55519024eeb4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::min_cpu </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum of a vector with final reduction on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01015">1015</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6f228d570bffac37abb106970b08532"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::min_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01045">1045</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63df0f54d270c1f43f87f21305500f5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::min_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add42dc3329c401285f39cb6d6e0000e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::min_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18f5df131ed2c04914ea120f1808c6d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::min_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum of a vector with final reduction on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00972">972</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad39b63615f03a2d316593075f9060b2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::min_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01002">1002</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad89501246ebdf434e5181cfa83116cb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::multiply_complex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutiply two complex vectors and store result in output. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fft_8cpp-example.html#a12">fft.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00267">267</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1682d7a829cecf20106e407aed749a49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::nmf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1linalg_1_1nmf__config.html">viennacl::linalg::nmf_config</a> const &amp;&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The nonnegative matrix factorization (approximation) algorithm as suggested by Lee and Seung. Factorizes a matrix V with nonnegative entries into matrices W and H such that ||V - W*H|| is minimized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Input matrix </td></tr>
    <tr><td class="paramname">W</td><td>First factor </td></tr>
    <tr><td class="paramname">H</td><td>Second factor </td></tr>
    <tr><td class="paramname">conf</td><td>A configuration object holding tolerances and the like </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="nmf_8cpp-example.html#a9">nmf.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="nmf_8hpp_source.html#l00057">57</a> of file <a class="el" href="nmf_8hpp_source.html">nmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2efad0d090dde0c127fa8b25a73836e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T viennacl::linalg::norm_1 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="blas1_8cpp-example.html#a9">blas1.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="norm__1_8hpp_source.html#l00061">61</a> of file <a class="el" href="norm__1_8hpp_source.html">norm_1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18799037aaa2e6b5e1778cdf203a0274"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, <a class="el" href="structviennacl_1_1op__norm__1.html">viennacl::op_norm_1</a> &gt; viennacl::linalg::norm_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="norm__1_8hpp_source.html#l00078">78</a> of file <a class="el" href="norm__1_8hpp_source.html">norm_1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5b81d05ed5510a3142a5f29e8b2525f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__norm__1.html">viennacl::op_norm_1</a>&gt; viennacl::linalg::norm_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="norm__1_8hpp_source.html#l00090">90</a> of file <a class="el" href="norm__1_8hpp_source.html">norm_1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcf0050426d4b7147d50588919f690da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_1_cpu </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the l^1-norm of a vector with final reduction on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00613">613</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a215de6e882e7e3ac0b62da887a88b827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_1_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the l^1-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00644">644</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94c58051a4819c96e29cd360e784c68f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_1_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the l^1-norm of a vector - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00598">598</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6126a98d0d6306dcb6079dd242d7570d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_1_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the l^1-norm of a vector - dispatcher interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00566">566</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2487c579ee752a9fcc31c12d0bddf604"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_1_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae46f15d01c01f92a153b3f555a15096b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T viennacl::linalg::norm_2 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="amg_8cpp-example.html#a7">amg.cpp</a>, <a class="el" href="blas1_8cpp-example.html#a10">blas1.cpp</a>, <a class="el" href="custom-kernels_8cpp-example.html#a9">custom-kernels.cpp</a>, <a class="el" href="iterative-armadillo_8cpp-example.html#a7">iterative-armadillo.cpp</a>, <a class="el" href="iterative-custom_8cpp-example.html#a1">iterative-custom.cpp</a>, <a class="el" href="iterative-eigen_8cpp-example.html#a6">iterative-eigen.cpp</a>, <a class="el" href="iterative-mtl4_8cpp-example.html#a4">iterative-mtl4.cpp</a>, <a class="el" href="iterative-ublas_8cpp-example.html#a11">iterative-ublas.cpp</a>, <a class="el" href="multithreaded_8cpp-example.html#a7">multithreaded.cpp</a>, and <a class="el" href="spai_8cpp-example.html#a3">spai.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="norm__2_8hpp_source.html#l00096">96</a> of file <a class="el" href="norm__2_8hpp_source.html">norm_2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdb24aada7fa315529db8931ed08cd5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, <a class="el" href="structviennacl_1_1op__norm__2.html">viennacl::op_norm_2</a> &gt; viennacl::linalg::norm_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="norm__2_8hpp_source.html#l00112">112</a> of file <a class="el" href="norm__2_8hpp_source.html">norm_2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a22bc2566ec601883db764cf08950c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__norm__2.html">viennacl::op_norm_2</a>&gt; viennacl::linalg::norm_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="norm__2_8hpp_source.html#l00125">125</a> of file <a class="el" href="norm__2_8hpp_source.html">norm_2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a029d42a0d83d6db9f4737ee3443cbeb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_2_cpu </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the l^2-norm of a vector with final reduction on the CPU - dispatcher interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00705">705</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f7076e4aae076d5038c880273414dda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_2_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the l^2-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00736">736</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aabf5182473bb609dedc9c85148553b55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_2_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the l^2-norm of a vector - dispatcher interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00660">660</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cab21b7d6b7e0e73c2ca2c20170eafd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_2_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the l^2-norm of a vector - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00691">691</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67813d48ed274df9fc19e6aad99fc761"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__norm__frobenius.html">op_norm_frobenius</a>&gt; viennacl::linalg::norm_frobenius </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="norm__frobenius_8hpp_source.html#l00061">61</a> of file <a class="el" href="norm__frobenius_8hpp_source.html">norm_frobenius.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acefc10657837355dd686f359e2f2bdd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_frobenius_cpu </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Frobenius norm of a vector with final reduction on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar</td></tr>
  </table>
  </dd>
</dl>
<p>Note that if A is strided or off-set, then a copy will be created. </p>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00399">399</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8d50400363dab7d4edef7d9f67954c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_frobenius_impl </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Frobenius norm of a matrix - dispatcher interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar</td></tr>
  </table>
  </dd>
</dl>
<p>Note that if A is strided or off-set, then a copy will be created. </p>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00369">369</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4de9152d556e89d823eb47a683ead11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T viennacl::linalg::norm_inf </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="blas1_8cpp-example.html#a11">blas1.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="norm__inf_8hpp_source.html#l00060">60</a> of file <a class="el" href="norm__inf_8hpp_source.html">norm_inf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3097c09e7f5ec6aa812420965f147f69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&gt;, <a class="el" href="structviennacl_1_1op__norm__inf.html">viennacl::op_norm_inf</a> &gt; viennacl::linalg::norm_inf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="norm__inf_8hpp_source.html#l00080">80</a> of file <a class="el" href="norm__inf_8hpp_source.html">norm_inf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6ac490ffc6af2faebcc33724bba120e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__norm__inf.html">viennacl::op_norm_inf</a>&gt; viennacl::linalg::norm_inf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="norm__inf_8hpp_source.html#l00093">93</a> of file <a class="el" href="norm__inf_8hpp_source.html">norm_inf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c5a2876bc65af939fc449ec07f33e6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_inf_cpu </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the supremum-norm of a vector with final reduction on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00797">797</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa79e3c0b81933fcd016f62ede5daa94b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_inf_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00828">828</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e31dfc478858db3fc0febbf9bf360d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_inf_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the supremum-norm of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00752">752</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2940be20884af6f718f1ef1882e4b09e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::norm_inf_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the supremum norm of a vector - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00783">783</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a867024b8e563104417fc09e675a1e931"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize vector on with his own size. </p>

<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00299">299</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80b166d4b1b136b020820db3d7572b0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a>&gt; viennacl::linalg::outer_prod </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a proxy class for the operation mat += vec1 * vec2^T, i.e. a rank 1 update. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multithreaded_8cpp-example.html#a6">multithreaded.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00840">840</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab66c2c1f1a8eb05b116d9b1274243b38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_bicgstab_prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r0star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_prod_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>buffer_chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>buffer_chunk_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a joint vector update operation needed for an efficient pipelined CG algorithm. </p>
<p>This routines computes for a matrix A and vectors 'p' and 'Ap': Ap = prod(A, p); and computes the two reduction stages for computing inner_prod(p,Ap), inner_prod(Ap,Ap) </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00208">208</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53f4ef640389f9a074761824cb29ac43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_bicgstab_update_s </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>Ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_prod_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>buffer_chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>buffer_chunk_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a joint vector update operation needed for an efficient pipelined CG algorithm. </p>
<p>This routines computes for vectors 's', 'r', 'Ap': s = r - alpha * Ap with alpha obtained from a reduction step on the 0th and the 3rd out of 6 chunks in inner_prod_buffer and runs the parallel reduction stage for computing inner_prod(s,s) </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00134">134</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a793be26a151c2fa6c7478143cdc75bfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_bicgstab_vector_update </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>As</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>Ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r0star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_prod_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>buffer_chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a joint vector update operation needed for an efficient pipelined BiCGStab algorithm. </p>
<p>x_{j+1} = x_j + alpha * p_j + omega * s_j r_{j+1} = s_j - omega * t_j p_{j+1} = r_{j+1} + beta * (p_j - omega * q_j) and compute first stage of r_dot_r0 = &lt;r_{j+1}, r_o^*&gt; for use in next iteration </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00171">171</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cde61c393aa96dbf2fe6f32462b18c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_cg_prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_prod_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a joint vector update operation needed for an efficient pipelined CG algorithm. </p>
<p>This routines computes for a matrix A and vectors 'p' and 'Ap': Ap = prod(A, p); and computes the two reduction stages for computing inner_prod(p,Ap), inner_prod(Ap,Ap) </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00097">97</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5aba6fa27cb6e14b04f527c64a10196"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_cg_vector_update </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>Ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_prod_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a joint vector update operation needed for an efficient pipelined CG algorithm. </p>
<p>This routines computes for vectors 'result', 'p', 'r', 'Ap': result += alpha * p; r -= alpha * Ap; p = r + beta * p; and runs the parallel reduction stage for computing inner_prod(r,r) </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00059">59</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a26e6e73c2c27a83fa958ca25e468b8ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_gmres_gram_schmidt_stage1 </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>device_krylov_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>v_k_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>v_k_internal_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vi_in_vk_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>buffer_chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the first reduction stage for multiple inner products &lt;v_i, v_k&gt;, i=0..k-1. </p>
<p>All vectors v_i are stored column-major in the array 'device_krylov_basis', where each vector has an actual length 'v_k_size', but might be padded to have 'v_k_internal_size' </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00286">286</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39b768f9d8385b980d2e5e9073d09530"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_gmres_gram_schmidt_stage2 </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>device_krylov_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>v_k_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>v_k_internal_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vi_in_vk_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>krylov_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_prod_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>buffer_chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the second reduction stage for multiple inner products &lt;v_i, v_k&gt;, i=0..k-1, then updates v_k -= &lt;v_i, v_k&gt; v_i and computes the first reduction stage for ||v_k||. </p>
<p>All vectors v_i are stored column-major in the array 'device_krylov_basis', where each vector has an actual length 'v_k_size', but might be padded to have 'v_k_internal_size' </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00321">321</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaca868298580acb7df97aff002bf6867"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_gmres_normalize_vk </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>offset_in_R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>inner_prod_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_dot_vk_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>buffer_chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>buffer_chunk_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a vector normalization needed for an efficient pipelined GMRES algorithm. </p>
<p>This routines computes for vectors 'r', 'v_k': Second reduction step for ||v_k|| v_k /= ||v_k|| First reduction step for &lt;r, v_k&gt; </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00248">248</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6faa475e03dfe776021e91f5a66f9319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_gmres_prod </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_prod_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a joint vector update operation needed for an efficient pipelined GMRES algorithm. </p>
<p>This routines computes for a matrix A and vectors 'p' and 'Ap': Ap = prod(A, p); and computes the two reduction stages for computing inner_prod(p,Ap), inner_prod(Ap,Ap) </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00393">393</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8783d68cc82f47d4862d7bb77bed2bab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::pipelined_gmres_update_result </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>krylov_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>v_k_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>v_k_internal_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes x += eta_0 r + sum_{i=1}^{k-1} eta_i v_{i-1}. </p>

<p>Definition at line <a class="el" href="iterative__operations_8hpp_source.html#l00356">356</a> of file <a class="el" href="iterative__operations_8hpp_source.html">iterative_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbacf04789215a3a748eca63743d50af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::plane_rotation </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a plane rotation of two vectors. </p>
<p>Computes (x,y) &lt;- (alpha * x + beta * y, -beta * x + alpha * y)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">alpha</td><td>The first transformation coefficient (CPU scalar) </td></tr>
    <tr><td class="paramname">beta</td><td>The second transformation coefficient (CPU scalar) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="blas1_8cpp-example.html#a12">blas1.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01152">1152</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a674c204660f61ec3c8b881fe86ef1dfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::precondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ichol0_tag const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of a ILU-preconditioner with static pattern. Optimized version for CSR matrices. </p>
<p>Refer to Chih-Jen Lin and Jorge J. Moré, Incomplete Cholesky Factorizations with Limited Memory, SIAM J. Sci. Comput., 21(1), 24–45 for one of many descriptions of incomplete Cholesky Factorizations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix in CSR format // param tag An <a class="el" href="classviennacl_1_1linalg_1_1ichol0__tag.html" title="A tag for incomplete Cholesky factorization with static pattern (ILU0) ">ichol0_tag</a> in order to dispatch among several other preconditioners. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ichol_8hpp_source.html#l00055">55</a> of file <a class="el" href="ichol_8hpp_source.html">ichol.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae92ae6061c4ac82fdea8230c9877badc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::precondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ilu0_tag const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of a ILU-preconditioner with static pattern. Optimized version for CSR matrices. </p>
<p>refer to the Algorithm in Saad's book (1996 edition)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The sparse matrix matrix. The result is directly written to A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ilu0_8hpp_source.html#l00078">78</a> of file <a class="el" href="ilu0_8hpp_source.html">ilu0.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aabecdfbc7ea786184aa5044db47a14b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::precondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ilut_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of a ILU-preconditioner with threshold. Optimized implementation for <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a>. </p>
<p>refer to Algorithm 10.6 by Saad's book (1996 edition)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix. Either a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> or of type std::vector&lt; std::map&lt;T, U&gt; &gt; </td></tr>
    <tr><td class="paramname">L</td><td>The output matrix for L. </td></tr>
    <tr><td class="paramname">U</td><td>The output matrix for U. </td></tr>
    <tr><td class="paramname">tag</td><td>An <a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html" title="A tag for incomplete LU factorization with threshold (ILUT) ">ilut_tag</a> in order to dispatch among several other preconditioners. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ilut_8hpp_source.html#l00193">193</a> of file <a class="el" href="ilut_8hpp_source.html">ilut.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa18d10f8a90e38bd9ff43c650fc670ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A1 , typename A2 , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T, A1 &gt;, A2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="amg_8cpp-example.html#a6">amg.cpp</a>, <a class="el" href="armadillo-with-viennacl_8cpp-example.html#a4">armadillo-with-viennacl.cpp</a>, <a class="el" href="blas2_8cpp-example.html#a8">blas2.cpp</a>, <a class="el" href="blas3_8cpp-example.html#a16">blas3.cpp</a>, <a class="el" href="custom-context_8cpp-example.html#a19">custom-context.cpp</a>, <a class="el" href="eigen-with-viennacl_8cpp-example.html#a4">eigen-with-viennacl.cpp</a>, <a class="el" href="iterative-custom_8cpp-example.html#a0">iterative-custom.cpp</a>, <a class="el" href="lanczos_8cpp-example.html#a12">lanczos.cpp</a>, <a class="el" href="matrix-range_8cpp-example.html#a8">matrix-range.cpp</a>, <a class="el" href="mtl4-with-viennacl_8cpp-example.html#a4">mtl4-with-viennacl.cpp</a>, <a class="el" href="nmf_8cpp-example.html#a10">nmf.cpp</a>, <a class="el" href="power-iter_8cpp-example.html#a8">power-iter.cpp</a>, <a class="el" href="spai_8cpp-example.html#a2">spai.cpp</a>, <a class="el" href="sparse_8cpp-example.html#a7">sparse.cpp</a>, and <a class="el" href="structured-matrices_8cpp-example.html#a9">structured-matrices.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00102">102</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a8191b8e2833645bf9a50cf0385bf84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KEY , typename DATA , typename COMPARE , typename AMAP , typename AVEC , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; KEY, DATA, COMPARE, AMAP &gt;, AVEC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00117">117</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9dbf28b182155a8036335d473bf5fa67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__mat__mat__prod.html">viennacl::op_mat_mat_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00153">153</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5214077835c189277d6eca907530c673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename LhsT , typename RhsT , typename OpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LhsT, const RhsT, OpT&gt;, <a class="el" href="structviennacl_1_1op__mat__mat__prod.html">viennacl::op_mat_mat_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT, const RhsT, OpT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00166">166</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf365675ae14ac0ed16d1f0b065be399"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsT , typename RhsT , typename OpT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LhsT, const RhsT, OpT&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__mat__mat__prod.html">viennacl::op_mat_mat_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT, const RhsT, OpT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00179">179</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02c5997b7fae26a1abfcd0d4d9fe630b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsT1 , typename RhsT1 , typename OpT1 , typename LhsT2 , typename RhsT2 , typename OpT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LhsT1, const RhsT1, OpT1&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LhsT2, const RhsT2, OpT2&gt;, <a class="el" href="structviennacl_1_1op__mat__mat__prod.html">viennacl::op_mat_mat_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT1, const RhsT1, OpT1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT2, const RhsT2, OpT2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00194">194</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7edeb4f4249dd1b38b4dbc33b0d2c30f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00209">209</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad411899e5dba6c80530c432eb9ff14a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00222">222</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb9bd2539edadb395c980ac9deeb97e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__range.html">viennacl::matrix_range</a>&lt; MatrixT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00235">235</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0e1429628379a8912c4e580d03c8c72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__slice.html">viennacl::matrix_slice</a>&lt; MatrixT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00248">248</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a960045016584f346ad635d81be790619"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename LhsT , typename RhsT , typename OpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LhsT, const RhsT, OpT&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT, const RhsT, OpT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00261">261</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d9a28b9f21ece1b0d1d25b3c5760678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename LhsT , typename RhsT , typename OpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LhsT, const RhsT, OpT&gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LhsT, const RhsT, OpT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00275">275</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae98b74abb405df7fa2184e27f0fd9b62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsT1 , typename RhsT1 , typename OpT1 , typename LhsT2 , typename RhsT2 , typename OpT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LhsT1, const RhsT1, OpT1&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LhsT2, const RhsT2, OpT2&gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LhsT1, const RhsT1, OpT1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LhsT2, const RhsT2, OpT2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00290">290</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3bba0146e669e012bb7c7380ce780a25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType , typename SCALARTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const SparseMatrixType, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a> &lt;SCALARTYPE&gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &gt;::type viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>sp_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00307">307</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2f953a28fd0726963616efc7c6502be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType , typename SCALARTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;SCALARTYPE&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;SCALARTYPE&gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &gt;::type viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; SCALARTYPE &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; SCALARTYPE &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00324">324</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a481c6668b16471330cbb8dc667ea777d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sparse matrix-matrix product with <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> objects. </p>

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00342">342</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77f5c8c3c3de21c082ccf1db28cf5189"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic matrix-vector product with user-provided sparse matrix type. </p>

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00355">355</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64b4f1d927a4df6416192cc8e69ed8aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vandermonde__matrix.html">viennacl::vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class. ">vandermonde_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vandermonde__matrix__operations_8hpp_source.html#l00048">48</a> of file <a class="el" href="vandermonde__matrix__operations_8hpp_source.html">vandermonde_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7df39ef1d7dacadae32160d335ffa44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1hankel__matrix.html">viennacl::hankel_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class. ">hankel_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hankel__matrix__operations_8hpp_source.html#l00049">49</a> of file <a class="el" href="hankel__matrix__operations_8hpp_source.html">hankel_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae45beece755553455daea6973a60043d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1toeplitz__matrix.html">viennacl::toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class. ">toeplitz_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="toeplitz__matrix__operations_8hpp_source.html#l00049">49</a> of file <a class="el" href="toeplitz__matrix__operations_8hpp_source.html">toeplitz_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8e5bca2a6154804234c62fb466d8a47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1circulant__matrix.html">viennacl::circulant_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class. ">circulant_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="circulant__matrix__operations_8hpp_source.html#l00049">49</a> of file <a class="el" href="circulant__matrix__operations_8hpp_source.html">circulant_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4ecc092e443847d1968d9d2cef07eda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType , class ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value&gt;::type viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-vector multiplication involving a sparse matrix type. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sparse__matrix__operations_8hpp_source.html#l00092">92</a> of file <a class="el" href="sparse__matrix__operations_8hpp_source.html">sparse_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6448c1d1c0cdb1010a146c0238c8d20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType , class ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value&gt;::type viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>sp_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-matrix multiplication first matrix being sparse. </p>
<p>Implementation of the convenience expression result = prod(sp_mat, d_mat);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp_mat</td><td>The sparse matrix </td></tr>
    <tr><td class="paramname">d_mat</td><td>The dense matrix </td></tr>
    <tr><td class="paramname">result</td><td>The result matrix (dense) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sparse__matrix__operations_8hpp_source.html#l00135">135</a> of file <a class="el" href="sparse__matrix__operations_8hpp_source.html">sparse_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07ddf85f2f61d198160ffd13bf7aebac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType , class ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value&gt;::type viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>sp_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-matrix multiplication first matrix being sparse, and the second transposed. </p>
<p>Implementation of the convenience expression result = prod(sp_mat, d_mat);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp_mat</td><td>The sparse matrix </td></tr>
    <tr><td class="paramname">d_mat</td><td>The dense matrix (transposed) </td></tr>
    <tr><td class="paramname">result</td><td>The result matrix (dense) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sparse__matrix__operations_8hpp_source.html#l00175">175</a> of file <a class="el" href="sparse__matrix__operations_8hpp_source.html">sparse_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac371515668e3ef88cd49a4adba597e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out sparse_matrix-sparse_matrix multiplication for CSR matrices. </p>
<p>Implementation of the convenience expression C = prod(A, B); Based on computing C(i, :) = A(i, :) * B via merging the respective rows of B</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Left factor </td></tr>
    <tr><td class="paramname">B</td><td>Right factor </td></tr>
    <tr><td class="paramname">C</td><td>Result matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sparse__matrix__operations_8hpp_source.html#l00219">219</a> of file <a class="el" href="sparse__matrix__operations_8hpp_source.html">sparse_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee54e81505baf1ad693923f931cf977f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, B); </p>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00519">519</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4cb0e6f13312518b9feeb79641d68db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), B); </p>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00560">560</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a259294962bcc11782615f4860324d223"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, trans(B)); </p>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00603">603</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abab441eef21bb94768f6a8113ff2fdee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), trans(B)); </p>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00643">643</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aafc6db8d806f67c24f93eaaded84b853"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-vector multiplication. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00438">438</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3e5d39428cebc0a54a6ba2c10a3f73c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carries out matrix-vector multiplication with a transposed matrix. </p>
<p>Implementation of the convenience expression result = trans(mat) * vec;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_trans</td><td>The transposed matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00479">479</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7a946e478e53f6464d1dedeb3a46c89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType , class SCALARTYPE , unsigned int ALIGNMENT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &gt;::type viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe64190e92ee58ad753947142204d0f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::qr_method_nsm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method_8hpp_source.html#l00796">796</a> of file <a class="el" href="qr-method_8hpp_source.html">qr-method.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51cbe06645207f9b3054e8725269cc71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::qr_method_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="qr_method_8cpp-example.html#a5">qr_method.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="qr-method_8hpp_source.html#l00806">806</a> of file <a class="el" href="qr-method_8hpp_source.html">qr-method.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec312fb569dcc41351adb8aeacbea571"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::qr_method_sym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method_8hpp_source.html#l00817">817</a> of file <a class="el" href="qr-method_8hpp_source.html">qr-method.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a824a7dd4e1dd0dd3a7698b1f1bffc431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::radix2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>batch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>sign</em> = <code><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a>&#160;</td>
          <td class="paramname"><em>data_order</em> = <code><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Radix-2 1D algorithm for computing Fourier transformation. </p>
<p>Works only on power-of-two sizes of data. Serial implementation has o(n * lg n) complexity. This is a Cooley-Tukey algorithm </p>

<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00162">162</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61dd345e5bec9894f6272e04b1f08602"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::radix2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>batch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>sign</em> = <code><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a>&#160;</td>
          <td class="paramname"><em>data_order</em> = <code><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Radix-2 2D algorithm for computing Fourier transformation. </p>
<p>Works only on power-of-two sizes of data. Serial implementation has o(n * lg n) complexity. This is a Cooley-Tukey algorithm </p>

<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00198">198</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab46594affa4b4f500660ea741cc1582a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::real_to_complex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create complex vector from real vector (even elements(2*k) = real part, odd elements(2*k+1) = imaginary part) </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fft_8cpp-example.html#a10">fft.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00390">390</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76fc8bf8f5a20c576b7ddbad32d3e56d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::recoverQ </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>betas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="qr_8cpp-example.html#a6">qr.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="qr_8hpp_source.html#l00564">564</a> of file <a class="el" href="qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81e762eac66a1c45136f2beb12f8eea6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>bits_datasize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>batch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::DATA_ORDER</a>&#160;</td>
          <td class="paramname"><em>data_order</em> = <code><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html#aac2583f16e35875f2696e9220bd262f2afffdaee3461226037812d7c99faf6e1b">viennacl::linalg::host_based::detail::fft::FFT_DATA_ORDER::ROW_MAJOR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00125">125</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65decb368dc002ff34334fa0918add2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse vector to oposite order and save it in input vector. </p>

<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00452">452</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c3e422a3d27609f0c036badc34e6479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__row__sum.html">viennacl::op_row_sum</a> &gt; viennacl::linalg::row_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User interface function for computing the sum of all elements of each row of a matrix. </p>

<p>Definition at line <a class="el" href="sum_8hpp_source.html#l00077">77</a> of file <a class="el" href="sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34f57091ab11e083e3663039a3f40b32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt;const LHS, const RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__row__sum.html">viennacl::op_row_sum</a>&gt; viennacl::linalg::row_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User interface function for computing the sum of all elements of each row of a matrix specified by a matrix operation. </p>
<p>Typical use case: vector&lt;double&gt; my_sums = <a class="el" href="namespaceviennacl_1_1linalg.html#a9c3e422a3d27609f0c036badc34e6479" title="User interface function for computing the sum of all elements of each row of a matrix. ">viennacl::linalg::row_sum</a>(A + B); </p>

<p>Definition at line <a class="el" href="sum_8hpp_source.html#l00092">92</a> of file <a class="el" href="sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a989dc9f1224caf70090b16ba7e0caffb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::row_sum_impl </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00679">679</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b132454748512537e1db081c5dcc11d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::scaled_rank_1_update </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>len_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update. </p>
<p>Implementation of the convenience expression result += alpha * outer_prod(vec1, vec2);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat1</td><td>The matrix to be updated </td></tr>
    <tr><td class="paramname">alpha</td><td>The scaling factor (either a viennacl::scalar&lt;&gt;, float, or double) </td></tr>
    <tr><td class="paramname">len_alpha</td><td>Length of the buffer for an eventual final reduction step (currently always '1') </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>Use 1/alpha instead of alpha </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>Use -alpha instead of alpha </td></tr>
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00859">859</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a727542f4624926e74ff52ea5c75d546f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mixed_precision_cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the conjugate gradient solver without preconditioner. </p>
<p>Following the algorithm in the book by Y. Saad "Iterative Methods for sparse linear systems"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Solver configuration tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result vector </dd></dl>

<p>Definition at line <a class="el" href="mixed__precision__cg_8hpp_source.html#l00096">96</a> of file <a class="el" href="mixed__precision__cg_8hpp_source.html">mixed_precision_cg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5579a603f93ad9fb66d8ebc358d7d5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mixed_precision_cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mixed__precision__cg_8hpp_source.html#l00190">190</a> of file <a class="el" href="mixed__precision__cg_8hpp_source.html">mixed_precision_cg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1c5dfe2ca91ca582638c39016c0a208e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience functions for C = solve(A, B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of load vectors </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00301">301</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8e8ed654f145cb91cd73e759603683c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience functions for C = solve(A, B^T, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">proxy</td><td>The transposed load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00318">318</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a61b45de1633dab2c70d4e0f7d6b58e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of load vectors </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00335">335</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fad8cb9d4b354019644518915c7f54f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT , typename PreconditionerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerT const &amp;&#160;</td>
          <td class="paramname"><em>precond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the preconditioned conjugate gradient solver, generic implementation for non-ViennaCL types. </p>
<p>Following Algorithm 9.1 in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Solver configuration tag </td></tr>
    <tr><td class="paramname">precond</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result vector </dd></dl>

<p>Definition at line <a class="el" href="cg_8hpp_source.html#l00339">339</a> of file <a class="el" href="cg_8hpp_source.html">cg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52e8d1aec0a1fac16ec0a9065b1434d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename NumericT , typename PreconditionerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerT const &amp;&#160;</td>
          <td class="paramname"><em>precond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload for calling the CG solver using types from the C++ STL. </p>
<p>A std::vector&lt;std::map&lt;T, U&gt; &gt; matrix is convenient for e.g. finite element assembly. It is not the fastest option for setting up a system, but often it is fast enough - particularly for just trying things out. </p>

<p>Definition at line <a class="el" href="cg_8hpp_source.html#l00350">350</a> of file <a class="el" href="cg_8hpp_source.html">cg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ff7d3cc1ecf2686dcb0795d188ecdf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The transposed matrix of load vectors, where the solution is directly written to </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00352">352</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0679942882efd21c540fac8e78a6d56a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for the unpreconditioned CG method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side vector (load vector) </td></tr>
    <tr><td class="paramname">tag</td><td>A BiCGStab tag providing relative tolerances, etc. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cg_8hpp_source.html#l00372">372</a> of file <a class="el" href="cg_8hpp_source.html">cg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6d7887a8badaa283e9522d63a611a56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for result = solve(mat, vec, upper_tag()); for an upper triangular solve. </p>
<p>Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The system matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00492">492</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e9b329b64ac782e6a5687ad2fc47a2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT , typename PreconditionerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerT const &amp;&#160;</td>
          <td class="paramname"><em>precond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="amg_8cpp-example.html#a3">amg.cpp</a>, <a class="el" href="blas2_8cpp-example.html#a11">blas2.cpp</a>, <a class="el" href="iterative-armadillo_8cpp-example.html#a5">iterative-armadillo.cpp</a>, <a class="el" href="iterative-eigen_8cpp-example.html#a4">iterative-eigen.cpp</a>, <a class="el" href="iterative-mtl4_8cpp-example.html#a2">iterative-mtl4.cpp</a>, <a class="el" href="iterative-ublas_8cpp-example.html#a9">iterative-ublas.cpp</a>, <a class="el" href="iterative_8cpp-example.html#a15">iterative.cpp</a>, <a class="el" href="matrix-free_8cpp-example.html#a10">matrix-free.cpp</a>, <a class="el" href="multithreaded_cg_8cpp-example.html#a7">multithreaded_cg.cpp</a>, and <a class="el" href="spai_8cpp-example.html#a1">spai.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="bicgstab_8hpp_source.html#l00496">496</a> of file <a class="el" href="bicgstab_8hpp_source.html">bicgstab.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acec0a2656d4cf6648f999bb2a99a332a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename NumericT , typename PreconditionerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerT const &amp;&#160;</td>
          <td class="paramname"><em>precond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload for calling the preconditioned BiCGStab solver using types from the C++ STL. </p>
<p>A std::vector&lt;std::map&lt;T, U&gt; &gt; matrix is convenient for e.g. finite element assembly. It is not the fastest option for setting up a system, but often it is fast enough - particularly for just trying things out. </p>

<p>Definition at line <a class="el" href="bicgstab_8hpp_source.html#l00508">508</a> of file <a class="el" href="bicgstab_8hpp_source.html">bicgstab.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac76b5c350f25569a8c503ab102289dfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a> const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for result = solve(mat, vec, upper_tag()); for an upper triangular solve with unit diagonal. </p>
<p>Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The system matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00511">511</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcecbbb0d1af0b546c1464c0b8445b61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for the unpreconditioned BiCGStab method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side vector (load vector) </td></tr>
    <tr><td class="paramname">tag</td><td>A BiCGStab tag providing relative tolerances, etc. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bicgstab_8hpp_source.html#l00530">530</a> of file <a class="el" href="bicgstab_8hpp_source.html">bicgstab.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b295af009d30ee10ba558b5cae9fcfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a> const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for result = solve(mat, vec, upper_tag()); for a lower triangular solve. </p>
<p>Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The system matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00530">530</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87b19fc27005f6e13a9ee981965a5e97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for result = solve(mat, vec, upper_tag()); for a lower triangular solve with unit diagonal. </p>
<p>Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The system matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00549">549</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0c2e482814cd46a9dc139af45d5977e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SolverTagT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SolverTagT const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#adf06f61be9418e5817eed66004f9dd2b" title="Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notat...">inplace_solve()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector, where the solution is directly written to </td></tr>
    <tr><td class="paramname">tag</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="direct__solve_8hpp_source.html#l00566">566</a> of file <a class="el" href="direct__solve_8hpp_source.html">direct_solve.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6c0a087d090d74573763d9dd48c9074"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT , typename PreconditionerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmres_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerT const &amp;&#160;</td>
          <td class="paramname"><em>precond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gmres_8hpp_source.html#l00636">636</a> of file <a class="el" href="gmres_8hpp_source.html">gmres.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70c979c1bdf04f724d1b32c7789b563d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename NumericT , typename PreconditionerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmres_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerT const &amp;&#160;</td>
          <td class="paramname"><em>precond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload for calling the preconditioned BiCGStab solver using types from the C++ STL. </p>
<p>A std::vector&lt;std::map&lt;T, U&gt; &gt; matrix is convenient for e.g. finite element assembly. It is not the fastest option for setting up a system, but often it is fast enough - particularly for just trying things out. </p>

<p>Definition at line <a class="el" href="gmres_8hpp_source.html#l00647">647</a> of file <a class="el" href="gmres_8hpp_source.html">gmres.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac34f2a4be7c82ecf4fd10e05ecc24273"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmres_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for the unpreconditioned GMRES method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side vector (load vector) </td></tr>
    <tr><td class="paramname">tag</td><td>A BiCGStab tag providing relative tolerances, etc. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gmres_8hpp_source.html#l00670">670</a> of file <a class="el" href="gmres_8hpp_source.html">gmres.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4117795095db49147ba7305d3e0a1af5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__sum.html">viennacl::op_sum</a> &gt; viennacl::linalg::sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User interface function for computing the sum of all elements of a vector. </p>

<p>Definition at line <a class="el" href="sum_8hpp_source.html#l00045">45</a> of file <a class="el" href="sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6cf85f2a992e09305f5f8c0db4bc6bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const LHS, const RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__sum.html">viennacl::op_sum</a>&gt; viennacl::linalg::sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User interface function for computing the sum of all elements of a vector specified by a vector operation. </p>
<p>Typical use case: double my_sum = <a class="el" href="namespaceviennacl_1_1linalg.html#a4117795095db49147ba7305d3e0a1af5" title="User interface function for computing the sum of all elements of a vector. ">viennacl::linalg::sum</a>(x + y); </p>

<p>Definition at line <a class="el" href="sum_8hpp_source.html#l00060">60</a> of file <a class="el" href="sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a45afae73aac6a14d0b5c46053ff3b08b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::sum_cpu </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of a vector with final reduction on the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01102">1102</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fd49659a7210abda3960382288a7160"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::sum_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01132">1132</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98ec50ed65cf65aac0a0d01706370f39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::sum_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4727940e3c347e78e154a9df15a8d74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::sum_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4362cfc81d9d44c6cb84eb4c809babd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::sum_impl </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of a vector with final reduction on the device (GPU, etc.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01059">1059</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2257c033c8155745f3b0fa5de168c4dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::sum_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector expression </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01089">1089</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7dd4119fc5dfef5c067af3b46bd86191"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, row_major, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, row_major, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>QL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, row_major, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>QR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the singular value decomposition of a matrix A. Experimental in 1.3.x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The input matrix. Will be overwritten with a diagonal matrix containing the singular values on return </td></tr>
    <tr><td class="paramname">QL</td><td>The left orthogonal matrix </td></tr>
    <tr><td class="paramname">QR</td><td>The right orthogonal matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="svd_8hpp_source.html#l00492">492</a> of file <a class="el" href="svd_8hpp_source.html">svd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a376a98ceee0ab85880a4b5a9c343d802"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::value &gt;::type viennacl::linalg::swap </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of two scalars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="scalar__operations_8hpp_source.html#l00213">213</a> of file <a class="el" href="scalar__operations_8hpp_source.html">scalar_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a528690f82b77f9fc12ee90038ee404ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::tql1 </td>
          <td>(</td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tql2_8hpp_source.html#l00041">41</a> of file <a class="el" href="tql2_8hpp_source.html">tql2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3fe3eb20d4dcda794259fd6a6d30afb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE , typename VectorType , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::tql2 </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; SCALARTYPE, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tql2_8cpp-example.html#a4">tql2.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="tql2_8hpp_source.html#l00131">131</a> of file <a class="el" href="tql2_8hpp_source.html">tql2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad88c948ebe30524e225cb523fe6f6cd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SizeT , typename DistanceT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::trans </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, SizeT, DistanceT &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, SizeT, DistanceT &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>temp_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l00083">83</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae829451e793471ca5e8751cf89fec950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inplace_transpose matrix. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fft_8cpp-example.html#a8">fft.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00329">329</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c67f0718cac71823eed6758492defda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose matrix. </p>

<p>Definition at line <a class="el" href="fft__operations_8hpp_source.html#l00359">359</a> of file <a class="el" href="fft__operations_8hpp_source.html">fft_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4ac2cb73f99d27607fdce761323d892"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::vector_assign </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>up_to_internal_size</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a constant value to a vector (-range/-slice) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector to which the value should be assigned </td></tr>
    <tr><td class="paramname">alpha</td><td>The value to be assigned </td></tr>
    <tr><td class="paramname">up_to_internal_size</td><td>Whether 'alpha' should be written to padded memory as well. This is used for setting all entries to zero, including padded memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00187">187</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad345204a9420f9dd57bbad0b16fc40d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::vector_swap </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of two vectors, data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector (or -range, or -slice) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l00218">218</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a8477d884683dafc7e6ca04f2e02a1d1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string viennacl::linalg::SVD_FINAL_ITER_UPDATE_KERNEL = &quot;final_iter_update&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method-common_8hpp_source.html#l00053">53</a> of file <a class="el" href="qr-method-common_8hpp_source.html">qr-method-common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15bedacb51ec9b425baf52ee7f68bdba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string viennacl::linalg::SVD_GIVENS_PREV_KERNEL = &quot;givens_prev&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method-common_8hpp_source.html#l00052">52</a> of file <a class="el" href="qr-method-common_8hpp_source.html">qr-method-common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e62fa452895c889f7bad9700300994d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string viennacl::linalg::SVD_HOUSEHOLDER_UPDATE_A_LEFT_KERNEL = &quot;house_update_A_left&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method-common_8hpp_source.html#l00055">55</a> of file <a class="el" href="qr-method-common_8hpp_source.html">qr-method-common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace85ea4095e9e7404b6f77b767ac000f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string viennacl::linalg::SVD_HOUSEHOLDER_UPDATE_A_RIGHT_KERNEL = &quot;house_update_A_right&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method-common_8hpp_source.html#l00056">56</a> of file <a class="el" href="qr-method-common_8hpp_source.html">qr-method-common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04a5ce1f7230502c9d1ee87dcc24c8b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string viennacl::linalg::SVD_HOUSEHOLDER_UPDATE_QL_KERNEL = &quot;house_update_QL&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method-common_8hpp_source.html#l00057">57</a> of file <a class="el" href="qr-method-common_8hpp_source.html">qr-method-common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b5cb81b46208cae772a5e0813f02517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string viennacl::linalg::SVD_HOUSEHOLDER_UPDATE_QR_KERNEL = &quot;house_update_QR&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method-common_8hpp_source.html#l00049">49</a> of file <a class="el" href="qr-method-common_8hpp_source.html">qr-method-common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05717ddd22894376e780b075d59616ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string viennacl::linalg::SVD_INVERSE_SIGNS_KERNEL = &quot;inverse_signs&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method-common_8hpp_source.html#l00051">51</a> of file <a class="el" href="qr-method-common_8hpp_source.html">qr-method-common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a349e6e78f95ef631a5f2736158766739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string viennacl::linalg::SVD_MATRIX_TRANSPOSE_KERNEL = &quot;transpose_inplace&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method-common_8hpp_source.html#l00050">50</a> of file <a class="el" href="qr-method-common_8hpp_source.html">qr-method-common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a439370108ddfa59c2fcb4136b13c8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string viennacl::linalg::SVD_UPDATE_QR_COLUMN_KERNEL = &quot;update_qr_column&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="qr-method-common_8hpp_source.html#l00054">54</a> of file <a class="el" href="qr-method-common_8hpp_source.html">qr-method-common.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a></li><li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a></li>
    <li class="footer">Generated on Wed Jan 20 2016 22:32:45 for ViennaCL - The Vienna Computing Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
