<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::linalg::detail::spai Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Free open-source GPU-accelerated linear algebra and solver library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceviennacl_1_1linalg_1_1detail_1_1spai.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl::linalg::detail::spai Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation namespace for sparse approximate inverse preconditioner.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents contigious matrices on GPU.  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a contiguous vector on the GPU to represent a concatentation of small vectors.  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1detail_1_1spai_1_1_compare_second.html">CompareSecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor for comparing std::pair&lt;&gt; based on the second member.  <a href="structviennacl_1_1linalg_1_1detail_1_1spai_1_1_compare_second.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html">fspai_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for FSPAI. Experimental.  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for SPAI.  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1sparse__vector.html">sparse_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sparse vector based on std::map&lt;unsigned int, NumericT&gt;  <a href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1sparse__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af1ff03eb8bd6bd2f78f4738731394f7d"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:af1ff03eb8bd6bd2f78f4738731394f7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af1ff03eb8bd6bd2f78f4738731394f7d">sym_sparse_matrix_to_stl</a> (MatrixT const &amp;A, std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;STL_A)</td></tr>
<tr class="separator:af1ff03eb8bd6bd2f78f4738731394f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f2c2a17a35ffa9682589bc3bd692dc"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:ae5f2c2a17a35ffa9682589bc3bd692dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae5f2c2a17a35ffa9682589bc3bd692dc">generateJ</a> (MatrixT const &amp;A, std::vector&lt; std::vector&lt; <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> &gt; &gt; &amp;J)</td></tr>
<tr class="separator:ae5f2c2a17a35ffa9682589bc3bd692dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd198c046af39cfe38f1aad62c0580ae"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:acd198c046af39cfe38f1aad62c0580ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acd198c046af39cfe38f1aad62c0580ae">fill_blocks</a> (std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;A, std::vector&lt; MatrixT &gt; &amp;blocks, std::vector&lt; std::vector&lt; <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> &gt; &gt; const &amp;J, std::vector&lt; VectorT &gt; &amp;Y)</td></tr>
<tr class="separator:acd198c046af39cfe38f1aad62c0580ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aaf276d63d5442f2f95d060912c4ab"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:ac3aaf276d63d5442f2f95d060912c4ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ac3aaf276d63d5442f2f95d060912c4ab">cholesky_decompose</a> (MatrixT &amp;A)</td></tr>
<tr class="separator:ac3aaf276d63d5442f2f95d060912c4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097e316b51cf3854abec362e6a6d1d47"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:a097e316b51cf3854abec362e6a6d1d47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a097e316b51cf3854abec362e6a6d1d47">cholesky_solve</a> (MatrixT const &amp;L, VectorT &amp;b)</td></tr>
<tr class="separator:a097e316b51cf3854abec362e6a6d1d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac5736cf32d6afbea570aa683dbe115"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:aeac5736cf32d6afbea570aa683dbe115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aeac5736cf32d6afbea570aa683dbe115">computeL</a> (MatrixT const &amp;A, MatrixT &amp;L, MatrixT &amp;L_trans, std::vector&lt; VectorT &gt; &amp;Y, std::vector&lt; std::vector&lt; <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> &gt; &gt; &amp;J)</td></tr>
<tr class="separator:aeac5736cf32d6afbea570aa683dbe115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b282bb53b72b43e7f76d9aeb3df64b"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:a23b282bb53b72b43e7f76d9aeb3df64b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a23b282bb53b72b43e7f76d9aeb3df64b">computeFSPAI</a> (MatrixT const &amp;A, MatrixT const &amp;PatternA, MatrixT &amp;L, MatrixT &amp;L_trans, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1fspai__tag.html">fspai_tag</a>)</td></tr>
<tr class="separator:a23b282bb53b72b43e7f76d9aeb3df64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa237a50ec1e8dd5e279a0fb02ff0bf8f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename InputIteratorT &gt; </td></tr>
<tr class="memitem:aa237a50ec1e8dd5e279a0fb02ff0bf8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa237a50ec1e8dd5e279a0fb02ff0bf8f">Print</a> (std::ostream &amp;ostr, InputIteratorT it_begin, InputIteratorT it_end)</td></tr>
<tr class="separator:aa237a50ec1e8dd5e279a0fb02ff0bf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65295176395fdf1c526d3880f3d76b53"><td class="memTemplParams" colspan="2">template&lt;typename VectorT , typename MatrixT &gt; </td></tr>
<tr class="memitem:a65295176395fdf1c526d3880f3d76b53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a65295176395fdf1c526d3880f3d76b53">write_to_block</a> (VectorT &amp;con_A_I_J, unsigned int start_ind, std::vector&lt; unsigned int &gt; const &amp;I, std::vector&lt; unsigned int &gt; const &amp;J, MatrixT &amp;m)</td></tr>
<tr class="separator:a65295176395fdf1c526d3880f3d76b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7434114c0e1f546e32b4bc2a81a35ad1"><td class="memTemplParams" colspan="2">template&lt;typename VectorT &gt; </td></tr>
<tr class="memitem:a7434114c0e1f546e32b4bc2a81a35ad1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a7434114c0e1f546e32b4bc2a81a35ad1">print_continious_matrix</a> (VectorT &amp;con_A_I_J, std::vector&lt; cl_uint &gt; &amp;blocks_ind, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_J)</td></tr>
<tr class="separator:a7434114c0e1f546e32b4bc2a81a35ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbff207e6f84bc89822c0eab0aea0fe7"><td class="memTemplParams" colspan="2">template&lt;typename VectorT &gt; </td></tr>
<tr class="memitem:abbff207e6f84bc89822c0eab0aea0fe7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#abbff207e6f84bc89822c0eab0aea0fe7">print_continious_vector</a> (VectorT &amp;con_v, std::vector&lt; cl_uint &gt; &amp;block_ind, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_J)</td></tr>
<tr class="separator:abbff207e6f84bc89822c0eab0aea0fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a76ae3dcfedb876ec9f2db3155b81a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a9a76ae3dcfedb876ec9f2db3155b81a7">compute_blocks_size</a> (std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_J, unsigned int &amp;sz, std::vector&lt; cl_uint &gt; &amp;blocks_ind, std::vector&lt; cl_uint &gt; &amp;matrix_dims)</td></tr>
<tr class="memdesc:a9a76ae3dcfedb876ec9f2db3155b81a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">**************************************** BLOCK FUNCTIONS ************************************//  <a href="#a9a76ae3dcfedb876ec9f2db3155b81a7">More...</a><br/></td></tr>
<tr class="separator:a9a76ae3dcfedb876ec9f2db3155b81a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b43cbe43e0371cea55b325b410c1b4"><td class="memTemplParams" colspan="2">template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:af7b43cbe43e0371cea55b325b410c1b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af7b43cbe43e0371cea55b325b410c1b4">get_size</a> (std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;inds, SizeT &amp;size)</td></tr>
<tr class="memdesc:af7b43cbe43e0371cea55b325b410c1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes size of particular container of index set.  <a href="#af7b43cbe43e0371cea55b325b410c1b4">More...</a><br/></td></tr>
<tr class="separator:af7b43cbe43e0371cea55b325b410c1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47df1186969f6872fe0dcaf83d4982b"><td class="memTemplParams" colspan="2">template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:aa47df1186969f6872fe0dcaf83d4982b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa47df1186969f6872fe0dcaf83d4982b">init_start_inds</a> (std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;inds, std::vector&lt; cl_uint &gt; &amp;start_inds)</td></tr>
<tr class="memdesc:aa47df1186969f6872fe0dcaf83d4982b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes start indices of particular index set.  <a href="#aa47df1186969f6872fe0dcaf83d4982b">More...</a><br/></td></tr>
<tr class="separator:aa47df1186969f6872fe0dcaf83d4982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eeb3f2f51183bed7e6d0a1aeefc87bc"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a7eeb3f2f51183bed7e6d0a1aeefc87bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a7eeb3f2f51183bed7e6d0a1aeefc87bc">dot_prod</a> (MatrixT const &amp;A, unsigned int beg_ind, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;res)</td></tr>
<tr class="memdesc:a7eeb3f2f51183bed7e6d0a1aeefc87bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot prod of particular column of martix A with it's self starting at a certain index beg_ind.  <a href="#a7eeb3f2f51183bed7e6d0a1aeefc87bc">More...</a><br/></td></tr>
<tr class="separator:a7eeb3f2f51183bed7e6d0a1aeefc87bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d21631da144b8d5c5de25afcbe53e7"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:ae6d21631da144b8d5c5de25afcbe53e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae6d21631da144b8d5c5de25afcbe53e7">custom_inner_prod</a> (MatrixT const &amp;A, VectorT const &amp;v, unsigned int col_ind, unsigned int start_ind, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;res)</td></tr>
<tr class="memdesc:ae6d21631da144b8d5c5de25afcbe53e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot prod of particular matrix column with arbitrary vector: A(:, col_ind)  <a href="#ae6d21631da144b8d5c5de25afcbe53e7">More...</a><br/></td></tr>
<tr class="separator:ae6d21631da144b8d5c5de25afcbe53e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9928b400d93d677b626c5ea9e51819"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:a9c9928b400d93d677b626c5ea9e51819"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a9c9928b400d93d677b626c5ea9e51819">copy_vector</a> (MatrixT const &amp;A, VectorT &amp;v, unsigned int beg_ind)</td></tr>
<tr class="memdesc:a9c9928b400d93d677b626c5ea9e51819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying part of matrix column.  <a href="#a9c9928b400d93d677b626c5ea9e51819">More...</a><br/></td></tr>
<tr class="separator:a9c9928b400d93d677b626c5ea9e51819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b989396d25d3ec653ea0aa1e620f55"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:a34b989396d25d3ec653ea0aa1e620f55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a34b989396d25d3ec653ea0aa1e620f55">householder_vector</a> (MatrixT const &amp;A, unsigned int j, VectorT &amp;v, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;b)</td></tr>
<tr class="memdesc:a34b989396d25d3ec653ea0aa1e620f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of Householder vector, householder reflection c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.210.  <a href="#a34b989396d25d3ec653ea0aa1e620f55">More...</a><br/></td></tr>
<tr class="separator:a34b989396d25d3ec653ea0aa1e620f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cfda20cf63c245a5c22034875743da"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:a08cfda20cf63c245a5c22034875743da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a08cfda20cf63c245a5c22034875743da">apply_householder_reflection</a> (MatrixT &amp;A, unsigned int iter_cnt, VectorT &amp;v, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> b)</td></tr>
<tr class="memdesc:a08cfda20cf63c245a5c22034875743da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace application of Householder vector to a matrix A.  <a href="#a08cfda20cf63c245a5c22034875743da">More...</a><br/></td></tr>
<tr class="separator:a08cfda20cf63c245a5c22034875743da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaaf643f5b021ac04dd7690904e59f9"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:abcaaf643f5b021ac04dd7690904e59f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#abcaaf643f5b021ac04dd7690904e59f9">store_householder_vector</a> (MatrixT &amp;A, unsigned int ind, VectorT &amp;v)</td></tr>
<tr class="memdesc:abcaaf643f5b021ac04dd7690904e59f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of vector v in column(A, ind), starting from ind-1 index of a column.  <a href="#abcaaf643f5b021ac04dd7690904e59f9">More...</a><br/></td></tr>
<tr class="separator:abcaaf643f5b021ac04dd7690904e59f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e707b637111b93ec04a6149aa72eac4"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:a6e707b637111b93ec04a6149aa72eac4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6e707b637111b93ec04a6149aa72eac4">single_qr</a> (MatrixT &amp;R, VectorT &amp;b_v)</td></tr>
<tr class="memdesc:a6e707b637111b93ec04a6149aa72eac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace QR factorization via Householder reflections c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.224.  <a href="#a6e707b637111b93ec04a6149aa72eac4">More...</a><br/></td></tr>
<tr class="separator:a6e707b637111b93ec04a6149aa72eac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12bfcc7a652ea6bc9150c302dae81a7"><td class="memTemplParams" colspan="2">template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:af12bfcc7a652ea6bc9150c302dae81a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af12bfcc7a652ea6bc9150c302dae81a7">get_max_block_size</a> (std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;inds, SizeT &amp;max_size)</td></tr>
<tr class="memdesc:af12bfcc7a652ea6bc9150c302dae81a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting max size of rows/columns from container of index set.  <a href="#af12bfcc7a652ea6bc9150c302dae81a7">More...</a><br/></td></tr>
<tr class="separator:af12bfcc7a652ea6bc9150c302dae81a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f734abea08b6732fb5a6d3d50f36319"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:a0f734abea08b6732fb5a6d3d50f36319"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a0f734abea08b6732fb5a6d3d50f36319">custom_dot_prod</a> (MatrixT const &amp;A, VectorT const &amp;v, unsigned int ind, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;res)</td></tr>
<tr class="memdesc:a0f734abea08b6732fb5a6d3d50f36319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot_prod(column(A, ind), v) starting from index ind+1.  <a href="#a0f734abea08b6732fb5a6d3d50f36319">More...</a><br/></td></tr>
<tr class="separator:a0f734abea08b6732fb5a6d3d50f36319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b64ba7bb53a1526cc852daf0d4d53e"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:ab3b64ba7bb53a1526cc852daf0d4d53e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab3b64ba7bb53a1526cc852daf0d4d53e">apply_q_trans_vec</a> (MatrixT const &amp;R, VectorT const &amp;b_v, VectorT &amp;y)</td></tr>
<tr class="memdesc:ab3b64ba7bb53a1526cc852daf0d4d53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovery Q from matrix R and vector of betas b_v.  <a href="#ab3b64ba7bb53a1526cc852daf0d4d53e">More...</a><br/></td></tr>
<tr class="separator:ab3b64ba7bb53a1526cc852daf0d4d53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcb9bff13f114739f5f7d70d5b38223"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:a1bcb9bff13f114739f5f7d70d5b38223"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a1bcb9bff13f114739f5f7d70d5b38223">apply_q_trans_mat</a> (MatrixT const &amp;R, VectorT const &amp;b_v, MatrixT &amp;A)</td></tr>
<tr class="memdesc:a1bcb9bff13f114739f5f7d70d5b38223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of Q'*A, where Q is in implicit for lower part of R and vector of betas - b_v.  <a href="#a1bcb9bff13f114739f5f7d70d5b38223">More...</a><br/></td></tr>
<tr class="separator:a1bcb9bff13f114739f5f7d70d5b38223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50a771c3604ad3913905871d54176f4"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aa50a771c3604ad3913905871d54176f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa50a771c3604ad3913905871d54176f4">block_qr</a> (std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update, <a class="el" href="classviennacl_1_1context.html">viennacl::context</a> ctx)</td></tr>
<tr class="memdesc:aa50a771c3604ad3913905871d54176f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace QR factorization via Householder reflections c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.224 performed on GPU.  <a href="#aa50a771c3604ad3913905871d54176f4">More...</a><br/></td></tr>
<tr class="separator:aa50a771c3604ad3913905871d54176f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d03e25caf5c1957fab6334c0d91c31"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:a75d03e25caf5c1957fab6334c0d91c31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a75d03e25caf5c1957fab6334c0d91c31">make_rotation_matrix</a> (MatrixT &amp;mat, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> new_size, <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a> off_diagonal_distance=4)</td></tr>
<tr class="separator:a75d03e25caf5c1957fab6334c0d91c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6543d2795df36b19080b431aca258b1"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:ad6543d2795df36b19080b431aca258b1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ad6543d2795df36b19080b431aca258b1">determinant</a> (boost::numeric::ublas::matrix_expression&lt; MatrixT &gt; const &amp;mat_r)</td></tr>
<tr class="separator:ad6543d2795df36b19080b431aca258b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed76d80fb1f213aa6ac3df4756a173a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:a4ed76d80fb1f213aa6ac3df4756a173a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a4ed76d80fb1f213aa6ac3df4756a173a">composeNewR</a> (MatrixT const &amp;A, MatrixT const &amp;R_n, MatrixT &amp;R)</td></tr>
<tr class="memdesc:a4ed76d80fb1f213aa6ac3df4756a173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of new matrix R, that is going to be used in Least Square problem solving.  <a href="#a4ed76d80fb1f213aa6ac3df4756a173a">More...</a><br/></td></tr>
<tr class="separator:a4ed76d80fb1f213aa6ac3df4756a173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f2cf7cafff244de64e0f5e54507963"><td class="memTemplParams" colspan="2">template&lt;typename VectorT &gt; </td></tr>
<tr class="memitem:a04f2cf7cafff244de64e0f5e54507963"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a04f2cf7cafff244de64e0f5e54507963">composeNewVector</a> (VectorT const &amp;v_n, VectorT &amp;v)</td></tr>
<tr class="memdesc:a04f2cf7cafff244de64e0f5e54507963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of new vector of coefficients beta from QR factorizations(necessary for Q recovery)  <a href="#a04f2cf7cafff244de64e0f5e54507963">More...</a><br/></td></tr>
<tr class="separator:a04f2cf7cafff244de64e0f5e54507963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76346f2d37c99cdda3737ad76942bdb2"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:a76346f2d37c99cdda3737ad76942bdb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a76346f2d37c99cdda3737ad76942bdb2">sparse_norm_2</a> (SparseVectorT const &amp;v, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;norm)</td></tr>
<tr class="memdesc:a76346f2d37c99cdda3737ad76942bdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of Euclidean norm for sparse vector.  <a href="#a76346f2d37c99cdda3737ad76942bdb2">More...</a><br/></td></tr>
<tr class="separator:a76346f2d37c99cdda3737ad76942bdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76c2d795781c203de394c73c62b0420"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:aa76c2d795781c203de394c73c62b0420"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa76c2d795781c203de394c73c62b0420">sparse_inner_prod</a> (SparseVectorT const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, SparseVectorT const &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;res_v)</td></tr>
<tr class="memdesc:aa76c2d795781c203de394c73c62b0420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of two sparse vectors.  <a href="#aa76c2d795781c203de394c73c62b0420">More...</a><br/></td></tr>
<tr class="separator:aa76c2d795781c203de394c73c62b0420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53274082aa46458002bff392267fbaa"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:ae53274082aa46458002bff392267fbaa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae53274082aa46458002bff392267fbaa">buildAugmentedIndexSet</a> (std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, SparseVectorT const &amp;res, std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;J_u, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:ae53274082aa46458002bff392267fbaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Building a new set of column indices J_u, cf. Kallischko dissertation p.31.  <a href="#ae53274082aa46458002bff392267fbaa">More...</a><br/></td></tr>
<tr class="separator:ae53274082aa46458002bff392267fbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec10e331a15985f8d5fd3891332d60d"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT &gt; </td></tr>
<tr class="memitem:a8ec10e331a15985f8d5fd3891332d60d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a8ec10e331a15985f8d5fd3891332d60d">buildNewRowSet</a> (std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, std::vector&lt; unsigned int &gt; const &amp;I, std::vector&lt; unsigned int &gt; const &amp;J_n, std::vector&lt; unsigned int &gt; &amp;I_n)</td></tr>
<tr class="memdesc:a8ec10e331a15985f8d5fd3891332d60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Building a new indices to current set of row indices I_n, cf. Kallischko dissertation p.32.  <a href="#a8ec10e331a15985f8d5fd3891332d60d">More...</a><br/></td></tr>
<tr class="separator:a8ec10e331a15985f8d5fd3891332d60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453c8768ecde4b09adaff9e130d8f3ed"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:a453c8768ecde4b09adaff9e130d8f3ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a453c8768ecde4b09adaff9e130d8f3ed">QRBlockComposition</a> (MatrixT const &amp;A_I_J, MatrixT const &amp;A_I_J_u, MatrixT &amp;A_I_u_J_u)</td></tr>
<tr class="memdesc:a453c8768ecde4b09adaff9e130d8f3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of new block for QR factorization cf. Kallischko dissertation p.82, figure 4.7.  <a href="#a453c8768ecde4b09adaff9e130d8f3ed">More...</a><br/></td></tr>
<tr class="separator:a453c8768ecde4b09adaff9e130d8f3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a63d610aebbcd68a76468e22e33ac83"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixT , typename SparseVectorT , typename DenseMatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:a8a63d610aebbcd68a76468e22e33ac83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a8a63d610aebbcd68a76468e22e33ac83">block_update</a> (SparseMatrixT const &amp;A, std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, std::vector&lt; SparseVectorT &gt; &amp;g_res, std::vector&lt; bool &gt; &amp;g_is_update, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; VectorT &gt; &amp;g_b_v, std::vector&lt; DenseMatrixT &gt; &amp;g_A_I_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:a8a63d610aebbcd68a76468e22e33ac83"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU-based dynamic update for SPAI preconditioner.  <a href="#a8a63d610aebbcd68a76468e22e33ac83">More...</a><br/></td></tr>
<tr class="separator:a8a63d610aebbcd68a76468e22e33ac83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030bd1b3e7fb96ca912e86e190e7cb9a"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a030bd1b3e7fb96ca912e86e190e7cb9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a030bd1b3e7fb96ca912e86e190e7cb9a">block_q_multiplication</a> (std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_J_u, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_I, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_u_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update, <a class="el" href="classviennacl_1_1context.html">viennacl::context</a> ctx)</td></tr>
<tr class="memdesc:a030bd1b3e7fb96ca912e86e190e7cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multiplication Q'*A(I, \tilde J) on GPU.  <a href="#a030bd1b3e7fb96ca912e86e190e7cb9a">More...</a><br/></td></tr>
<tr class="separator:a030bd1b3e7fb96ca912e86e190e7cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97e4f8849c15f3dea55584f4a1fcc85"><td class="memTemplParams" colspan="2">template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:ab97e4f8849c15f3dea55584f4a1fcc85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab97e4f8849c15f3dea55584f4a1fcc85">assemble_qr_row_inds</a> (std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;g_I, std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;g_J, std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;g_I_u, std::vector&lt; std::vector&lt; SizeT &gt; &gt; &amp;g_I_q)</td></tr>
<tr class="memdesc:ab97e4f8849c15f3dea55584f4a1fcc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly of container of index row sets: I_q, row indices for new "QR block".  <a href="#ab97e4f8849c15f3dea55584f4a1fcc85">More...</a><br/></td></tr>
<tr class="separator:ab97e4f8849c15f3dea55584f4a1fcc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6a2326a67eed3c453880e1a9887b55"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a2a6a2326a67eed3c453880e1a9887b55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a2a6a2326a67eed3c453880e1a9887b55">assemble_qr_block</a> (std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_J, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_J_u, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_I_u, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I_q, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_u_vcl, <a class="el" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle</a>&lt; cl_mem &gt; &amp;matrix_dimensions, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_u_J_u_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update, bool is_empty_block, <a class="el" href="classviennacl_1_1context.html">viennacl::context</a> ctx)</td></tr>
<tr class="memdesc:a2a6a2326a67eed3c453880e1a9887b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs assembly for new QR block.  <a href="#a2a6a2326a67eed3c453880e1a9887b55">More...</a><br/></td></tr>
<tr class="separator:a2a6a2326a67eed3c453880e1a9887b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada295fb9ae10dcc0bc6728be3c006cd4"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ada295fb9ae10dcc0bc6728be3c006cd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ada295fb9ae10dcc0bc6728be3c006cd4">assemble_r</a> (std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_u_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_u_J_u_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl_u, std::vector&lt; cl_uint &gt; &amp;g_is_update, <a class="el" href="classviennacl_1_1context.html">viennacl::context</a> ctx)</td></tr>
<tr class="memdesc:ada295fb9ae10dcc0bc6728be3c006cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs assembly for new R matrix on GPU.  <a href="#ada295fb9ae10dcc0bc6728be3c006cd4">More...</a><br/></td></tr>
<tr class="separator:ada295fb9ae10dcc0bc6728be3c006cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7edbe83326cd05affc0ac8e68c6a2d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename SparseVectorT &gt; </td></tr>
<tr class="memitem:aac7edbe83326cd05affc0ac8e68c6a2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aac7edbe83326cd05affc0ac8e68c6a2d">block_update</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;A, std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, std::vector&lt; cl_uint &gt; &amp;g_is_update, std::vector&lt; SparseVectorT &gt; &amp;g_res, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:aac7edbe83326cd05affc0ac8e68c6a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU-based block update.  <a href="#aac7edbe83326cd05affc0ac8e68c6a2d">More...</a><br/></td></tr>
<tr class="separator:aac7edbe83326cd05affc0ac8e68c6a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04773e48e2b2afdbeee55fdda179ff5c"><td class="memTemplParams" colspan="2">template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:a04773e48e2b2afdbeee55fdda179ff5c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a04773e48e2b2afdbeee55fdda179ff5c">isInIndexSet</a> (std::vector&lt; SizeT &gt; const &amp;J, SizeT ind)</td></tr>
<tr class="memdesc:a04773e48e2b2afdbeee55fdda179ff5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if element ind is in set {J}.  <a href="#a04773e48e2b2afdbeee55fdda179ff5c">More...</a><br/></td></tr>
<tr class="separator:a04773e48e2b2afdbeee55fdda179ff5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19057ee4834fe816e96f0d52863cc45"><td class="memTemplParams" colspan="2">template&lt;typename VectorT , typename SparseVectorT &gt; </td></tr>
<tr class="memitem:ab19057ee4834fe816e96f0d52863cc45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab19057ee4834fe816e96f0d52863cc45">fanOutVector</a> (VectorT const &amp;m_in, std::vector&lt; unsigned int &gt; const &amp;J, SparseVectorT &amp;m)</td></tr>
<tr class="memdesc:ab19057ee4834fe816e96f0d52863cc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects solution of LS problem onto original column m.  <a href="#ab19057ee4834fe816e96f0d52863cc45">More...</a><br/></td></tr>
<tr class="separator:ab19057ee4834fe816e96f0d52863cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b348879ddf3c802a8fe03cc2539b43c"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:a6b348879ddf3c802a8fe03cc2539b43c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6b348879ddf3c802a8fe03cc2539b43c">backwardSolve</a> (MatrixT const &amp;R, VectorT const &amp;y, VectorT &amp;x)</td></tr>
<tr class="memdesc:a6b348879ddf3c802a8fe03cc2539b43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of linear:R*x=y system by backward substitution.  <a href="#a6b348879ddf3c802a8fe03cc2539b43c">More...</a><br/></td></tr>
<tr class="separator:a6b348879ddf3c802a8fe03cc2539b43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa448e23270c2fd92b9f6c9c4df359a6a"><td class="memTemplParams" colspan="2">template&lt;typename VectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:aa448e23270c2fd92b9f6c9c4df359a6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aa448e23270c2fd92b9f6c9c4df359a6a">projectI</a> (std::vector&lt; unsigned int &gt; const &amp;I, VectorT &amp;y, unsigned int ind)</td></tr>
<tr class="memdesc:aa448e23270c2fd92b9f6c9c4df359a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform projection of set I on the unit-vector.  <a href="#aa448e23270c2fd92b9f6c9c4df359a6a">More...</a><br/></td></tr>
<tr class="separator:aa448e23270c2fd92b9f6c9c4df359a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3f653e6eacca58ccf36e972017d36"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT &gt; </td></tr>
<tr class="memitem:a6ae3f653e6eacca58ccf36e972017d36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6ae3f653e6eacca58ccf36e972017d36">buildColumnIndexSet</a> (SparseVectorT const &amp;v, std::vector&lt; unsigned int &gt; &amp;J)</td></tr>
<tr class="memdesc:a6ae3f653e6eacca58ccf36e972017d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds index set of projected columns for current column of preconditioner.  <a href="#a6ae3f653e6eacca58ccf36e972017d36">More...</a><br/></td></tr>
<tr class="separator:a6ae3f653e6eacca58ccf36e972017d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8477f662432b03c92b4287e3a4db3d6"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixT &gt; </td></tr>
<tr class="memitem:ab8477f662432b03c92b4287e3a4db3d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ab8477f662432b03c92b4287e3a4db3d6">initPreconditioner</a> (SparseMatrixT const &amp;A, SparseMatrixT &amp;M)</td></tr>
<tr class="memdesc:ab8477f662432b03c92b4287e3a4db3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize preconditioner with sparcity pattern = p(A)  <a href="#ab8477f662432b03c92b4287e3a4db3d6">More...</a><br/></td></tr>
<tr class="separator:ab8477f662432b03c92b4287e3a4db3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae548ee7e9301caf3cc50ada65389bce0"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT &gt; </td></tr>
<tr class="memitem:ae548ee7e9301caf3cc50ada65389bce0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae548ee7e9301caf3cc50ada65389bce0">projectRows</a> (std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, std::vector&lt; unsigned int &gt; const &amp;J, std::vector&lt; unsigned int &gt; &amp;I)</td></tr>
<tr class="memdesc:ae548ee7e9301caf3cc50ada65389bce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row projection for matrix A(:,J) -&gt; A(I,J), building index set of non-zero rows.  <a href="#ae548ee7e9301caf3cc50ada65389bce0">More...</a><br/></td></tr>
<tr class="separator:ae548ee7e9301caf3cc50ada65389bce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d1da881af74993b78c433286b70a00"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT &gt; </td></tr>
<tr class="memitem:ae5d1da881af74993b78c433286b70a00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae5d1da881af74993b78c433286b70a00">print_sparse_vector</a> (SparseVectorT const &amp;v)</td></tr>
<tr class="separator:ae5d1da881af74993b78c433286b70a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dca466b626554c2b42bf25b500842e2"><td class="memTemplParams" colspan="2">template&lt;typename DenseMatrixT &gt; </td></tr>
<tr class="memitem:a5dca466b626554c2b42bf25b500842e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a5dca466b626554c2b42bf25b500842e2">print_matrix</a> (DenseMatrixT &amp;m)</td></tr>
<tr class="separator:a5dca466b626554c2b42bf25b500842e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1688aeb8885254756bf80384a223ac"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:ada1688aeb8885254756bf80384a223ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ada1688aeb8885254756bf80384a223ac">add_sparse_vectors</a> (SparseVectorT const &amp;v, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> b, SparseVectorT &amp;res_v)</td></tr>
<tr class="memdesc:ada1688aeb8885254756bf80384a223ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two sparse vectors res_v = b*v.  <a href="#ada1688aeb8885254756bf80384a223ac">More...</a><br/></td></tr>
<tr class="separator:ada1688aeb8885254756bf80384a223ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4673473f615b2369ca4e14b1a6f98b5c"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:a4673473f615b2369ca4e14b1a6f98b5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a4673473f615b2369ca4e14b1a6f98b5c">compute_spai_residual</a> (std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, SparseVectorT const &amp;v, unsigned int ind, SparseVectorT &amp;res)</td></tr>
<tr class="memdesc:a4673473f615b2369ca4e14b1a6f98b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of residual res = A*v - e.  <a href="#a4673473f615b2369ca4e14b1a6f98b5c">More...</a><br/></td></tr>
<tr class="separator:a4673473f615b2369ca4e14b1a6f98b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaad1278cf03e43d711f0f24d9d454c9"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT &gt; </td></tr>
<tr class="memitem:acaad1278cf03e43d711f0f24d9d454c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#acaad1278cf03e43d711f0f24d9d454c9">build_index_set</a> (std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, SparseVectorT const &amp;v, std::vector&lt; unsigned int &gt; &amp;J, std::vector&lt; unsigned int &gt; &amp;I)</td></tr>
<tr class="memdesc:acaad1278cf03e43d711f0f24d9d454c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting up index set of columns and rows for certain column.  <a href="#acaad1278cf03e43d711f0f24d9d454c9">More...</a><br/></td></tr>
<tr class="separator:acaad1278cf03e43d711f0f24d9d454c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1616fc9ee32fd0e1d641f6d8f2ebf3"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixT , typename DenseMatrixT &gt; </td></tr>
<tr class="memitem:aff1616fc9ee32fd0e1d641f6d8f2ebf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aff1616fc9ee32fd0e1d641f6d8f2ebf3">initProjectSubMatrix</a> (SparseMatrixT const &amp;A_in, std::vector&lt; unsigned int &gt; const &amp;J, std::vector&lt; unsigned int &gt; &amp;I, DenseMatrixT &amp;A_out)</td></tr>
<tr class="memdesc:aff1616fc9ee32fd0e1d641f6d8f2ebf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a dense matrix from a sparse one.  <a href="#aff1616fc9ee32fd0e1d641f6d8f2ebf3">More...</a><br/></td></tr>
<tr class="separator:aff1616fc9ee32fd0e1d641f6d8f2ebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906b89d67f50b1adf349391bb62b7cf0"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixT , typename DenseMatrixT , typename SparseVectorT , typename VectorT &gt; </td></tr>
<tr class="memitem:a906b89d67f50b1adf349391bb62b7cf0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a906b89d67f50b1adf349391bb62b7cf0">block_set_up</a> (SparseMatrixT const &amp;A, std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, std::vector&lt; SparseVectorT &gt; const &amp;M_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; DenseMatrixT &gt; &amp;g_A_I_J, std::vector&lt; VectorT &gt; &amp;g_b_v)</td></tr>
<tr class="memdesc:a906b89d67f50b1adf349391bb62b7cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting up blocks and QR factorizing them on CPU.  <a href="#a906b89d67f50b1adf349391bb62b7cf0">More...</a><br/></td></tr>
<tr class="separator:a906b89d67f50b1adf349391bb62b7cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6983ad76ea95e66ed94092bd05f44204"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT &gt; </td></tr>
<tr class="memitem:a6983ad76ea95e66ed94092bd05f44204"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a6983ad76ea95e66ed94092bd05f44204">index_set_up</a> (std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, std::vector&lt; SparseVectorT &gt; const &amp;M_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I)</td></tr>
<tr class="memdesc:a6983ad76ea95e66ed94092bd05f44204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting up index set of columns and rows for all columns.  <a href="#a6983ad76ea95e66ed94092bd05f44204">More...</a><br/></td></tr>
<tr class="separator:a6983ad76ea95e66ed94092bd05f44204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae544b4abea516f88a64117c4c548d3a7"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename SparseVectorT &gt; </td></tr>
<tr class="memitem:ae544b4abea516f88a64117c4c548d3a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#ae544b4abea516f88a64117c4c548d3a7">block_set_up</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;A, std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, std::vector&lt; SparseVectorT &gt; const &amp;M_v, std::vector&lt; cl_uint &gt; g_is_update, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv)</td></tr>
<tr class="memdesc:ae544b4abea516f88a64117c4c548d3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting up blocks and QR factorizing them on GPU.  <a href="#ae544b4abea516f88a64117c4c548d3a7">More...</a><br/></td></tr>
<tr class="separator:ae544b4abea516f88a64117c4c548d3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5e501e0f8a2f6e2733b0c5df10c6ad"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename SparseVectorT &gt; </td></tr>
<tr class="memitem:a4a5e501e0f8a2f6e2733b0c5df10c6ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a4a5e501e0f8a2f6e2733b0c5df10c6ad">custom_fan_out</a> (std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;m_in, unsigned int start_m_ind, std::vector&lt; unsigned int &gt; const &amp;J, SparseVectorT &amp;m)</td></tr>
<tr class="memdesc:a4a5e501e0f8a2f6e2733b0c5df10c6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elicitation of sparse vector m for particular column from m_in - contigious vector for all columns.  <a href="#a4a5e501e0f8a2f6e2733b0c5df10c6ad">More...</a><br/></td></tr>
<tr class="separator:a4a5e501e0f8a2f6e2733b0c5df10c6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644c28fb7b3c4e677d86dc4b06388dab"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT , typename NumericT &gt; </td></tr>
<tr class="memitem:a644c28fb7b3c4e677d86dc4b06388dab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a644c28fb7b3c4e677d86dc4b06388dab">least_square_solve</a> (std::vector&lt; SparseVectorT &gt; &amp;A_v_c, std::vector&lt; SparseVectorT &gt; &amp;M_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__vector.html">block_vector</a> &amp;g_bv_vcl, std::vector&lt; SparseVectorT &gt; &amp;g_res, std::vector&lt; cl_uint &gt; &amp;g_is_update, const <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> &amp;tag, <a class="el" href="classviennacl_1_1context.html">viennacl::context</a> ctx)</td></tr>
<tr class="memdesc:a644c28fb7b3c4e677d86dc4b06388dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of Least square problem on GPU.  <a href="#a644c28fb7b3c4e677d86dc4b06388dab">More...</a><br/></td></tr>
<tr class="separator:a644c28fb7b3c4e677d86dc4b06388dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b9a595189ffa38d5acdaad6a286905"><td class="memTemplParams" colspan="2">template&lt;typename SparseVectorT , typename DenseMatrixT , typename VectorT &gt; </td></tr>
<tr class="memitem:a18b9a595189ffa38d5acdaad6a286905"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a18b9a595189ffa38d5acdaad6a286905">least_square_solve</a> (std::vector&lt; SparseVectorT &gt; const &amp;A_v_c, std::vector&lt; DenseMatrixT &gt; &amp;g_R, std::vector&lt; VectorT &gt; &amp;g_b_v, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_I, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;g_J, std::vector&lt; SparseVectorT &gt; &amp;g_res, std::vector&lt; bool &gt; &amp;g_is_update, std::vector&lt; SparseVectorT &gt; &amp;M_v, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:a18b9a595189ffa38d5acdaad6a286905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of Least square problem on CPU.  <a href="#a18b9a595189ffa38d5acdaad6a286905">More...</a><br/></td></tr>
<tr class="separator:a18b9a595189ffa38d5acdaad6a286905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b96ecccca6f209e810669f0d13e36"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:aea8b96ecccca6f209e810669f0d13e36"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#aea8b96ecccca6f209e810669f0d13e36">is_all_update</a> (VectorType &amp;parallel_is_update)</td></tr>
<tr class="separator:aea8b96ecccca6f209e810669f0d13e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a76d81e5a1302f9d03949ea2783ee7d"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixT , typename SparseVectorT &gt; </td></tr>
<tr class="memitem:a1a76d81e5a1302f9d03949ea2783ee7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a1a76d81e5a1302f9d03949ea2783ee7d">vectorize_column_matrix</a> (SparseMatrixT const &amp;M_in, std::vector&lt; SparseVectorT &gt; &amp;M_v)</td></tr>
<tr class="memdesc:a1a76d81e5a1302f9d03949ea2783ee7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of Least square problem on CPU.  <a href="#a1a76d81e5a1302f9d03949ea2783ee7d">More...</a><br/></td></tr>
<tr class="separator:a1a76d81e5a1302f9d03949ea2783ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c462e0ad109f5e23eb34982c2f91dd4"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixT , typename SparseVectorT &gt; </td></tr>
<tr class="memitem:a7c462e0ad109f5e23eb34982c2f91dd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a7c462e0ad109f5e23eb34982c2f91dd4">vectorize_row_matrix</a> (SparseMatrixT const &amp;M_in, std::vector&lt; SparseVectorT &gt; &amp;M_v)</td></tr>
<tr class="separator:a7c462e0ad109f5e23eb34982c2f91dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511597723c2d451fda55ff4ead99eaf0"><td class="memTemplParams" colspan="2">template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:a511597723c2d451fda55ff4ead99eaf0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a511597723c2d451fda55ff4ead99eaf0">write_set_to_array</a> (std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;ind_set, std::vector&lt; cl_uint &gt; &amp;a)</td></tr>
<tr class="separator:a511597723c2d451fda55ff4ead99eaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2919f83347787985e20e0599ba4296"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:afe2919f83347787985e20e0599ba4296"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#afe2919f83347787985e20e0599ba4296">block_assembly</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;A, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_J, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;g_I, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1block__matrix.html">block_matrix</a> &amp;g_A_I_J_vcl, std::vector&lt; cl_uint &gt; &amp;g_is_update, bool &amp;is_empty_block)</td></tr>
<tr class="memdesc:afe2919f83347787985e20e0599ba4296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly of blocks on GPU by a gived set of row indices: g_I and column indices: g_J.  <a href="#afe2919f83347787985e20e0599ba4296">More...</a><br/></td></tr>
<tr class="separator:afe2919f83347787985e20e0599ba4296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312ded5b57f112daa612d3b790cbc830"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixT , typename SparseVectorT &gt; </td></tr>
<tr class="memitem:a312ded5b57f112daa612d3b790cbc830"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a312ded5b57f112daa612d3b790cbc830">insert_sparse_columns</a> (std::vector&lt; SparseVectorT &gt; const &amp;M_v, SparseMatrixT &amp;M, bool is_right)</td></tr>
<tr class="memdesc:a312ded5b57f112daa612d3b790cbc830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion of vectorized matrix column into original sparse matrix.  <a href="#a312ded5b57f112daa612d3b790cbc830">More...</a><br/></td></tr>
<tr class="separator:a312ded5b57f112daa612d3b790cbc830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934fa8b447e7836d4c9be2dd40c35390"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:a934fa8b447e7836d4c9be2dd40c35390"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a934fa8b447e7836d4c9be2dd40c35390">sparse_transpose</a> (MatrixT const &amp;A_in, MatrixT &amp;A)</td></tr>
<tr class="memdesc:a934fa8b447e7836d4c9be2dd40c35390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposition of sparse matrix.  <a href="#a934fa8b447e7836d4c9be2dd40c35390">More...</a><br/></td></tr>
<tr class="separator:a934fa8b447e7836d4c9be2dd40c35390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d52c5d84eb0f23619d0129c50412e82"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT &gt; </td></tr>
<tr class="memitem:a4d52c5d84eb0f23619d0129c50412e82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#a4d52c5d84eb0f23619d0129c50412e82">computeSPAI</a> (MatrixT const &amp;A, MatrixT &amp;M, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a4d52c5d84eb0f23619d0129c50412e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of SPAI preconditioner on CPU.  <a href="#a4d52c5d84eb0f23619d0129c50412e82">More...</a><br/></td></tr>
<tr class="separator:a4d52c5d84eb0f23619d0129c50412e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29f9f19dceffdd04a1ac530c6fbb4ed"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:af29f9f19dceffdd04a1ac530c6fbb4ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html#af29f9f19dceffdd04a1ac530c6fbb4ed">computeSPAI</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;A, boost::numeric::ublas::compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;cpu_A, boost::numeric::ublas::compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;cpu_M, <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;M, <a class="el" href="classviennacl_1_1linalg_1_1detail_1_1spai_1_1spai__tag.html">spai_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:af29f9f19dceffdd04a1ac530c6fbb4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of SPAI preconditioner on GPU.  <a href="#af29f9f19dceffdd04a1ac530c6fbb4ed">More...</a><br/></td></tr>
<tr class="separator:af29f9f19dceffdd04a1ac530c6fbb4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation namespace for sparse approximate inverse preconditioner. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ada1688aeb8885254756bf80384a223ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::add_sparse_vectors </td>
          <td>(</td>
          <td class="paramtype">SparseVectorT const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorT &amp;&#160;</td>
          <td class="paramname"><em>res_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two sparse vectors res_v = b*v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>initial sparse vector </td></tr>
    <tr><td class="paramname">b</td><td>scalar </td></tr>
    <tr><td class="paramname">res_v</td><td>output vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00105">105</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08cfda20cf63c245a5c22034875743da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::apply_householder_reflection </td>
          <td>(</td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iter_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inplace application of Householder vector to a matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">iter_cnt</td><td>current iteration </td></tr>
    <tr><td class="paramname">v</td><td>Householder vector </td></tr>
    <tr><td class="paramname">b</td><td>beta </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00271">271</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1bcb9bff13f114739f5f7d70d5b38223"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::apply_q_trans_mat </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>b_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication of Q'*A, where Q is in implicit for lower part of R and vector of betas - b_v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>input matrix </td></tr>
    <tr><td class="paramname">b_v</td><td>vector of betas </td></tr>
    <tr><td class="paramname">A</td><td>output matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00404">404</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3b64ba7bb53a1526cc852daf0d4d53e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::apply_q_trans_vec </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>b_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recovery Q from matrix R and vector of betas b_v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>input matrix </td></tr>
    <tr><td class="paramname">b_v</td><td>vector of betas </td></tr>
    <tr><td class="paramname">y</td><td>output vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00377">377</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a6a2326a67eed3c453880e1a9887b55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::assemble_qr_block </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_J_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_I_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle</a>&lt; cl_mem &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_u_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_empty_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1context.html">viennacl::context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs assembly for new QR block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J_u</td><td>container of new column indices </td></tr>
    <tr><td class="paramname">g_I_u</td><td>container of new row indices </td></tr>
    <tr><td class="paramname">g_I_q</td><td>container of row indices for new QR blocks </td></tr>
    <tr><td class="paramname">g_A_I_J_u_vcl</td><td>blocks of Q'*A(I, \tilde J) </td></tr>
    <tr><td class="paramname">matrix_dimensions</td><td>array with matrix dimensions for all blocks </td></tr>
    <tr><td class="paramname">g_A_I_u_J_u_vcl</td><td>blocks A(\tilde I, \tilde J) </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with update indicators </td></tr>
    <tr><td class="paramname">is_empty_block</td><td>indicator if all previous blocks A(\tilde I, \tilde J) - are empty, in case if they are empty kernel with smaller number of arguments is used </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context in which the matrix is created (one out of multiple OpenCL contexts, CUDA, host) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00439">439</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab97e4f8849c15f3dea55584f4a1fcc85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::assemble_qr_row_inds </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_I_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SizeT &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I_q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assembly of container of index row sets: I_q, row indices for new "QR block". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_I_u</td><td>container of new row indices </td></tr>
    <tr><td class="paramname">g_I_q</td><td>container of row indices for new QR blocks </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00406">406</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada295fb9ae10dcc0bc6728be3c006cd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::assemble_r </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_u_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1context.html">viennacl::context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs assembly for new R matrix on GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>container of block matrices from previous update </td></tr>
    <tr><td class="paramname">g_A_I_J_u_vcl</td><td>container of block matrices Q'*A(I, \tilde J) </td></tr>
    <tr><td class="paramname">g_A_I_u_J_u_vcl</td><td>container of block matrices QR factored on current iteration </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>block of beta vectors from previous iteration </td></tr>
    <tr><td class="paramname">g_bv_vcl_u</td><td>block of updated beta vectors got after recent QR factorization </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with identificators that shows which block should be modified </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context in which the auxiliary data is created (one out of multiple OpenCL contexts, CUDA, host) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00533">533</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b348879ddf3c802a8fe03cc2539b43c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::backwardSolve </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solution of linear:R*x=y system by backward substitution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>uppertriangular matrix </td></tr>
    <tr><td class="paramname">y</td><td>right handside vector </td></tr>
    <tr><td class="paramname">x</td><td>solution vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-static_8hpp_source.html#l00102">102</a> of file <a class="el" href="spai-static_8hpp_source.html">spai-static.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe2919f83347787985e20e0599ba4296"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::block_assembly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>is_empty_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assembly of blocks on GPU by a gived set of row indices: g_I and column indices: g_J. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>intial sparse matrix </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column index set </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row index set </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>contigious blocks A(I, J) using GPU memory </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with indicators which blocks are active </td></tr>
    <tr><td class="paramname">is_empty_block</td><td>parameter that indicates if no block were assembled </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00507">507</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a030bd1b3e7fb96ca912e86e190e7cb9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::block_q_multiplication </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_J_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_u_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1context.html">viennacl::context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs multiplication Q'*A(I, \tilde J) on GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_J_u</td><td>container of sets of new column indices </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>block matrix composed from previous blocks, they are blocks of R </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>block of beta vectors </td></tr>
    <tr><td class="paramname">g_A_I_J_u_vcl</td><td>block of matrices A(I, \tilde J) </td></tr>
    <tr><td class="paramname">g_is_update</td><td>indicators, that show if a certain block should be processed </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context in which the auxiliary data is created (one out of multiple OpenCL contexts, CUDA, host) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00361">361</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa50a771c3604ad3913905871d54176f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::block_qr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1context.html">viennacl::context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inplace QR factorization via Householder reflections c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.224 performed on GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>contigious matrices, GPU memory is used </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>contigiuos vectors beta, GPU memory is used </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container of indicators that show active blocks </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context in which the auxiliary data is created (one out of multiple OpenCL contexts, CUDA, host) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00428">428</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a906b89d67f50b1adf349391bb62b7cf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixT , typename DenseMatrixT , typename SparseVectorT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::block_set_up </td>
          <td>(</td>
          <td class="paramtype">SparseMatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DenseMatrixT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_b_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting up blocks and QR factorizing them on CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">A_v_c</td><td>column major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>initialized preconditioner </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_A_I_J</td><td>container of dense matrices -&gt; R matrices after QR factorization </td></tr>
    <tr><td class="paramname">g_b_v</td><td>container of vectors beta, necessary for Q recovery </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00181">181</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae544b4abea516f88a64117c4c548d3a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::block_set_up </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting up blocks and QR factorizing them on GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">A_v_c</td><td>column major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>initialized preconditioner </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container that indicates which blocks are active </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_A_I_J</td><td>container of dense matrices -&gt; R matrices after QR factorization </td></tr>
    <tr><td class="paramname">g_bv</td><td>container of vectors beta, necessary for Q recovery </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00240">240</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a63d610aebbcd68a76468e22e33ac83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixT , typename SparseVectorT , typename DenseMatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::block_update </td>
          <td>(</td>
          <td class="paramtype">SparseMatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_b_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DenseMatrixT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spai_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CPU-based dynamic update for SPAI preconditioner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">A_v_c</td><td>vectorized column-wise initial matrix </td></tr>
    <tr><td class="paramname">g_res</td><td>container of residuals for all columns </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with identificators that shows which block should be modified </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row index sets for all columns </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column index sets for all columns </td></tr>
    <tr><td class="paramname">g_b_v</td><td>container of vectors of beta for Q recovery(cf. Golub Van Loan "Matrix Computations", 3rd edition p.211) </td></tr>
    <tr><td class="paramname">g_A_I_J</td><td>container of block matrices from previous update </td></tr>
    <tr><td class="paramname">tag</td><td>SPAI configuration tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00291">291</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac7edbe83326cd05affc0ac8e68c6a2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::block_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spai_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPU-based block update. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>sparse matrix </td></tr>
    <tr><td class="paramname">A_v_c</td><td>vectorized column-wise initial matrix </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with identificators that shows which block should be modified </td></tr>
    <tr><td class="paramname">g_res</td><td>container of residuals for all columns </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column index sets for all columns </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row index sets for all columns </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>container of block matrices from previous update </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>block of beta vectors from previous iteration </td></tr>
    <tr><td class="paramname">tag</td><td>SPAI configuration tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00625">625</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acaad1278cf03e43d711f0f24d9d454c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::build_index_set </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorT const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting up index set of columns and rows for certain column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">v</td><td>current column of preconditioner matrix </td></tr>
    <tr><td class="paramname">J</td><td>set of column indices </td></tr>
    <tr><td class="paramname">I</td><td>set of row indices </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00139">139</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae53274082aa46458002bff392267fbaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viennacl::linalg::detail::spai::buildAugmentedIndexSet </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorT const &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spai_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Building a new set of column indices J_u, cf. Kallischko dissertation p.31. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>vectorized column-wise initial matrix </td></tr>
    <tr><td class="paramname">res</td><td>residual vector </td></tr>
    <tr><td class="paramname">J</td><td>set of column indices </td></tr>
    <tr><td class="paramname">J_u</td><td>set of new column indices </td></tr>
    <tr><td class="paramname">tag</td><td>SPAI tag with parameters </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00188">188</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ae3f653e6eacca58ccf36e972017d36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::buildColumnIndexSet </td>
          <td>(</td>
          <td class="paramtype">SparseVectorT const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds index set of projected columns for current column of preconditioner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>current column of preconditioner </td></tr>
    <tr><td class="paramname">J</td><td>output - index set of non-zero columns </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-static_8hpp_source.html#l00140">140</a> of file <a class="el" href="spai-static_8hpp_source.html">spai-static.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ec10e331a15985f8d5fd3891332d60d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::buildNewRowSet </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>J_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Building a new indices to current set of row indices I_n, cf. Kallischko dissertation p.32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>vectorized column-wise initial matrix </td></tr>
    <tr><td class="paramname">I</td><td>set of previous determined row indices </td></tr>
    <tr><td class="paramname">J_n</td><td>set of new column indices </td></tr>
    <tr><td class="paramname">I_n</td><td>set of new indices </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00228">228</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3aaf276d63d5442f2f95d060912c4ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fspai_8hpp_source.html#l00210">210</a> of file <a class="el" href="fspai_8hpp_source.html">fspai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a097e316b51cf3854abec362e6a6d1d47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::cholesky_solve </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fspai_8hpp_source.html#l00238">238</a> of file <a class="el" href="fspai_8hpp_source.html">fspai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ed76d80fb1f213aa6ac3df4756a173a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::composeNewR </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>R_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composition of new matrix R, that is going to be used in Least Square problem solving. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix Q'*A(I, \tilde J), where \tilde J - set of new column indices </td></tr>
    <tr><td class="paramname">R_n</td><td>matrix A_Iu_J_u after QR factorization </td></tr>
    <tr><td class="paramname">R</td><td>previously composed matrix R </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00094">94</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04f2cf7cafff244de64e0f5e54507963"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::composeNewVector </td>
          <td>(</td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>v_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composition of new vector of coefficients beta from QR factorizations(necessary for Q recovery) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_n</td><td>new vector from last QR factorization </td></tr>
    <tr><td class="paramname">v</td><td>composition of previous vectors from QR factorizations </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00124">124</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a76ae3dcfedb876ec9f2db3155b81a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::compute_blocks_size </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocks_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>**************************************** BLOCK FUNCTIONS ************************************// </p>
<p>Computes size of elements, start indices and matrix dimensions for a certain block</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">sz</td><td>general size for all elements in a certain block </td></tr>
    <tr><td class="paramname">blocks_ind</td><td>start indices in a certain </td></tr>
    <tr><td class="paramname">matrix_dims</td><td>matrix dimensions for each block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00129">129</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4673473f615b2369ca4e14b1a6f98b5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::compute_spai_residual </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorT const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorT &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation of residual res = A*v - e. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column major vectorized input sparse matrix </td></tr>
    <tr><td class="paramname">v</td><td>sparse vector, in this case new column of preconditioner matrix </td></tr>
    <tr><td class="paramname">ind</td><td>index for current column </td></tr>
    <tr><td class="paramname">res</td><td>residual </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00120">120</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23b282bb53b72b43e7f76d9aeb3df64b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::computeFSPAI </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>PatternA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>L_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fspai_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fspai_8hpp_source.html#l00313">313</a> of file <a class="el" href="fspai_8hpp_source.html">fspai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeac5736cf32d6afbea570aa683dbe115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::computeL </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>L_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; vcl_size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fspai_8hpp_source.html#l00266">266</a> of file <a class="el" href="fspai_8hpp_source.html">fspai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d52c5d84eb0f23619d0129c50412e82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::computeSPAI </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spai_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construction of SPAI preconditioner on CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">M</td><td>output preconditioner </td></tr>
    <tr><td class="paramname">tag</td><td>spai tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00686">686</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af29f9f19dceffdd04a1ac530c6fbb4ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::computeSPAI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::numeric::ublas::compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::numeric::ublas::compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spai_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construction of SPAI preconditioner on GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>initial sparse matrix </td></tr>
    <tr><td class="paramname">cpu_A</td><td>copy of initial matrix on CPU </td></tr>
    <tr><td class="paramname">cpu_M</td><td>output preconditioner on CPU </td></tr>
    <tr><td class="paramname">M</td><td>output preconditioner </td></tr>
    <tr><td class="paramname">tag</td><td>SPAI tag class with parameters </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00775">775</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c9928b400d93d677b626c5ea9e51819"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::copy_vector </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>beg_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copying part of matrix column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">v</td><td>output vector </td></tr>
    <tr><td class="paramname">beg_ind</td><td>start index for copying </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00218">218</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f734abea08b6732fb5a6d3d50f36319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::custom_dot_prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot_prod(column(A, ind), v) starting from index ind+1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">v</td><td>input vector </td></tr>
    <tr><td class="paramname">ind</td><td>index </td></tr>
    <tr><td class="paramname">res</td><td>result value </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00355">355</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a5e501e0f8a2f6e2733b0c5df10c6ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::custom_fan_out </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start_m_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorT &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elicitation of sparse vector m for particular column from m_in - contigious vector for all columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m_in</td><td>contigious sparse vector for all columns </td></tr>
    <tr><td class="paramname">start_m_ind</td><td>start index of particular vector </td></tr>
    <tr><td class="paramname">J</td><td>column index set </td></tr>
    <tr><td class="paramname">m</td><td>sparse vector for particular column </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00271">271</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6d21631da144b8d5c5de25afcbe53e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::custom_inner_prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot prod of particular matrix column with arbitrary vector: A(:, col_ind) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">v</td><td>input vector </td></tr>
    <tr><td class="paramname">col_ind</td><td>starting column index </td></tr>
    <tr><td class="paramname">start_ind</td><td>starting index inside column </td></tr>
    <tr><td class="paramname">res</td><td>result of dot product </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00200">200</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6543d2795df36b19080b431aca258b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double viennacl::linalg::detail::spai::determinant </td>
          <td>(</td>
          <td class="paramtype">boost::numeric::ublas::matrix_expression&lt; MatrixT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat_r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="small__matrix_8hpp_source.html#l00084">84</a> of file <a class="el" href="small__matrix_8hpp_source.html">small_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7eeb3f2f51183bed7e6d0a1aeefc87bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::dot_prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>beg_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot prod of particular column of martix A with it's self starting at a certain index beg_ind. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">beg_ind</td><td>starting index </td></tr>
    <tr><td class="paramname">res</td><td>result of dot product </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00182">182</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab19057ee4834fe816e96f0d52863cc45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorT , typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::fanOutVector </td>
          <td>(</td>
          <td class="paramtype">VectorT const &amp;&#160;</td>
          <td class="paramname"><em>m_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorT &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects solution of LS problem onto original column m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m_in</td><td>solution of LS </td></tr>
    <tr><td class="paramname">J</td><td>set of non-zero columns </td></tr>
    <tr><td class="paramname">m</td><td>original column of M </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-static_8hpp_source.html#l00088">88</a> of file <a class="el" href="spai-static_8hpp_source.html">spai-static.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd198c046af39cfe38f1aad62c0580ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::fill_blocks </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; MatrixT &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; vcl_size_t &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fspai_8hpp_source.html#l00172">172</a> of file <a class="el" href="fspai_8hpp_source.html">fspai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5f2c2a17a35ffa9682589bc3bd692dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::generateJ </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; vcl_size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fspai_8hpp_source.html#l00145">145</a> of file <a class="el" href="fspai_8hpp_source.html">fspai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af12bfcc7a652ea6bc9150c302dae81a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::get_max_block_size </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeT &amp;&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getting max size of rows/columns from container of index set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inds</td><td>container of index set </td></tr>
    <tr><td class="paramname">max_size</td><td>max size that corresponds to that container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00338">338</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7b43cbe43e0371cea55b325b410c1b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::get_size </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeT &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes size of particular container of index set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inds</td><td>container of index sets </td></tr>
    <tr><td class="paramname">size</td><td>output size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00151">151</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34b989396d25d3ec653ea0aa1e620f55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::householder_vector </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation of Householder vector, householder reflection c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.210. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">j</td><td>start index for computations </td></tr>
    <tr><td class="paramname">v</td><td>output Householder vector </td></tr>
    <tr><td class="paramname">b</td><td>beta </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00236">236</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6983ad76ea95e66ed94092bd05f44204"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::index_set_up </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting up index set of columns and rows for all columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>initialized preconditioner </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column indices </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row indices </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00211">211</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa47df1186969f6872fe0dcaf83d4982b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::init_start_inds </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>inds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_inds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes start indices of particular index set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inds</td><td>container of index sets </td></tr>
    <tr><td class="paramname">start_inds</td><td>output index set </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00165">165</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8477f662432b03c92b4287e3a4db3d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::initPreconditioner </td>
          <td>(</td>
          <td class="paramtype">SparseMatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseMatrixT &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize preconditioner with sparcity pattern = p(A) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">M</td><td>output matrix - initialized preconditioner </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-static_8hpp_source.html#l00154">154</a> of file <a class="el" href="spai-static_8hpp_source.html">spai-static.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff1616fc9ee32fd0e1d641f6d8f2ebf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixT , typename DenseMatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::initProjectSubMatrix </td>
          <td>(</td>
          <td class="paramtype">SparseMatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseMatrixT &amp;&#160;</td>
          <td class="paramname"><em>A_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a dense matrix from a sparse one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_in</td><td>Oiginal sparse matrix </td></tr>
    <tr><td class="paramname">J</td><td>Set of column indices </td></tr>
    <tr><td class="paramname">I</td><td>Set of row indices </td></tr>
    <tr><td class="paramname">A_out</td><td>dense matrix output </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00156">156</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a312ded5b57f112daa612d3b790cbc830"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixT , typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::insert_sparse_columns </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseMatrixT &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insertion of vectorized matrix column into original sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_v</td><td>column-major vectorized matrix </td></tr>
    <tr><td class="paramname">M</td><td>original sparse matrix </td></tr>
    <tr><td class="paramname">is_right</td><td>indicates if matrix should be transposed in the output </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00616">616</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea8b96ecccca6f209e810669f0d13e36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viennacl::linalg::detail::spai::is_all_update </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>parallel_is_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00443">443</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04773e48e2b2afdbeee55fdda179ff5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viennacl::linalg::detail::spai::isInIndexSet </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SizeT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if element ind is in set {J}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">J</td><td>current set </td></tr>
    <tr><td class="paramname">ind</td><td>current element </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-static_8hpp_source.html#l00072">72</a> of file <a class="el" href="spai-static_8hpp_source.html">spai-static.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a644c28fb7b3c4e677d86dc4b06388dab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::least_square_solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_matrix &amp;&#160;</td>
          <td class="paramname"><em>g_A_I_J_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_vector &amp;&#160;</td>
          <td class="paramname"><em>g_bv_vcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const spai_tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1context.html">viennacl::context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solution of Least square problem on GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column-major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>column-major vectorized sparse preconditioner matrix </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row set indices </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column set indices </td></tr>
    <tr><td class="paramname">g_A_I_J_vcl</td><td>contigious matrix that consists of blocks A(I_k, J_k) </td></tr>
    <tr><td class="paramname">g_bv_vcl</td><td>contigious vector that consists of betas, necessary for Q recovery </td></tr>
    <tr><td class="paramname">g_res</td><td>container of residuals </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with indicators which blocks are active </td></tr>
    <tr><td class="paramname">tag</td><td>spai tag </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context in which the auxiliary data is created (one out of multiple OpenCL contexts, CUDA, host) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00298">298</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18b9a595189ffa38d5acdaad6a286905"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT , typename DenseMatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::least_square_solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DenseMatrixT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_b_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spai_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solution of Least square problem on CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>column-major vectorized initial sparse matrix </td></tr>
    <tr><td class="paramname">g_R</td><td>blocks for least square solution </td></tr>
    <tr><td class="paramname">g_b_v</td><td>vectors beta, necessary for Q recovery </td></tr>
    <tr><td class="paramname">g_I</td><td>container of row index set for all columns of matrix M </td></tr>
    <tr><td class="paramname">g_J</td><td>container of column index set for all columns of matrix M </td></tr>
    <tr><td class="paramname">g_res</td><td>container of residuals </td></tr>
    <tr><td class="paramname">g_is_update</td><td>container with indicators which blocks are active </td></tr>
    <tr><td class="paramname">M_v</td><td>column-major vectorized sparse matrix, final preconditioner </td></tr>
    <tr><td class="paramname">tag</td><td>spai tag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00398">398</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75d03e25caf5c1957fab6334c0d91c31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::make_rotation_matrix </td>
          <td>(</td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>off_diagonal_distance</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="small__matrix_8hpp_source.html#l00061">61</a> of file <a class="el" href="small__matrix_8hpp_source.html">small_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa237a50ec1e8dd5e279a0fb02ff0bf8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename InputIteratorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::Print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIteratorT&#160;</td>
          <td class="paramname"><em>it_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIteratorT&#160;</td>
          <td class="paramname"><em>it_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00063">63</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7434114c0e1f546e32b4bc2a81a35ad1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::print_continious_matrix </td>
          <td>(</td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>con_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocks_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00085">85</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbff207e6f84bc89822c0eab0aea0fe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::print_continious_vector </td>
          <td>(</td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>con_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g_J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00101">101</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dca466b626554c2b42bf25b500842e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DenseMatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::print_matrix </td>
          <td>(</td>
          <td class="paramtype">DenseMatrixT &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00088">88</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5d1da881af74993b78c433286b70a00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::print_sparse_vector </td>
          <td>(</td>
          <td class="paramtype">SparseVectorT const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00081">81</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa448e23270c2fd92b9f6c9c4df359a6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::projectI </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform projection of set I on the unit-vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>set of non-zero rows </td></tr>
    <tr><td class="paramname">y</td><td>result vector </td></tr>
    <tr><td class="paramname">ind</td><td>index of unit vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-static_8hpp_source.html#l00122">122</a> of file <a class="el" href="spai-static_8hpp_source.html">spai-static.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae548ee7e9301caf3cc50ada65389bce0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::projectRows </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A_v_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row projection for matrix A(:,J) -&gt; A(I,J), building index set of non-zero rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_v_c</td><td>input matrix </td></tr>
    <tr><td class="paramname">J</td><td>set of non-zero rows </td></tr>
    <tr><td class="paramname">I</td><td>output matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-static_8hpp_source.html#l00171">171</a> of file <a class="el" href="spai-static_8hpp_source.html">spai-static.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a453c8768ecde4b09adaff9e130d8f3ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::QRBlockComposition </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A_I_J_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>A_I_u_J_u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composition of new block for QR factorization cf. Kallischko dissertation p.82, figure 4.7. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_I_J</td><td>previously composed block </td></tr>
    <tr><td class="paramname">A_I_J_u</td><td>matrix Q'*A(I, \tilde J), where \tilde J - set of new column indices </td></tr>
    <tr><td class="paramname">A_I_u_J_u</td><td>is composition of lower part A(I, \tilde J) and A(\tilde I, \tilde J) - new block for QR decomposition </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00250">250</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e707b637111b93ec04a6149aa72eac4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::single_qr </td>
          <td>(</td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>b_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inplace QR factorization via Householder reflections c.f. Gene H. Golub, Charles F. Van Loan "Matrix Computations" 3rd edition p.224. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>input matrix </td></tr>
    <tr><td class="paramname">b_v</td><td>vector of betas </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00311">311</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa76c2d795781c203de394c73c62b0420"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::sparse_inner_prod </td>
          <td>(</td>
          <td class="paramtype">SparseVectorT const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseVectorT const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;&#160;</td>
          <td class="paramname"><em>res_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot product of two sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>initial sparse vector </td></tr>
    <tr><td class="paramname">v2</td><td>initial sparse vector </td></tr>
    <tr><td class="paramname">res_v</td><td>scalar that represents dot product result </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00157">157</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76346f2d37c99cdda3737ad76942bdb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseVectorT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::sparse_norm_2 </td>
          <td>(</td>
          <td class="paramtype">SparseVectorT const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation of Euclidean norm for sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>initial sparse vector </td></tr>
    <tr><td class="paramname">norm</td><td>scalar that represents Euclidean norm </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spai-dynamic_8hpp_source.html#l00141">141</a> of file <a class="el" href="spai-dynamic_8hpp_source.html">spai-dynamic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a934fa8b447e7836d4c9be2dd40c35390"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::sparse_transpose </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposition of sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_in</td><td>intial sparse matrix </td></tr>
    <tr><td class="paramname">A</td><td>output transposed matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00640">640</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcaaf643f5b021ac04dd7690904e59f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename VectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::store_householder_vector </td>
          <td>(</td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage of vector v in column(A, ind), starting from ind-1 index of a column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>init matrix </td></tr>
    <tr><td class="paramname">ind</td><td>index of a column </td></tr>
    <tr><td class="paramname">v</td><td>vector that should be stored </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00295">295</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af1ff03eb8bd6bd2f78f4738731394f7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::sym_sparse_matrix_to_stl </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>STL_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fspai_8hpp_source.html#l00121">121</a> of file <a class="el" href="fspai_8hpp_source.html">fspai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a76d81e5a1302f9d03949ea2783ee7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixT , typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::vectorize_column_matrix </td>
          <td>(</td>
          <td class="paramtype">SparseMatrixT const &amp;&#160;</td>
          <td class="paramname"><em>M_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solution of Least square problem on CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_in</td><td>input sparse, boost::numeric::ublas::compressed_matrix </td></tr>
    <tr><td class="paramname">M_v</td><td>array of sparse vectors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00462">462</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c462e0ad109f5e23eb34982c2f91dd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixT , typename SparseVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::vectorize_row_matrix </td>
          <td>(</td>
          <td class="paramtype">SparseMatrixT const &amp;&#160;</td>
          <td class="paramname"><em>M_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseVectorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00472">472</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a511597723c2d451fda55ff4ead99eaf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::write_set_to_array </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SizeT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ind_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cl_uint &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="detail_2spai_2spai_8hpp_source.html#l00484">484</a> of file <a class="el" href="detail_2spai_2spai_8hpp_source.html">spai.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65295176395fdf1c526d3880f3d76b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorT , typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::detail::spai::write_to_block </td>
          <td>(</td>
          <td class="paramtype">VectorT &amp;&#160;</td>
          <td class="paramname"><em>con_A_I_J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="detail_2spai_2qr_8hpp_source.html#l00072">72</a> of file <a class="el" href="detail_2spai_2qr_8hpp_source.html">qr.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a></li><li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html">spai</a></li>
    <li class="footer">Generated on Wed Jan 20 2016 22:32:46 for ViennaCL - The Vienna Computing Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
