<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ViennaCL - The Vienna Computing Library: viennacl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Free open-source GPU-accelerated linear algebra and solver library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceviennacl.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceviennacl_1_1backend"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend.html">backend</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1backend"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace providing routines for handling the different memory domains. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds implementation details for functionality in the main viennacl-namespace. Not intended for direct use by library users. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1device__specific"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1device__specific.html">device_specific</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1device__specific"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an OpenCL kernel generator. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io.html">io</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides basic input-output functionality. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides all linear algebra operations which are not covered by operator overloads. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1ocl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1ocl.html">ocl</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1ocl"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenCL backend. Manages platforms, contexts, buffers, kernels, etc. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1result__of"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1result__of.html">result_of</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1result__of"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing many meta-functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1scheduler"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1scheduler.html">scheduler</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1scheduler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the scheduling functionality which allows for dynamic kernel generation as well as the fusion of multiple statements into a single kernel. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1tools"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html">tools</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1tools"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for various tools used within ViennaCL. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1traits.html">traits</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace providing traits-information as well as generic wrappers to common routines for vectors and matrices such as <a class="el" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.) ">size()</a> or <a class="el" href="namespaceviennacl_1_1traits.html#a22ab64b1df12a9da0423e5cad52ea367" title="Generic routine for setting all entries of a vector to zero. This is the version for non-ViennaCL obj...">clear()</a> <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1advanced__cuthill__mckee__tag.html">advanced_cuthill_mckee_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for the advanced Cuthill-McKee algorithm (i.e. running the 'standard' Cuthill-McKee algorithm for a couple of different seeds).  <a href="classviennacl_1_1advanced__cuthill__mckee__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1basic__range.html">basic_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range class that refers to an interval [start, stop), where 'start' is included, and 'stop' is excluded.  <a href="classviennacl_1_1basic__range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1basic__slice.html">basic_slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice class that refers to an interval [start, stop), where 'start' is included, and 'stop' is excluded.  <a href="classviennacl_1_1basic__slice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Circulant matrix class.  <a href="classviennacl_1_1circulant__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1col__iteration.html">col_iteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing columns index of a matrix.  <a href="structviennacl_1_1col__iteration.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major.html">column_major</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for column-major storage of a dense matrix.  <a href="structviennacl_1_1column__major.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major__tag.html">column_major_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for indicating column-major layout of a matrix. Not passed to the matrix directly, see <a class="el" href="structviennacl_1_1row__major.html" title="A tag for row-major storage of a dense matrix. ">row_major</a> type.  <a href="structviennacl_1_1column__major__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows carry nonzero entries.  <a href="classviennacl_1_1compressed__compressed__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix in compressed sparse rows format.  <a href="classviennacl_1_1compressed__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__entry__proxy.html">const_entry_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1const__entry__proxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated. VERY SLOW!!  <a href="classviennacl_1_1const__vector__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1context.html">context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a generic 'context' similar to an OpenCL context, but is backend-agnostic and thus also suitable for CUDA and OpenMP.  <a href="classviennacl_1_1context.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row and column indices and val denotes the entry.  <a href="classviennacl_1_1coordinate__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1cuda__not__available__exception.html">cuda_not_available_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1cuthill__mckee__tag.html">cuthill_mckee_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for selecting the Cuthill-McKee algorithm for reducing the bandwidth of a sparse matrix.  <a href="structviennacl_1_1cuthill__mckee__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix class using the ELLPACK format for storing the nonzeros.  <a href="classviennacl_1_1ell__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple enable-if variant that uses the SFINAE pattern.  <a href="structviennacl_1_1enable__if.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1entry__proxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1gibbs__poole__stockmeyer__tag.html">gibbs_poole_stockmeyer_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for identifying the Gibbs-Poole-Stockmeyer algorithm for reducing the bandwidth of a sparse matrix.  <a href="structviennacl_1_1gibbs__poole__stockmeyer__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Hankel matrix class.  <a href="classviennacl_1_1hankel__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros.  <a href="classviennacl_1_1hyb__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1identity__matrix.html">identity_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x. ">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1identity__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1implicit__matrix__base.html">implicit_matrix_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representing matrices where the individual entries are not all stored explicitly, e.g. identity_matrix&lt;&gt;  <a href="classviennacl_1_1implicit__matrix__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1implicit__vector__base.html">implicit_vector_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for representing vectors where the entries are not all stored explicitly.  <a href="classviennacl_1_1implicit__vector__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__addition.html">is_addition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is <a class="el" href="structviennacl_1_1op__add.html" title="A tag class representing addition. ">viennacl::op_add</a> (for addition)  <a href="structviennacl_1_1is__addition.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__matrix.html">is_any_dense_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for either <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a> or <a class="el" href="classviennacl_1_1implicit__matrix__base.html" title="Base class for representing matrices where the individual entries are not all stored explicitly...">implicit_matrix_base</a>.  <a href="structviennacl_1_1is__any__dense__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__structured__matrix.html">is_any_dense_structured_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether the provided type is any of the dense structured matrix types (circulant, Hankel, etc.)  <a href="structviennacl_1_1is__any__dense__structured__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__scalar.html">is_any_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether the provided type represents a scalar (either host, from ViennaCL, or a flip-sign proxy)  <a href="structviennacl_1_1is__any__scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">is_any_sparse_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether the provided type is one of the sparse matrix types (<a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a>, <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>, etc.)  <a href="structviennacl_1_1is__any__sparse__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__vector.html">is_any_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for a type being either <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a> or <a class="el" href="classviennacl_1_1implicit__vector__base.html" title="Common base class for representing vectors where the entries are not all stored explicitly. ">implicit_vector_base</a>.  <a href="structviennacl_1_1is__any__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__circulant__matrix.html">is_circulant_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a circulant matrix.  <a href="structviennacl_1_1is__circulant__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__compressed__matrix.html">is_compressed_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> (CSR format)  <a href="structviennacl_1_1is__compressed__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__coordinate__matrix.html">is_coordinate_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> (COO format)  <a href="structviennacl_1_1is__coordinate__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__cpu__scalar.html">is_cpu_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type is a host scalar type (e.g. float, double)  <a href="structviennacl_1_1is__cpu__scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__division.html">is_division</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is <a class="el" href="structviennacl_1_1op__div.html" title="A tag class representing division. ">viennacl::op_div</a> (for division)  <a href="structviennacl_1_1is__division.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__eigen.html">is_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__eigen.html" title="A tag class for identifying types from Eigen. ">tag_eigen</a>.  <a href="structviennacl_1_1is__eigen.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ell__matrix.html">is_ell_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is an <a class="el" href="classviennacl_1_1ell__matrix.html" title="Sparse matrix class using the ELLPACK format for storing the nonzeros. ">ell_matrix</a> (ELL format)  <a href="structviennacl_1_1is__ell__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__flip__sign__scalar.html">is_flip_sign_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type represents a sign flip on a viennacl::scalar&lt;&gt;  <a href="structviennacl_1_1is__flip__sign__scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hankel__matrix.html">is_hankel_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Hankel matrix.  <a href="structviennacl_1_1is__hankel__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hyb__matrix.html">is_hyb_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a> (hybrid format: ELL plus CSR)  <a href="structviennacl_1_1is__hyb__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__mtl4.html">is_mtl4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__mtl4.html" title="A tag class for identifying types from MTL4. ">tag_mtl4</a>.  <a href="structviennacl_1_1is__mtl4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__primitive__type.html">is_primitive_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a type is a primitive type.  <a href="structviennacl_1_1is__primitive__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__product.html">is_product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is <a class="el" href="structviennacl_1_1op__prod.html" title="A tag class representing matrix-vector products and element-wise multiplications. ...">viennacl::op_prod</a> (for products/multiplication)  <a href="structviennacl_1_1is__product.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__row__major.html">is_row_major</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix has a row-major layout.  <a href="structviennacl_1_1is__row__major.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type is a viennacl::scalar&lt;&gt;  <a href="structviennacl_1_1is__scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__sliced__ell__matrix.html">is_sliced_ell_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1sliced__ell__matrix.html" title="Sparse matrix class using the sliced ELLPACK with parameters C, . ">sliced_ell_matrix</a> (SELL-C- <img class="formulaInl" alt="$ \sigma $" src="form_0.png"/> format)  <a href="structviennacl_1_1is__sliced__ell__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__stl.html">is_stl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__ublas.html" title="A tag class for identifying types from uBLAS. ">tag_ublas</a>.  <a href="structviennacl_1_1is__stl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__subtraction.html">is_subtraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is <a class="el" href="structviennacl_1_1op__sub.html" title="A tag class representing subtraction. ">viennacl::op_sub</a> (for subtraction)  <a href="structviennacl_1_1is__subtraction.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__toeplitz__matrix.html">is_toeplitz_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Toeplitz matrix.  <a href="structviennacl_1_1is__toeplitz__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ublas.html">is_ublas</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__ublas.html" title="A tag class for identifying types from uBLAS. ">tag_ublas</a>.  <a href="structviennacl_1_1is__ublas.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__vandermonde__matrix.html">is_vandermonde_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Vandermonde matrix.  <a href="structviennacl_1_1is__vandermonde__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__viennacl.html">is_viennacl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__viennacl.html" title="A tag class for identifying types from ViennaCL. ">tag_viennacl</a>.  <a href="structviennacl_1_1is__viennacl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression template class for representing a tree of expressions which ultimately result in a matrix.  <a href="classviennacl_1_1matrix__expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__iterator.html">matrix_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing non-strided submatrices of a bigger matrix A.  <a href="classviennacl_1_1matrix__range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__range_3_01matrix__range_3_01_matrix_type_01_4_01_4.html">matrix_range&lt; matrix_range&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing strided submatrices of a bigger matrix A.  <a href="classviennacl_1_1matrix__slice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__slice_3_01matrix__range_3_01_matrix_type_01_4_01_4.html">matrix_slice&lt; matrix_range&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1memory__exception.html">memory_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class in case of memory errors.  <a href="classviennacl_1_1memory__exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1one__vector.html">one_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__abs.html">op_abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the modulus function for integers.  <a href="structviennacl_1_1op__abs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__acos.html">op_acos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the acos() function.  <a href="structviennacl_1_1op__acos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__add.html">op_add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing addition.  <a href="structviennacl_1_1op__add.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__argmax.html">op_argmax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for representing the argmax() function.  <a href="structviennacl_1_1op__argmax.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__argmin.html">op_argmin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for representing the argmin() function.  <a href="structviennacl_1_1op__argmin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__asin.html">op_asin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the asin() function.  <a href="structviennacl_1_1op__asin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__assign.html">op_assign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing assignment.  <a href="structviennacl_1_1op__assign.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__atan.html">op_atan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the atan() function.  <a href="structviennacl_1_1op__atan.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__atan2.html">op_atan2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the atan2() function.  <a href="structviennacl_1_1op__atan2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__ceil.html">op_ceil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the ceil() function.  <a href="structviennacl_1_1op__ceil.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__col__sum.html">op_col_sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the summation of all columns of a matrix.  <a href="structviennacl_1_1op__col__sum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__column.html">op_column</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the extraction of a matrix column to a vector.  <a href="structviennacl_1_1op__column.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__cos.html">op_cos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the cos() function.  <a href="structviennacl_1_1op__cos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__cosh.html">op_cosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the cosh() function.  <a href="structviennacl_1_1op__cosh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__div.html">op_div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing division.  <a href="structviennacl_1_1op__div.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__binary.html">op_element_binary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise binary operations (like multiplication) on vectors or matrices.  <a href="structviennacl_1_1op__element__binary.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__cast.html">op_element_cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise casting operations on vectors and matrices.  <a href="structviennacl_1_1op__element__cast.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__unary.html">op_element_unary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise unary operations (like sin()) on vectors or matrices.  <a href="structviennacl_1_1op__element__unary.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__eq.html">op_eq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing equality.  <a href="structviennacl_1_1op__eq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__exp.html">op_exp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the exp() function.  <a href="structviennacl_1_1op__exp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fabs.html">op_fabs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fabs() function.  <a href="structviennacl_1_1op__fabs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fdim.html">op_fdim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fdim() function.  <a href="structviennacl_1_1op__fdim.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__flip__sign.html">op_flip_sign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing sign flips (for scalars only. Vectors and matrices use the standard multiplication by the scalar -1.0)  <a href="structviennacl_1_1op__flip__sign.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__floor.html">op_floor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the floor() function.  <a href="structviennacl_1_1op__floor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmax.html">op_fmax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmax() function.  <a href="structviennacl_1_1op__fmax.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmin.html">op_fmin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmin() function.  <a href="structviennacl_1_1op__fmin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmod.html">op_fmod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmod() function.  <a href="structviennacl_1_1op__fmod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__geq.html">op_geq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing greater-than-or-equal-to.  <a href="structviennacl_1_1op__geq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__greater.html">op_greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing greater-than.  <a href="structviennacl_1_1op__greater.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inner__prod.html">op_inner_prod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inner products of two vectors.  <a href="structviennacl_1_1op__inner__prod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inplace__add.html">op_inplace_add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inplace addition.  <a href="structviennacl_1_1op__inplace__add.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inplace__sub.html">op_inplace_sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inplace subtraction.  <a href="structviennacl_1_1op__inplace__sub.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__leq.html">op_leq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing less-than-or-equal-to.  <a href="structviennacl_1_1op__leq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__less.html">op_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing less-than.  <a href="structviennacl_1_1op__less.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__log.html">op_log</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the log() function.  <a href="structviennacl_1_1op__log.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__log10.html">op_log10</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the log10() function.  <a href="structviennacl_1_1op__log10.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__mat__mat__prod.html">op_mat_mat_prod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing matrix-matrix products.  <a href="structviennacl_1_1op__mat__mat__prod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__matrix__diag.html">op_matrix_diag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the (off-)diagonal of a matrix.  <a href="structviennacl_1_1op__matrix__diag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__max.html">op_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the maximum of a vector.  <a href="structviennacl_1_1op__max.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__min.html">op_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the minimum of a vector.  <a href="structviennacl_1_1op__min.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__mult.html">op_mult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing multiplication by a scalar.  <a href="structviennacl_1_1op__mult.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__neq.html">op_neq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inequality.  <a href="structviennacl_1_1op__neq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__1.html">op_norm_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the 1-norm of a vector.  <a href="structviennacl_1_1op__norm__1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__2.html">op_norm_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the 2-norm of a vector.  <a href="structviennacl_1_1op__norm__2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__frobenius.html">op_norm_frobenius</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the Frobenius-norm of a matrix.  <a href="structviennacl_1_1op__norm__frobenius.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__inf.html">op_norm_inf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the inf-norm of a vector.  <a href="structviennacl_1_1op__norm__inf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__pow.html">op_pow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the power function.  <a href="structviennacl_1_1op__pow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__prod.html">op_prod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing matrix-vector products and element-wise multiplications.  <a href="structviennacl_1_1op__prod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__row.html">op_row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the extraction of a matrix row to a vector.  <a href="structviennacl_1_1op__row.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__row__sum.html">op_row_sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the summation of all rows of a matrix.  <a href="structviennacl_1_1op__row__sum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sin.html">op_sin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sin() function.  <a href="structviennacl_1_1op__sin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sinh.html">op_sinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sinh() function.  <a href="structviennacl_1_1op__sinh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sqrt.html">op_sqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sqrt() function.  <a href="structviennacl_1_1op__sqrt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sub.html">op_sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing subtraction.  <a href="structviennacl_1_1op__sub.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sum.html">op_sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the summation of a vector.  <a href="structviennacl_1_1op__sum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__tan.html">op_tan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the tan() function.  <a href="structviennacl_1_1op__tan.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__tanh.html">op_tanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the tanh() function.  <a href="structviennacl_1_1op__tanh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__trans.html">op_trans</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing transposed matrices.  <a href="structviennacl_1_1op__trans.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__vector__diag.html">op_vector_diag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a matrix given by a vector placed on a certain (off-)diagonal.  <a href="structviennacl_1_1op__vector__diag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__iteration.html">row_iteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing row index of a matrix.  <a href="structviennacl_1_1row__iteration.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major.html">row_major</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for row-major storage of a dense matrix.  <a href="structviennacl_1_1row__major.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major__tag.html">row_major_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for indicating row-major layout of a matrix. Not passed to the matrix directly, see <a class="el" href="structviennacl_1_1row__major.html" title="A tag for row-major storage of a dense matrix. ">row_major</a> type.  <a href="structviennacl_1_1row__major__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar.html">scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type like float or double.  <a href="classviennacl_1_1scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy for scalar expressions (e.g. from inner vector products)  <a href="classviennacl_1_1scalar__expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__inner__prod_01_4.html">scalar_expression&lt; LHS, RHS, op_inner_prod &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for inner products. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__inner__prod_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__max_01_4.html">scalar_expression&lt; LHS, RHS, op_max &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for <a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a5d46fe9558b0e462f10fd44942ad4fc6" title="Maximum. ">max()</a>. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__max_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__min_01_4.html">scalar_expression&lt; LHS, RHS, op_min &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_inf. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__min_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__1_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_1. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__1_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__2_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_2. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__2_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__frobenius_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_frobenius &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_frobenius. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__frobenius_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__inf_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_inf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_inf. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__inf_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__sum_01_4.html">scalar_expression&lt; LHS, RHS, op_sum &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_inf. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__sum_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__matrix.html">scalar_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x. ">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1scalar__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1scalar__vector.html">scalar_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x. ">vector_range</a>, or vector_slize only.  <a href="structviennacl_1_1scalar__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1sliced__ell__matrix.html">sliced_ell_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix class using the sliced ELLPACK with parameters C, <img class="formulaInl" alt="$ \sigma $" src="form_0.png"/>.  <a href="classviennacl_1_1sliced__ell__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__eigen.html">tag_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from Eigen.  <a href="structviennacl_1_1tag__eigen.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__mtl4.html">tag_mtl4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from MTL4.  <a href="structviennacl_1_1tag__mtl4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__none.html">tag_none</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying 'unknown' types.  <a href="structviennacl_1_1tag__none.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__stl.html">tag_stl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from the C++ STL.  <a href="structviennacl_1_1tag__stl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from uBLAS.  <a href="structviennacl_1_1tag__ublas.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__viennacl.html">tag_viennacl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from ViennaCL.  <a href="structviennacl_1_1tag__viennacl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Toeplitz matrix class.  <a href="classviennacl_1_1toeplitz__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1unit__vector.html">unit_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise.  <a href="structviennacl_1_1unit__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1unknown__norm__exception.html">unknown_norm_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Vandermonde matrix class.  <a href="classviennacl_1_1vandermonde__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for dense vectors, vector ranges, and vector slices.  <a href="classviennacl_1_1vector__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression template class that represents a binary operation that yields a vector.  <a href="classviennacl_1_1vector__expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!  <a href="classviennacl_1_1vector__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing non-strided subvectors of a bigger vector x.  <a href="classviennacl_1_1vector__range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__range_3_01vector__range_3_01_vector_type_01_4_01_4.html">vector_range&lt; vector_range&lt; VectorType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing strided subvectors of a bigger vector x.  <a href="classviennacl_1_1vector__slice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__slice_3_01vector__slice_3_01_vector_type_01_4_01_4.html">vector_slice&lt; vector_slice&lt; VectorType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple class holding pointers to multiple vectors. Mainly used as a temporary object returned from <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie()</a>.  <a href="classviennacl_1_1vector__tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__matrix.html">zero_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of zeros only. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x. ">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1zero__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__on__diagonal__exception.html">zero_on_diagonal_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1zero__vector.html">zero_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a98a0afcc513111ffa0bd138f891930df"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">vcl_size_t</a></td></tr>
<tr class="separator:a98a0afcc513111ffa0bd138f891930df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad612e26a65487b7e747c18c678ffd9"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#afad612e26a65487b7e747c18c678ffd9">vcl_ptrdiff_t</a></td></tr>
<tr class="separator:afad612e26a65487b7e747c18c678ffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92c62d9fd59870c1f6b881e391d32aa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1basic__range.html">basic_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">range</a></td></tr>
<tr class="separator:ae92c62d9fd59870c1f6b881e391d32aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa84915fbd15d5fb318c41f715c2b337"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1basic__slice.html">basic_slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">slice</a></td></tr>
<tr class="separator:aaa84915fbd15d5fb318c41f715c2b337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a00b40450b6b2fd87aad3527d9b2084b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8">memory_types</a> { <a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8a020ede27e1975479bce748e0e4ea3c7f">MEMORY_NOT_INITIALIZED</a>, 
<a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8a427356f0fb1b8d32b28f37e36b272df4">MAIN_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8adb37af613f34867568e4f6cf720c68b1">OPENCL_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8ab58facda25e2c7e20d9fe1b5e62f46d2">CUDA_MEMORY</a>
 }</td></tr>
<tr class="separator:a00b40450b6b2fd87aad3527d9b2084b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a87d41d517b3d0daca8b1536e15e6659d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87d41d517b3d0daca8b1536e15e6659d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a87d41d517b3d0daca8b1536e15e6659d">switch_memory_context</a> (T &amp;obj, <a class="el" href="classviennacl_1_1context.html">viennacl::context</a> new_ctx)</td></tr>
<tr class="memdesc:a87d41d517b3d0daca8b1536e15e6659d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic convenience routine for migrating data of an object to a new memory domain.  <a href="#a87d41d517b3d0daca8b1536e15e6659d">More...</a><br/></td></tr>
<tr class="separator:a87d41d517b3d0daca8b1536e15e6659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b7f8cf6b8864a7aa196d670481a453"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a10b7f8cf6b8864a7aa196d670481a453"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">copy</a> (std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;cpu_vec, <a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_mat)</td></tr>
<tr class="memdesc:a10b7f8cf6b8864a7aa196d670481a453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#a10b7f8cf6b8864a7aa196d670481a453">More...</a><br/></td></tr>
<tr class="separator:a10b7f8cf6b8864a7aa196d670481a453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a8609bb498019d160969fde138a0bb"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:af2a8609bb498019d160969fde138a0bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af2a8609bb498019d160969fde138a0bb">copy</a> (<a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_mat, std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;cpu_vec)</td></tr>
<tr class="memdesc:af2a8609bb498019d160969fde138a0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#af2a8609bb498019d160969fde138a0bb">More...</a><br/></td></tr>
<tr class="separator:af2a8609bb498019d160969fde138a0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebed46e25be6371fe5610f75c315afc"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </td></tr>
<tr class="memitem:aaebed46e25be6371fe5610f75c315afc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaebed46e25be6371fe5610f75c315afc">copy</a> (<a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;circ_src, MatrixT &amp;com_dst)</td></tr>
<tr class="memdesc:aaebed46e25be6371fe5610f75c315afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#aaebed46e25be6371fe5610f75c315afc">More...</a><br/></td></tr>
<tr class="separator:aaebed46e25be6371fe5610f75c315afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7efd2bd791d1d11894ed488c3751ee"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </td></tr>
<tr class="memitem:acd7efd2bd791d1d11894ed488c3751ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acd7efd2bd791d1d11894ed488c3751ee">copy</a> (MatrixT &amp;com_src, <a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;circ_dst)</td></tr>
<tr class="memdesc:acd7efd2bd791d1d11894ed488c3751ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the circulant matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#acd7efd2bd791d1d11894ed488c3751ee">More...</a><br/></td></tr>
<tr class="separator:acd7efd2bd791d1d11894ed488c3751ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620670ffc1049b66b2d51399d2c4c9ae"><td class="memTemplParams" colspan="2">template&lt;class NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a620670ffc1049b66b2d51399d2c4c9ae"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a620670ffc1049b66b2d51399d2c4c9ae">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:a620670ffc1049b66b2d51399d2c4c9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a620670ffc1049b66b2d51399d2c4c9ae">More...</a><br/></td></tr>
<tr class="separator:a620670ffc1049b66b2d51399d2c4c9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c761df7c27ca099b03b46931911648"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a99c761df7c27ca099b03b46931911648"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a99c761df7c27ca099b03b46931911648">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:a99c761df7c27ca099b03b46931911648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)  <a href="#a99c761df7c27ca099b03b46931911648">More...</a><br/></td></tr>
<tr class="separator:a99c761df7c27ca099b03b46931911648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83a1719b10d1145a9d7035487c8f2ce"><td class="memTemplParams" colspan="2">template&lt;typename SizeT , typename NumericT &gt; </td></tr>
<tr class="memitem:ab83a1719b10d1145a9d7035487c8f2ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab83a1719b10d1145a9d7035487c8f2ce">copy</a> (const std::vector&lt; std::map&lt; SizeT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:ab83a1719b10d1145a9d7035487c8f2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector<std::map<SizeT, NumericT> > to basic u...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices.  <a href="#ab83a1719b10d1145a9d7035487c8f2ce">More...</a><br/></td></tr>
<tr class="separator:ab83a1719b10d1145a9d7035487c8f2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4513747040c2f4c7951d3e866fbb7fb4"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a4513747040c2f4c7951d3e866fbb7fb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4513747040c2f4c7951d3e866fbb7fb4">copy</a> (const <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;gpu_matrix, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="memdesc:a4513747040c2f4c7951d3e866fbb7fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#a4513747040c2f4c7951d3e866fbb7fb4">More...</a><br/></td></tr>
<tr class="separator:a4513747040c2f4c7951d3e866fbb7fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33af429555220f128281e71d75932ea3"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a33af429555220f128281e71d75932ea3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a33af429555220f128281e71d75932ea3">copy</a> (const <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr class="memdesc:a33af429555220f128281e71d75932ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#a33af429555220f128281e71d75932ea3">More...</a><br/></td></tr>
<tr class="separator:a33af429555220f128281e71d75932ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e5611375f016807a103ff293d3dc8a"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:ab4e5611375f016807a103ff293d3dc8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab4e5611375f016807a103ff293d3dc8a">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:ab4e5611375f016807a103ff293d3dc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)  <a href="#ab4e5611375f016807a103ff293d3dc8a">More...</a><br/></td></tr>
<tr class="separator:ab4e5611375f016807a103ff293d3dc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa72783b1449b3eef3fc2d5bab759871"><td class="memTemplParams" colspan="2">template&lt;typename SizeT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:afa72783b1449b3eef3fc2d5bab759871"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#afa72783b1449b3eef3fc2d5bab759871">copy</a> (const std::vector&lt; std::map&lt; SizeT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:afa72783b1449b3eef3fc2d5bab759871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector<std::map<SizeT, NumericT> > to basic u...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices.  <a href="#afa72783b1449b3eef3fc2d5bab759871">More...</a><br/></td></tr>
<tr class="separator:afa72783b1449b3eef3fc2d5bab759871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee17c9f4826a3a7574c6d94fd1946c4"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:acee17c9f4826a3a7574c6d94fd1946c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acee17c9f4826a3a7574c6d94fd1946c4">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="memdesc:acee17c9f4826a3a7574c6d94fd1946c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#acee17c9f4826a3a7574c6d94fd1946c4">More...</a><br/></td></tr>
<tr class="separator:acee17c9f4826a3a7574c6d94fd1946c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae943c139b8f5faf2ca261c1a919e4d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:aeae943c139b8f5faf2ca261c1a919e4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aeae943c139b8f5faf2ca261c1a919e4d">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr class="memdesc:aeae943c139b8f5faf2ca261c1a919e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#aeae943c139b8f5faf2ca261c1a919e4d">More...</a><br/></td></tr>
<tr class="separator:aeae943c139b8f5faf2ca261c1a919e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e37765605f0b2728573419f0f6e691b"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a2e37765605f0b2728573419f0f6e691b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2e37765605f0b2728573419f0f6e691b">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;A)</td></tr>
<tr class="memdesc:a2e37765605f0b2728573419f0f6e691b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream support for <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a>. Output format is same as MATLAB, Octave, or SciPy.  <a href="#a2e37765605f0b2728573419f0f6e691b">More...</a><br/></td></tr>
<tr class="separator:a2e37765605f0b2728573419f0f6e691b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3947c4a75b60a14b7051746805e1bc47"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a3947c4a75b60a14b7051746805e1bc47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3947c4a75b60a14b7051746805e1bc47">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:a3947c4a75b60a14b7051746805e1bc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)  <a href="#a3947c4a75b60a14b7051746805e1bc47">More...</a><br/></td></tr>
<tr class="separator:a3947c4a75b60a14b7051746805e1bc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9285f6f62eebc19c0756c5a31f3806f1"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a9285f6f62eebc19c0756c5a31f3806f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9285f6f62eebc19c0756c5a31f3806f1">copy</a> (const std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:a9285f6f62eebc19c0756c5a31f3806f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device.  <a href="#a9285f6f62eebc19c0756c5a31f3806f1">More...</a><br/></td></tr>
<tr class="separator:a9285f6f62eebc19c0756c5a31f3806f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f355f732e924a4233950b0e77a14db5"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a6f355f732e924a4233950b0e77a14db5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6f355f732e924a4233950b0e77a14db5">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="memdesc:a6f355f732e924a4233950b0e77a14db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#a6f355f732e924a4233950b0e77a14db5">More...</a><br/></td></tr>
<tr class="separator:a6f355f732e924a4233950b0e77a14db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09970b6d02bfa2dd17a7d63d1fcbe18f"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a09970b6d02bfa2dd17a7d63d1fcbe18f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a09970b6d02bfa2dd17a7d63d1fcbe18f">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr class="memdesc:a09970b6d02bfa2dd17a7d63d1fcbe18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#a09970b6d02bfa2dd17a7d63d1fcbe18f">More...</a><br/></td></tr>
<tr class="separator:a09970b6d02bfa2dd17a7d63d1fcbe18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86076cab217f7a739775b848fbb2a58f"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a86076cab217f7a739775b848fbb2a58f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a86076cab217f7a739775b848fbb2a58f">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="separator:a86076cab217f7a739775b848fbb2a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94125a5d77782ecabf9896c4a7378ae6"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a94125a5d77782ecabf9896c4a7378ae6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a94125a5d77782ecabf9896c4a7378ae6">copy</a> (std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;cpu_matrix, <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:a94125a5d77782ecabf9896c4a7378ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the compute device. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#a94125a5d77782ecabf9896c4a7378ae6">More...</a><br/></td></tr>
<tr class="separator:a94125a5d77782ecabf9896c4a7378ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9b4abab4a308f6850d8a379ce9d19c"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:aeb9b4abab4a308f6850d8a379ce9d19c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aeb9b4abab4a308f6850d8a379ce9d19c">copy</a> (const <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="separator:aeb9b4abab4a308f6850d8a379ce9d19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe5d5ca06633e7eb223bc43df45351d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename IndexT &gt; </td></tr>
<tr class="memitem:adbe5d5ca06633e7eb223bc43df45351d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#adbe5d5ca06633e7eb223bc43df45351d">copy</a> (const <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr class="memdesc:adbe5d5ca06633e7eb223bc43df45351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the compute device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#adbe5d5ca06633e7eb223bc43df45351d">More...</a><br/></td></tr>
<tr class="separator:adbe5d5ca06633e7eb223bc43df45351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c1f7718f95bf4ed4cddc264b24c623"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr class="memitem:ac9c1f7718f95bf4ed4cddc264b24c623"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9c1f7718f95bf4ed4cddc264b24c623">copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr class="separator:ac9c1f7718f95bf4ed4cddc264b24c623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac6b8ed7edad298388c5936e476f783"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr class="memitem:aaac6b8ed7edad298388c5936e476f783"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaac6b8ed7edad298388c5936e476f783">copy</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr class="separator:aaac6b8ed7edad298388c5936e476f783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9139574d3d99501f0ef6c3fc322e548"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr class="memitem:ac9139574d3d99501f0ef6c3fc322e548"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9139574d3d99501f0ef6c3fc322e548">copy</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr class="separator:ac9139574d3d99501f0ef6c3fc322e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5c8726b45bc89a523ca2fa8c42107a"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr class="memitem:aaa5c8726b45bc89a523ca2fa8c42107a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaa5c8726b45bc89a523ca2fa8c42107a">fast_copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr class="separator:aaa5c8726b45bc89a523ca2fa8c42107a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3331c10c42bdec311e4c6b8665b01ac"><td class="memTemplParams" colspan="2">template&lt;typename CPU_ITERATOR , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:ab3331c10c42bdec311e4c6b8665b01ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab3331c10c42bdec311e4c6b8665b01ac">fast_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr class="separator:ab3331c10c42bdec311e4c6b8665b01ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc11117a965de33ff004e39dddb4df3"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a2fc11117a965de33ff004e39dddb4df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2fc11117a965de33ff004e39dddb4df3">copy</a> (std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;cpu_vec, <a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_mat)</td></tr>
<tr class="memdesc:a2fc11117a965de33ff004e39dddb4df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Hankel matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#a2fc11117a965de33ff004e39dddb4df3">More...</a><br/></td></tr>
<tr class="separator:a2fc11117a965de33ff004e39dddb4df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68ce4636ce26e10fd645b65c30614fb"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:ab68ce4636ce26e10fd645b65c30614fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab68ce4636ce26e10fd645b65c30614fb">copy</a> (<a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;gpu_mat, std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;cpu_vec)</td></tr>
<tr class="memdesc:ab68ce4636ce26e10fd645b65c30614fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#ab68ce4636ce26e10fd645b65c30614fb">More...</a><br/></td></tr>
<tr class="separator:ab68ce4636ce26e10fd645b65c30614fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9552fa64927a22bd0210e14021d12fe9"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </td></tr>
<tr class="memitem:a9552fa64927a22bd0210e14021d12fe9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9552fa64927a22bd0210e14021d12fe9">copy</a> (<a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;han_src, MatrixT &amp;com_dst)</td></tr>
<tr class="memdesc:a9552fa64927a22bd0210e14021d12fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#a9552fa64927a22bd0210e14021d12fe9">More...</a><br/></td></tr>
<tr class="separator:a9552fa64927a22bd0210e14021d12fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770c4f5948de36c4c343a608169c25b4"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </td></tr>
<tr class="memitem:a770c4f5948de36c4c343a608169c25b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a770c4f5948de36c4c343a608169c25b4">copy</a> (MatrixT const &amp;com_src, <a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;han_dst)</td></tr>
<tr class="memdesc:a770c4f5948de36c4c343a608169c25b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the Hankel matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#a770c4f5948de36c4c343a608169c25b4">More...</a><br/></td></tr>
<tr class="separator:a770c4f5948de36c4c343a608169c25b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc974973c62956db774c398cdc8cd7e"><td class="memTemplParams" colspan="2">template&lt;class NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:abcc974973c62956db774c398cdc8cd7e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abcc974973c62956db774c398cdc8cd7e">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="separator:abcc974973c62956db774c398cdc8cd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eccd807b53d2713366addeaf1137bae"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a3eccd807b53d2713366addeaf1137bae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3eccd807b53d2713366addeaf1137bae">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="separator:a3eccd807b53d2713366addeaf1137bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3fd50d62ce69e229ebdc92f9ddb6a6"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:aef3fd50d62ce69e229ebdc92f9ddb6a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aef3fd50d62ce69e229ebdc92f9ddb6a6">copy</a> (std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;cpu_matrix, <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:aef3fd50d62ce69e229ebdc92f9ddb6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the compute device. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#aef3fd50d62ce69e229ebdc92f9ddb6a6">More...</a><br/></td></tr>
<tr class="separator:aef3fd50d62ce69e229ebdc92f9ddb6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee077076d127c528b236cc78ff6b8bbe"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:aee077076d127c528b236cc78ff6b8bbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aee077076d127c528b236cc78ff6b8bbe">copy</a> (const <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="separator:aee077076d127c528b236cc78ff6b8bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad947ef8abf3c3cd4f69649b01ffb6d7e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename IndexT &gt; </td></tr>
<tr class="memitem:ad947ef8abf3c3cd4f69649b01ffb6d7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad947ef8abf3c3cd4f69649b01ffb6d7e">copy</a> (const <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr class="memdesc:ad947ef8abf3c3cd4f69649b01ffb6d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the compute device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#ad947ef8abf3c3cd4f69649b01ffb6d7e">More...</a><br/></td></tr>
<tr class="separator:ad947ef8abf3c3cd4f69649b01ffb6d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d5db0c2c91be75218db5b52c4d13da"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ae7d5db0c2c91be75218db5b52c4d13da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae7d5db0c2c91be75218db5b52c4d13da">cuda_arg</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:ae7d5db0c2c91be75218db5b52c4d13da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a ViennaCL scalar. Non-const version.  <a href="#ae7d5db0c2c91be75218db5b52c4d13da">More...</a><br/></td></tr>
<tr class="separator:ae7d5db0c2c91be75218db5b52c4d13da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab05a30685bca6711fe6065de6ed76cc"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aab05a30685bca6711fe6065de6ed76cc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aab05a30685bca6711fe6065de6ed76cc">cuda_arg</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;obj)</td></tr>
<tr class="memdesc:aab05a30685bca6711fe6065de6ed76cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a ViennaCL scalar. Const version.  <a href="#aab05a30685bca6711fe6065de6ed76cc">More...</a><br/></td></tr>
<tr class="separator:aab05a30685bca6711fe6065de6ed76cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad897d9d77baa2bb290b5957a3906c6c9"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad897d9d77baa2bb290b5957a3906c6c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad897d9d77baa2bb290b5957a3906c6c9">cuda_arg</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:ad897d9d77baa2bb290b5957a3906c6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a ViennaCL vector (through the base class <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a>) with implicit return type deduction. Non-const version.  <a href="#ad897d9d77baa2bb290b5957a3906c6c9">More...</a><br/></td></tr>
<tr class="separator:ad897d9d77baa2bb290b5957a3906c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac551bbc38b63d40c61e46b447055fd5d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ac551bbc38b63d40c61e46b447055fd5d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac551bbc38b63d40c61e46b447055fd5d">cuda_arg</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;obj)</td></tr>
<tr class="memdesc:ac551bbc38b63d40c61e46b447055fd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a ViennaCL vector (through the base class <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a>) with implicit return type deduction. Const version.  <a href="#ac551bbc38b63d40c61e46b447055fd5d">More...</a><br/></td></tr>
<tr class="separator:ac551bbc38b63d40c61e46b447055fd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9a9315dd46da747461f896b61e4c06"><td class="memTemplParams" colspan="2">template&lt;typename ReturnT , typename NumericT &gt; </td></tr>
<tr class="memitem:a6d9a9315dd46da747461f896b61e4c06"><td class="memTemplItemLeft" align="right" valign="top">ReturnT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6d9a9315dd46da747461f896b61e4c06">cuda_arg</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:a6d9a9315dd46da747461f896b61e4c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a ViennaCL vector (through the base class <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a>). Return type needs to be explicitly provided as first template argument. Non-const version.  <a href="#a6d9a9315dd46da747461f896b61e4c06">More...</a><br/></td></tr>
<tr class="separator:a6d9a9315dd46da747461f896b61e4c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53d32565d6525c3f15e0f115b5fc458"><td class="memTemplParams" colspan="2">template&lt;typename ReturnT , typename NumericT &gt; </td></tr>
<tr class="memitem:af53d32565d6525c3f15e0f115b5fc458"><td class="memTemplItemLeft" align="right" valign="top">const ReturnT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af53d32565d6525c3f15e0f115b5fc458">cuda_arg</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;obj)</td></tr>
<tr class="memdesc:af53d32565d6525c3f15e0f115b5fc458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a ViennaCL vector (through the base class <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a>). Return type needs to be explicitly provided as first template argument. Const version.  <a href="#af53d32565d6525c3f15e0f115b5fc458">More...</a><br/></td></tr>
<tr class="separator:af53d32565d6525c3f15e0f115b5fc458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad231fa89c1b2e9bb4354cca72a9db563"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad231fa89c1b2e9bb4354cca72a9db563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad231fa89c1b2e9bb4354cca72a9db563">cuda_arg</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:ad231fa89c1b2e9bb4354cca72a9db563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a ViennaCL matrix (through the base class <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>). Non-const version.  <a href="#ad231fa89c1b2e9bb4354cca72a9db563">More...</a><br/></td></tr>
<tr class="separator:ad231fa89c1b2e9bb4354cca72a9db563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab16b276ab2da8dcc9dc2868f7a7202"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aeab16b276ab2da8dcc9dc2868f7a7202"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aeab16b276ab2da8dcc9dc2868f7a7202">cuda_arg</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;obj)</td></tr>
<tr class="memdesc:aeab16b276ab2da8dcc9dc2868f7a7202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a ViennaCL matrix (through the base class <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>). Const version.  <a href="#aeab16b276ab2da8dcc9dc2868f7a7202">More...</a><br/></td></tr>
<tr class="separator:aeab16b276ab2da8dcc9dc2868f7a7202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de94cbf1edc144185fd87a3ec725cdb"><td class="memTemplParams" colspan="2">template&lt;typename ReturnT &gt; </td></tr>
<tr class="memitem:a0de94cbf1edc144185fd87a3ec725cdb"><td class="memTemplItemLeft" align="right" valign="top">ReturnT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0de94cbf1edc144185fd87a3ec725cdb">cuda_arg</a> (<a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">viennacl::backend::mem_handle</a> &amp;h)</td></tr>
<tr class="memdesc:a0de94cbf1edc144185fd87a3ec725cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a generic memory handle. Non-const version.  <a href="#a0de94cbf1edc144185fd87a3ec725cdb">More...</a><br/></td></tr>
<tr class="separator:a0de94cbf1edc144185fd87a3ec725cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072d41ee21cc657238022f4917b51f64"><td class="memTemplParams" colspan="2">template&lt;typename ReturnT &gt; </td></tr>
<tr class="memitem:a072d41ee21cc657238022f4917b51f64"><td class="memTemplItemLeft" align="right" valign="top">ReturnT const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a072d41ee21cc657238022f4917b51f64">cuda_arg</a> (<a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">viennacl::backend::mem_handle</a> const &amp;h)</td></tr>
<tr class="memdesc:a072d41ee21cc657238022f4917b51f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience helper function for extracting the CUDA handle from a generic memory handle. Const-version.  <a href="#a072d41ee21cc657238022f4917b51f64">More...</a><br/></td></tr>
<tr class="separator:a072d41ee21cc657238022f4917b51f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fd323314d8e60ad9cfb710f4ed1c61"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a59fd323314d8e60ad9cfb710f4ed1c61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a59fd323314d8e60ad9cfb710f4ed1c61">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:a59fd323314d8e60ad9cfb710f4ed1c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += A * v2, where A is a matrix.  <a href="#a59fd323314d8e60ad9cfb710f4ed1c61">More...</a><br/></td></tr>
<tr class="separator:a59fd323314d8e60ad9cfb710f4ed1c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a077ac0a2f14f1772505f46059ef00b"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a9a077ac0a2f14f1772505f46059ef00b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9a077ac0a2f14f1772505f46059ef00b">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:a9a077ac0a2f14f1772505f46059ef00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= A * v2, where A is a matrix.  <a href="#a9a077ac0a2f14f1772505f46059ef00b">More...</a><br/></td></tr>
<tr class="separator:a9a077ac0a2f14f1772505f46059ef00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3a8290e94b15b653b3a0f0a3f80496"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a4d3a8290e94b15b653b3a0f0a3f80496"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4d3a8290e94b15b653b3a0f0a3f80496">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:a4d3a8290e94b15b653b3a0f0a3f80496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 + A * v2', where A is a matrix.  <a href="#a4d3a8290e94b15b653b3a0f0a3f80496">More...</a><br/></td></tr>
<tr class="separator:a4d3a8290e94b15b653b3a0f0a3f80496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3693cfc246adc889875c208ca23aff"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aeb3693cfc246adc889875c208ca23aff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aeb3693cfc246adc889875c208ca23aff">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:aeb3693cfc246adc889875c208ca23aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 - A * v2', where A is a matrix.  <a href="#aeb3693cfc246adc889875c208ca23aff">More...</a><br/></td></tr>
<tr class="separator:aeb3693cfc246adc889875c208ca23aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67afbd5c480d44b908d42990d27a2996"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a67afbd5c480d44b908d42990d27a2996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a67afbd5c480d44b908d42990d27a2996">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:a67afbd5c480d44b908d42990d27a2996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += A * v2, where A is a matrix.  <a href="#a67afbd5c480d44b908d42990d27a2996">More...</a><br/></td></tr>
<tr class="separator:a67afbd5c480d44b908d42990d27a2996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc9022fc750953ad0ecf8eadd8b1793"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:adbc9022fc750953ad0ecf8eadd8b1793"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#adbc9022fc750953ad0ecf8eadd8b1793">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:adbc9022fc750953ad0ecf8eadd8b1793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= A * v2, where A is a matrix.  <a href="#adbc9022fc750953ad0ecf8eadd8b1793">More...</a><br/></td></tr>
<tr class="separator:adbc9022fc750953ad0ecf8eadd8b1793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da44f4931a9c2574fdb8a89c10e252b"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a2da44f4931a9c2574fdb8a89c10e252b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2da44f4931a9c2574fdb8a89c10e252b">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:a2da44f4931a9c2574fdb8a89c10e252b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 + A * v2', where A is a matrix.  <a href="#a2da44f4931a9c2574fdb8a89c10e252b">More...</a><br/></td></tr>
<tr class="separator:a2da44f4931a9c2574fdb8a89c10e252b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17b8034f666a89b9852d3752d08e411"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad17b8034f666a89b9852d3752d08e411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad17b8034f666a89b9852d3752d08e411">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ad17b8034f666a89b9852d3752d08e411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 - A * v2', where A is a matrix.  <a href="#ad17b8034f666a89b9852d3752d08e411">More...</a><br/></td></tr>
<tr class="separator:ad17b8034f666a89b9852d3752d08e411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee5dd77d41040e0a937a60346475b84"><td class="memTemplParams" colspan="2">template&lt;typename M1 &gt; </td></tr>
<tr class="memitem:a2ee5dd77d41040e0a937a60346475b84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; M1 &gt;::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const M1, <br class="typebreak"/>
const M1, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2ee5dd77d41040e0a937a60346475b84">trans</a> (const M1 &amp;mat)</td></tr>
<tr class="memdesc:a2ee5dd77d41040e0a937a60346475b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#a2ee5dd77d41040e0a937a60346475b84">More...</a><br/></td></tr>
<tr class="separator:a2ee5dd77d41040e0a937a60346475b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85e3912a40d5d479835e7608808f07e"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </td></tr>
<tr class="memitem:ab85e3912a40d5d479835e7608808f07e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab85e3912a40d5d479835e7608808f07e">operator+</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ab85e3912a40d5d479835e7608808f07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 + A * v2', where A is a matrix.  <a href="#ab85e3912a40d5d479835e7608808f07e">More...</a><br/></td></tr>
<tr class="separator:ab85e3912a40d5d479835e7608808f07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5309df539f189a889f45f5e25098930f"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </td></tr>
<tr class="memitem:a5309df539f189a889f45f5e25098930f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5309df539f189a889f45f5e25098930f">operator-</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="memdesc:a5309df539f189a889f45f5e25098930f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 - A * v2', where A is a matrix.  <a href="#a5309df539f189a889f45f5e25098930f">More...</a><br/></td></tr>
<tr class="separator:a5309df539f189a889f45f5e25098930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad648cd691bb8fa8358f552d00bce2946"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:ad648cd691bb8fa8358f552d00bce2946"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad648cd691bb8fa8358f552d00bce2946">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const LHS, const RHS, OP &gt; &amp;proxy)</td></tr>
<tr class="separator:ad648cd691bb8fa8358f552d00bce2946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e584237e084f29313d487917ceed47e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a5e584237e084f29313d487917ceed47e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5e584237e084f29313d487917ceed47e">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const LHS, const RHS, OP &gt; &amp;proxy)</td></tr>
<tr class="separator:a5e584237e084f29313d487917ceed47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8707f526944ee24f12c399234fed56da"><td class="memTemplParams" colspan="2">template&lt;class NumericT &gt; </td></tr>
<tr class="memitem:a8707f526944ee24f12c399234fed56da"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8707f526944ee24f12c399234fed56da">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:a8707f526944ee24f12c399234fed56da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a8707f526944ee24f12c399234fed56da">More...</a><br/></td></tr>
<tr class="separator:a8707f526944ee24f12c399234fed56da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1627d47e4b494526e0287de3ed8476"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a6c1627d47e4b494526e0287de3ed8476"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6c1627d47e4b494526e0287de3ed8476">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; &amp;expr)</td></tr>
<tr class="memdesc:a6c1627d47e4b494526e0287de3ed8476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a6c1627d47e4b494526e0287de3ed8476">More...</a><br/></td></tr>
<tr class="separator:a6c1627d47e4b494526e0287de3ed8476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf958f77e4e8b2f4235675131e391ea"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aedf958f77e4e8b2f4235675131e391ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aedf958f77e4e8b2f4235675131e391ea">trans</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat)</td></tr>
<tr class="memdesc:aedf958f77e4e8b2f4235675131e391ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#aedf958f77e4e8b2f4235675131e391ea">More...</a><br/></td></tr>
<tr class="separator:aedf958f77e4e8b2f4235675131e391ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae384d8709f16c158a5974f9eb7d5864"><td class="memTemplParams" colspan="2">template&lt;typename LhsT , typename RhsT , typename OpT &gt; </td></tr>
<tr class="memitem:aae384d8709f16c158a5974f9eb7d5864"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LhsT, <br class="typebreak"/>
const RhsT, OpT &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LhsT, <br class="typebreak"/>
const RhsT, OpT &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aae384d8709f16c158a5974f9eb7d5864">trans</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LhsT, const RhsT, OpT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:aae384d8709f16c158a5974f9eb7d5864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template class representing the transposed matrix expression.  <a href="#aae384d8709f16c158a5974f9eb7d5864">More...</a><br/></td></tr>
<tr class="separator:aae384d8709f16c158a5974f9eb7d5864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507d2ac469c79997f2bb6e82b37b7483"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a507d2ac469c79997f2bb6e82b37b7483"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
int, <a class="el" href="structviennacl_1_1op__matrix__diag.html">op_matrix_diag</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a507d2ac469c79997f2bb6e82b37b7483">diag</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, int k=0)</td></tr>
<tr class="separator:a507d2ac469c79997f2bb6e82b37b7483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a96df6ab1bb59ee2c6e540694639d27"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a0a96df6ab1bb59ee2c6e540694639d27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
int, <a class="el" href="structviennacl_1_1op__vector__diag.html">op_vector_diag</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0a96df6ab1bb59ee2c6e540694639d27">diag</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;v, int k=0)</td></tr>
<tr class="separator:a0a96df6ab1bb59ee2c6e540694639d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a574e6cd04ca0e42298b4ab845700e4"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr class="memitem:a0a574e6cd04ca0e42298b4ab845700e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F &gt;<br class="typebreak"/>
, const unsigned int, <a class="el" href="structviennacl_1_1op__row.html">op_row</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0a574e6cd04ca0e42298b4ab845700e4">row</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F &gt; &amp;A, unsigned int i)</td></tr>
<tr class="separator:a0a574e6cd04ca0e42298b4ab845700e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fca08f4a83edffe7f47666d298ca87d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr class="memitem:a7fca08f4a83edffe7f47666d298ca87d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F &gt;<br class="typebreak"/>
, const unsigned int, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__column.html">op_column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7fca08f4a83edffe7f47666d298ca87d">column</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F &gt; &amp;A, unsigned int j)</td></tr>
<tr class="separator:a7fca08f4a83edffe7f47666d298ca87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04b51b11118a495d5202f50fadd1576"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , typename F , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:aa04b51b11118a495d5202f50fadd1576"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa04b51b11118a495d5202f50fadd1576">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:aa04b51b11118a495d5202f50fadd1576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#aa04b51b11118a495d5202f50fadd1576">More...</a><br/></td></tr>
<tr class="separator:aa04b51b11118a495d5202f50fadd1576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f75fa1ed33f5ed4728e49528720999"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename A1 , typename A2 , typename F , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:af7f75fa1ed33f5ed4728e49528720999"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af7f75fa1ed33f5ed4728e49528720999">copy</a> (const std::vector&lt; std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, A1 &gt;, A2 &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:af7f75fa1ed33f5ed4728e49528720999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#af7f75fa1ed33f5ed4728e49528720999">More...</a><br/></td></tr>
<tr class="separator:af7f75fa1ed33f5ed4728e49528720999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1057a25ff074250d9dc656ebed4c606"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:af1057a25ff074250d9dc656ebed4c606"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af1057a25ff074250d9dc656ebed4c606">fast_copy</a> (<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *cpu_matrix_begin, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *cpu_matrix_end, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:af1057a25ff074250d9dc656ebed4c606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU.  <a href="#af1057a25ff074250d9dc656ebed4c606">More...</a><br/></td></tr>
<tr class="separator:af1057a25ff074250d9dc656ebed4c606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30682f75678f2f807e807e5a46be4010"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT , typename F , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a30682f75678f2f807e807e5a46be4010"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a30682f75678f2f807e807e5a46be4010">copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;gpu_matrix, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="memdesc:a30682f75678f2f807e807e5a46be4010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a30682f75678f2f807e807e5a46be4010">More...</a><br/></td></tr>
<tr class="separator:a30682f75678f2f807e807e5a46be4010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c5c22fecddcfd850aace4aa231528e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename A1 , typename A2 , typename F , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a01c5c22fecddcfd850aace4aa231528e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a01c5c22fecddcfd850aace4aa231528e">copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;gpu_matrix, std::vector&lt; std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, A1 &gt;, A2 &gt; &amp;cpu_matrix)</td></tr>
<tr class="memdesc:a01c5c22fecddcfd850aace4aa231528e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a01c5c22fecddcfd850aace4aa231528e">More...</a><br/></td></tr>
<tr class="separator:a01c5c22fecddcfd850aace4aa231528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92695ea6fa06cb0b9d940bb14080b62a"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a92695ea6fa06cb0b9d940bb14080b62a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a92695ea6fa06cb0b9d940bb14080b62a">fast_copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;gpu_matrix, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *cpu_matrix_begin)</td></tr>
<tr class="memdesc:a92695ea6fa06cb0b9d940bb14080b62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a92695ea6fa06cb0b9d940bb14080b62a">More...</a><br/></td></tr>
<tr class="separator:a92695ea6fa06cb0b9d940bb14080b62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb8b80e0a2a0c7ae9d1c6ff0ff88ade"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr class="memitem:a2fb8b80e0a2a0c7ae9d1c6ff0ff88ade"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, <br class="typebreak"/>
const RHS2, OP2 &gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2fb8b80e0a2a0c7ae9d1c6ff0ff88ade">operator+</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr class="memdesc:a2fb8b80e0a2a0c7ae9d1c6ff0ff88ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep.  <a href="#a2fb8b80e0a2a0c7ae9d1c6ff0ff88ade">More...</a><br/></td></tr>
<tr class="separator:a2fb8b80e0a2a0c7ae9d1c6ff0ff88ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99433d936260c16ae92dad64d2af42d4"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT &gt; </td></tr>
<tr class="memitem:a99433d936260c16ae92dad64d2af42d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a99433d936260c16ae92dad64d2af42d4">operator+</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;proxy2)</td></tr>
<tr class="separator:a99433d936260c16ae92dad64d2af42d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d38ab31af0e8f442a2e90fa94aed2f"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr class="memitem:a39d38ab31af0e8f442a2e90fa94aed2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, <br class="typebreak"/>
const RHS2, OP2 &gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a39d38ab31af0e8f442a2e90fa94aed2f">operator+</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr class="separator:a39d38ab31af0e8f442a2e90fa94aed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc06bea5c7f930db9ff33f0f06b37ec"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a9dc06bea5c7f930db9ff33f0f06b37ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9dc06bea5c7f930db9ff33f0f06b37ec">operator+</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;m2)</td></tr>
<tr class="memdesc:a9dc06bea5c7f930db9ff33f0f06b37ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 + m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#a9dc06bea5c7f930db9ff33f0f06b37ec">More...</a><br/></td></tr>
<tr class="separator:a9dc06bea5c7f930db9ff33f0f06b37ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073efec32bd595b7620d5ca04a0ae500"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr class="memitem:a073efec32bd595b7620d5ca04a0ae500"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, <br class="typebreak"/>
const RHS2, OP2 &gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a073efec32bd595b7620d5ca04a0ae500">operator-</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr class="separator:a073efec32bd595b7620d5ca04a0ae500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefaf3038b632cba603d17de16b2a6b95"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT &gt; </td></tr>
<tr class="memitem:aefaf3038b632cba603d17de16b2a6b95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aefaf3038b632cba603d17de16b2a6b95">operator-</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;proxy2)</td></tr>
<tr class="separator:aefaf3038b632cba603d17de16b2a6b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302aac58b4a7e6894bff2105159969cb"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr class="memitem:a302aac58b4a7e6894bff2105159969cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, <br class="typebreak"/>
const RHS2, OP2 &gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a302aac58b4a7e6894bff2105159969cb">operator-</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr class="separator:a302aac58b4a7e6894bff2105159969cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bfb1e933c577c593814b926ae405e8"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ae5bfb1e933c577c593814b926ae405e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae5bfb1e933c577c593814b926ae405e8">operator-</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;m2)</td></tr>
<tr class="memdesc:ae5bfb1e933c577c593814b926ae405e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 - m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#ae5bfb1e933c577c593814b926ae405e8">More...</a><br/></td></tr>
<tr class="separator:ae5bfb1e933c577c593814b926ae405e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61f6e7bfb0b18b8f824d12e7cb36930"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename NumericT &gt; </td></tr>
<tr class="memitem:af61f6e7bfb0b18b8f824d12e7cb36930"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af61f6e7bfb0b18b8f824d12e7cb36930">operator*</a> (S1 const &amp;value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>)</td></tr>
<tr class="memdesc:af61f6e7bfb0b18b8f824d12e7cb36930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m1 is a ViennaCL matrix.  <a href="#af61f6e7bfb0b18b8f824d12e7cb36930">More...</a><br/></td></tr>
<tr class="separator:af61f6e7bfb0b18b8f824d12e7cb36930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa850e0b2b3ff9bb2647cb536b4fffb90"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aa850e0b2b3ff9bb2647cb536b4fffb90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa850e0b2b3ff9bb2647cb536b4fffb90">operator*</a> (char value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>)</td></tr>
<tr class="memdesc:aa850e0b2b3ff9bb2647cb536b4fffb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a char (8-bit integer)  <a href="#aa850e0b2b3ff9bb2647cb536b4fffb90">More...</a><br/></td></tr>
<tr class="separator:aa850e0b2b3ff9bb2647cb536b4fffb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671309a17a97947a8f42b6f4f93d54bb"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a671309a17a97947a8f42b6f4f93d54bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a671309a17a97947a8f42b6f4f93d54bb">operator*</a> (short value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>)</td></tr>
<tr class="memdesc:a671309a17a97947a8f42b6f4f93d54bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a short integer.  <a href="#a671309a17a97947a8f42b6f4f93d54bb">More...</a><br/></td></tr>
<tr class="separator:a671309a17a97947a8f42b6f4f93d54bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d9ca3d7b57048ef270019eec4c07a"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a416d9ca3d7b57048ef270019eec4c07a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a416d9ca3d7b57048ef270019eec4c07a">operator*</a> (int value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>)</td></tr>
<tr class="memdesc:a416d9ca3d7b57048ef270019eec4c07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is an integer.  <a href="#a416d9ca3d7b57048ef270019eec4c07a">More...</a><br/></td></tr>
<tr class="separator:a416d9ca3d7b57048ef270019eec4c07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1015874fe77649ea83df1ae264f623"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:acc1015874fe77649ea83df1ae264f623"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acc1015874fe77649ea83df1ae264f623">operator*</a> (long value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>)</td></tr>
<tr class="memdesc:acc1015874fe77649ea83df1ae264f623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a long integer.  <a href="#acc1015874fe77649ea83df1ae264f623">More...</a><br/></td></tr>
<tr class="separator:acc1015874fe77649ea83df1ae264f623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6388159c0090f38d828107ce8c633e27"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a6388159c0090f38d828107ce8c633e27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6388159c0090f38d828107ce8c633e27">operator*</a> (float value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>)</td></tr>
<tr class="memdesc:a6388159c0090f38d828107ce8c633e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a single precision floating point value.  <a href="#a6388159c0090f38d828107ce8c633e27">More...</a><br/></td></tr>
<tr class="separator:a6388159c0090f38d828107ce8c633e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5d72e16ba0b866062e7365332303c3"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a5a5d72e16ba0b866062e7365332303c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5a5d72e16ba0b866062e7365332303c3">operator*</a> (double value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>)</td></tr>
<tr class="memdesc:a5a5d72e16ba0b866062e7365332303c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a double precision floating point value.  <a href="#a5a5d72e16ba0b866062e7365332303c3">More...</a><br/></td></tr>
<tr class="separator:a5a5d72e16ba0b866062e7365332303c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58516a40d21e78d01366ebf3f9b5782"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr class="memitem:ac58516a40d21e78d01366ebf3f9b5782"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac58516a40d21e78d01366ebf3f9b5782">operator*</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr class="memdesc:ac58516a40d21e78d01366ebf3f9b5782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a scalar from the right, e.g. (beta * m1) * alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the right.  <a href="#ac58516a40d21e78d01366ebf3f9b5782">More...</a><br/></td></tr>
<tr class="separator:ac58516a40d21e78d01366ebf3f9b5782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7640299a65b58b1f08ca11222a972f"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a7b7640299a65b58b1f08ca11222a972f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7b7640299a65b58b1f08ca11222a972f">operator*</a> (S1 const &amp;val, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr class="memdesc:a7b7640299a65b58b1f08ca11222a972f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a ViennaCL scalar from the left, e.g. alpha * (beta * m1). Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the left.  <a href="#a7b7640299a65b58b1f08ca11222a972f">More...</a><br/></td></tr>
<tr class="separator:a7b7640299a65b58b1f08ca11222a972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad32571551a61deceaa9624f08e2d2a"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr class="memitem:a2ad32571551a61deceaa9624f08e2d2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2ad32571551a61deceaa9624f08e2d2a">operator*</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, S1 const &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a2ad32571551a61deceaa9624f08e2d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a GPU scalar 'alpha' and returns an expression template.  <a href="#a2ad32571551a61deceaa9624f08e2d2a">More...</a><br/></td></tr>
<tr class="separator:a2ad32571551a61deceaa9624f08e2d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055e2f08b4349d16f9637e86da2eca9e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a055e2f08b4349d16f9637e86da2eca9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a055e2f08b4349d16f9637e86da2eca9e">operator*</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, char <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a055e2f08b4349d16f9637e86da2eca9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a char (8-bit integer) 'alpha' and returns an expression template.  <a href="#a055e2f08b4349d16f9637e86da2eca9e">More...</a><br/></td></tr>
<tr class="separator:a055e2f08b4349d16f9637e86da2eca9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e42e369bb6ffba830440ba2e3d66552"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a1e42e369bb6ffba830440ba2e3d66552"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1e42e369bb6ffba830440ba2e3d66552">operator*</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, short <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a1e42e369bb6ffba830440ba2e3d66552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a short integer 'alpha' and returns an expression template.  <a href="#a1e42e369bb6ffba830440ba2e3d66552">More...</a><br/></td></tr>
<tr class="separator:a1e42e369bb6ffba830440ba2e3d66552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b950ce150130705567961767bc9f93"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a71b950ce150130705567961767bc9f93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a71b950ce150130705567961767bc9f93">operator*</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, int <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a71b950ce150130705567961767bc9f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by an integer 'alpha' and returns an expression template.  <a href="#a71b950ce150130705567961767bc9f93">More...</a><br/></td></tr>
<tr class="separator:a71b950ce150130705567961767bc9f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d6119d11ee3de96a0fb1bad2cd280f"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a37d6119d11ee3de96a0fb1bad2cd280f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a37d6119d11ee3de96a0fb1bad2cd280f">operator*</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, long <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a37d6119d11ee3de96a0fb1bad2cd280f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a long integer 'alpha' and returns an expression template.  <a href="#a37d6119d11ee3de96a0fb1bad2cd280f">More...</a><br/></td></tr>
<tr class="separator:a37d6119d11ee3de96a0fb1bad2cd280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0879808120c7027251b4abb70e6163d1"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a0879808120c7027251b4abb70e6163d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0879808120c7027251b4abb70e6163d1">operator*</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, float <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a0879808120c7027251b4abb70e6163d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a single precision floating point number 'alpha' and returns an expression template.  <a href="#a0879808120c7027251b4abb70e6163d1">More...</a><br/></td></tr>
<tr class="separator:a0879808120c7027251b4abb70e6163d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd254c13a3a3dc4d50df850726bd13d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:abbd254c13a3a3dc4d50df850726bd13d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abbd254c13a3a3dc4d50df850726bd13d">operator*</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, double <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:abbd254c13a3a3dc4d50df850726bd13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a double precision floating point number 'alpha' and returns an expression template.  <a href="#abbd254c13a3a3dc4d50df850726bd13d">More...</a><br/></td></tr>
<tr class="separator:abbd254c13a3a3dc4d50df850726bd13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5f1f57f46bcf1c5949022b1600a229"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr class="memitem:a9b5f1f57f46bcf1c5949022b1600a229"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9b5f1f57f46bcf1c5949022b1600a229">operator*=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, S1 const &amp;gpu_val)</td></tr>
<tr class="memdesc:a9b5f1f57f46bcf1c5949022b1600a229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a9b5f1f57f46bcf1c5949022b1600a229">More...</a><br/></td></tr>
<tr class="separator:a9b5f1f57f46bcf1c5949022b1600a229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff5bcd6a96666051b8e45e9d0cf36a4"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:adff5bcd6a96666051b8e45e9d0cf36a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#adff5bcd6a96666051b8e45e9d0cf36a4">operator*=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, char gpu_val)</td></tr>
<tr class="memdesc:adff5bcd6a96666051b8e45e9d0cf36a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a char (8-bit) value.  <a href="#adff5bcd6a96666051b8e45e9d0cf36a4">More...</a><br/></td></tr>
<tr class="separator:adff5bcd6a96666051b8e45e9d0cf36a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2febf91d5ae8f9034f0bf913ca8f0b17"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a2febf91d5ae8f9034f0bf913ca8f0b17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2febf91d5ae8f9034f0bf913ca8f0b17">operator*=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, short gpu_val)</td></tr>
<tr class="memdesc:a2febf91d5ae8f9034f0bf913ca8f0b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a short integer value.  <a href="#a2febf91d5ae8f9034f0bf913ca8f0b17">More...</a><br/></td></tr>
<tr class="separator:a2febf91d5ae8f9034f0bf913ca8f0b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc887938113f86149365f506e29ba938"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:acc887938113f86149365f506e29ba938"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acc887938113f86149365f506e29ba938">operator*=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, int gpu_val)</td></tr>
<tr class="memdesc:acc887938113f86149365f506e29ba938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by an integer value.  <a href="#acc887938113f86149365f506e29ba938">More...</a><br/></td></tr>
<tr class="separator:acc887938113f86149365f506e29ba938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d5a2c7b8514856ee97a68dee279ac2"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a97d5a2c7b8514856ee97a68dee279ac2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a97d5a2c7b8514856ee97a68dee279ac2">operator*=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, long gpu_val)</td></tr>
<tr class="memdesc:a97d5a2c7b8514856ee97a68dee279ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a long integer value.  <a href="#a97d5a2c7b8514856ee97a68dee279ac2">More...</a><br/></td></tr>
<tr class="separator:a97d5a2c7b8514856ee97a68dee279ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dffb3b912475aa7e25494c8f75e294"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:af4dffb3b912475aa7e25494c8f75e294"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af4dffb3b912475aa7e25494c8f75e294">operator*=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, float gpu_val)</td></tr>
<tr class="memdesc:af4dffb3b912475aa7e25494c8f75e294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a single precision floating point value.  <a href="#af4dffb3b912475aa7e25494c8f75e294">More...</a><br/></td></tr>
<tr class="separator:af4dffb3b912475aa7e25494c8f75e294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13520c405e905305b396e3e861c6017a"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a13520c405e905305b396e3e861c6017a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a13520c405e905305b396e3e861c6017a">operator*=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, double gpu_val)</td></tr>
<tr class="memdesc:a13520c405e905305b396e3e861c6017a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a double precision floating point value.  <a href="#a13520c405e905305b396e3e861c6017a">More...</a><br/></td></tr>
<tr class="separator:a13520c405e905305b396e3e861c6017a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6c40bbe0d9ca6f3f39d349639247c5"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr class="memitem:a1a6c40bbe0d9ca6f3f39d349639247c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1a6c40bbe0d9ca6f3f39d349639247c5">operator/</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr class="memdesc:a1a6c40bbe0d9ca6f3f39d349639247c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then divided by alpha.  <a href="#a1a6c40bbe0d9ca6f3f39d349639247c5">More...</a><br/></td></tr>
<tr class="separator:a1a6c40bbe0d9ca6f3f39d349639247c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60bf08e0585fc5feea364450e696558"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr class="memitem:aa60bf08e0585fc5feea364450e696558"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa60bf08e0585fc5feea364450e696558">operator/</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, S1 const &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:aa60bf08e0585fc5feea364450e696558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a GPU scalar 'alpha'.  <a href="#aa60bf08e0585fc5feea364450e696558">More...</a><br/></td></tr>
<tr class="separator:aa60bf08e0585fc5feea364450e696558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaca8fd86909b87757f7c1f2ff837092"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aeaca8fd86909b87757f7c1f2ff837092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aeaca8fd86909b87757f7c1f2ff837092">operator/</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, char <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:aeaca8fd86909b87757f7c1f2ff837092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a char (8-bit integer) 'alpha'.  <a href="#aeaca8fd86909b87757f7c1f2ff837092">More...</a><br/></td></tr>
<tr class="separator:aeaca8fd86909b87757f7c1f2ff837092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bb4021955c62357d76faf3a02e8fae"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ad1bb4021955c62357d76faf3a02e8fae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad1bb4021955c62357d76faf3a02e8fae">operator/</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, short <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:ad1bb4021955c62357d76faf3a02e8fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a short integer 'alpha'.  <a href="#ad1bb4021955c62357d76faf3a02e8fae">More...</a><br/></td></tr>
<tr class="separator:ad1bb4021955c62357d76faf3a02e8fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aa835a6184c0ef7858c4c5ee316b78"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a03aa835a6184c0ef7858c4c5ee316b78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a03aa835a6184c0ef7858c4c5ee316b78">operator/</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, int <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a03aa835a6184c0ef7858c4c5ee316b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by an integer 'alpha'.  <a href="#a03aa835a6184c0ef7858c4c5ee316b78">More...</a><br/></td></tr>
<tr class="separator:a03aa835a6184c0ef7858c4c5ee316b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095183526f991e43f8de21b7305f795e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a095183526f991e43f8de21b7305f795e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a095183526f991e43f8de21b7305f795e">operator/</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, long <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a095183526f991e43f8de21b7305f795e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a long integer 'alpha'.  <a href="#a095183526f991e43f8de21b7305f795e">More...</a><br/></td></tr>
<tr class="separator:a095183526f991e43f8de21b7305f795e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14d7130f2bf7648805ed09381263928"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ae14d7130f2bf7648805ed09381263928"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae14d7130f2bf7648805ed09381263928">operator/</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, float <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:ae14d7130f2bf7648805ed09381263928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a single precision floating point number 'alpha'.  <a href="#ae14d7130f2bf7648805ed09381263928">More...</a><br/></td></tr>
<tr class="separator:ae14d7130f2bf7648805ed09381263928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af4240e12b959b38134593d41bb49d1"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a5af4240e12b959b38134593d41bb49d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <br class="typebreak"/>
<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5af4240e12b959b38134593d41bb49d1">operator/</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, double <a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a5af4240e12b959b38134593d41bb49d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a double precision floating point number 'alpha'.  <a href="#a5af4240e12b959b38134593d41bb49d1">More...</a><br/></td></tr>
<tr class="separator:a5af4240e12b959b38134593d41bb49d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ab804469ebfdb77ad70c1cc0d7b2f9"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr class="memitem:a43ab804469ebfdb77ad70c1cc0d7b2f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a43ab804469ebfdb77ad70c1cc0d7b2f9">operator/=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, S1 const &amp;gpu_val)</td></tr>
<tr class="memdesc:a43ab804469ebfdb77ad70c1cc0d7b2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a43ab804469ebfdb77ad70c1cc0d7b2f9">More...</a><br/></td></tr>
<tr class="separator:a43ab804469ebfdb77ad70c1cc0d7b2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1be36347ee913ccefc9d42c9dbdd361"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aa1be36347ee913ccefc9d42c9dbdd361"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa1be36347ee913ccefc9d42c9dbdd361">operator/=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, char gpu_val)</td></tr>
<tr class="memdesc:aa1be36347ee913ccefc9d42c9dbdd361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a char (8-bit integer) value.  <a href="#aa1be36347ee913ccefc9d42c9dbdd361">More...</a><br/></td></tr>
<tr class="separator:aa1be36347ee913ccefc9d42c9dbdd361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683bc846ab01fff154ca436e3e0af161"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a683bc846ab01fff154ca436e3e0af161"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a683bc846ab01fff154ca436e3e0af161">operator/=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, short gpu_val)</td></tr>
<tr class="memdesc:a683bc846ab01fff154ca436e3e0af161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a short integer value.  <a href="#a683bc846ab01fff154ca436e3e0af161">More...</a><br/></td></tr>
<tr class="separator:a683bc846ab01fff154ca436e3e0af161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29579b205318b44886a3cc868feb064"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aa29579b205318b44886a3cc868feb064"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa29579b205318b44886a3cc868feb064">operator/=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, int gpu_val)</td></tr>
<tr class="memdesc:aa29579b205318b44886a3cc868feb064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by an integer value.  <a href="#aa29579b205318b44886a3cc868feb064">More...</a><br/></td></tr>
<tr class="separator:aa29579b205318b44886a3cc868feb064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbba4a1bd56d554ffa10e722c22e337"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a3dbba4a1bd56d554ffa10e722c22e337"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3dbba4a1bd56d554ffa10e722c22e337">operator/=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, long gpu_val)</td></tr>
<tr class="memdesc:a3dbba4a1bd56d554ffa10e722c22e337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a long integer value.  <a href="#a3dbba4a1bd56d554ffa10e722c22e337">More...</a><br/></td></tr>
<tr class="separator:a3dbba4a1bd56d554ffa10e722c22e337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dfc9998c7ae7a39d2c26dc35fb02d1"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a40dfc9998c7ae7a39d2c26dc35fb02d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a40dfc9998c7ae7a39d2c26dc35fb02d1">operator/=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, float gpu_val)</td></tr>
<tr class="memdesc:a40dfc9998c7ae7a39d2c26dc35fb02d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a single precision floating point value.  <a href="#a40dfc9998c7ae7a39d2c26dc35fb02d1">More...</a><br/></td></tr>
<tr class="separator:a40dfc9998c7ae7a39d2c26dc35fb02d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b752094b8c244a080136cdd5e2f271"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:af6b752094b8c244a080136cdd5e2f271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af6b752094b8c244a080136cdd5e2f271">operator/=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;<a class="el" href="global__variables_8cpp.html#a89b4bc8b54dcd52b589217c5ba927b38">m1</a>, double gpu_val)</td></tr>
<tr class="memdesc:af6b752094b8c244a080136cdd5e2f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a double precision floating point value.  <a href="#af6b752094b8c244a080136cdd5e2f271">More...</a><br/></td></tr>
<tr class="separator:af6b752094b8c244a080136cdd5e2f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e47d6dce13c75a6b32d792cd854ffa"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr class="memitem:ac3e47d6dce13c75a6b32d792cd854ffa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac3e47d6dce13c75a6b32d792cd854ffa">operator*</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy, const S1 &amp;val)</td></tr>
<tr class="separator:ac3e47d6dce13c75a6b32d792cd854ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e1cf3b5bddbb11b2500599ac6343b7"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr class="memitem:ad0e1cf3b5bddbb11b2500599ac6343b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__cpu__scalar.html">viennacl::is_cpu_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad0e1cf3b5bddbb11b2500599ac6343b7">operator*</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy, const S1 &amp;val)</td></tr>
<tr class="separator:ad0e1cf3b5bddbb11b2500599ac6343b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886d3a303d99d70d54820473e1349757"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr class="memitem:a886d3a303d99d70d54820473e1349757"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a886d3a303d99d70d54820473e1349757">operator*</a> (const S1 &amp;val, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="separator:a886d3a303d99d70d54820473e1349757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0da914c1ab007cc95f3dceed9eedab7"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr class="memitem:aa0da914c1ab007cc95f3dceed9eedab7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__cpu__scalar.html">viennacl::is_cpu_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa0da914c1ab007cc95f3dceed9eedab7">operator*</a> (const S1 &amp;val, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr class="separator:aa0da914c1ab007cc95f3dceed9eedab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591856f7f277d0cfe1d88f8157b74b7e"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a591856f7f277d0cfe1d88f8157b74b7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a591856f7f277d0cfe1d88f8157b74b7e">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; &amp;gpu_matrix_range)</td></tr>
<tr class="separator:a591856f7f277d0cfe1d88f8157b74b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8af211ade14d32939de1ab88fbfce3"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a5a8af211ade14d32939de1ab88fbfce3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5a8af211ade14d32939de1ab88fbfce3">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; &amp;gpu_matrix_range)</td></tr>
<tr class="separator:a5a8af211ade14d32939de1ab88fbfce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638aa5c54fe703aac75a9613b6fa992a"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a638aa5c54fe703aac75a9613b6fa992a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a638aa5c54fe703aac75a9613b6fa992a">copy</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_range, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="separator:a638aa5c54fe703aac75a9613b6fa992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b5ce1b764503f97c07405b6a937fc7"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a99b5ce1b764503f97c07405b6a937fc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a99b5ce1b764503f97c07405b6a937fc7">copy</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_range, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="separator:a99b5ce1b764503f97c07405b6a937fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc45a895937fe299100e2b235a442748"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:adc45a895937fe299100e2b235a442748"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#adc45a895937fe299100e2b235a442748">project</a> (MatrixType const &amp;A, <a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;r2)</td></tr>
<tr class="separator:adc45a895937fe299100e2b235a442748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d33198f0cc7b3e811381c65dc497632"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a3d33198f0cc7b3e811381c65dc497632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3d33198f0cc7b3e811381c65dc497632">project</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt; const &amp;A, <a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;r2)</td></tr>
<tr class="separator:a3d33198f0cc7b3e811381c65dc497632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c2dc32899cf921fc088bb5dd591e3f"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a32c2dc32899cf921fc088bb5dd591e3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a32c2dc32899cf921fc088bb5dd591e3f">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; &amp;gpu_matrix_slice)</td></tr>
<tr class="separator:a32c2dc32899cf921fc088bb5dd591e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8943b9e05480eb6b7bcd11a0061912e3"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a8943b9e05480eb6b7bcd11a0061912e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8943b9e05480eb6b7bcd11a0061912e3">copy</a> (const CPUMatrixT &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; &amp;gpu_matrix_slice)</td></tr>
<tr class="separator:a8943b9e05480eb6b7bcd11a0061912e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2902ac57885aecf018516bc72fbab09"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:af2902ac57885aecf018516bc72fbab09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af2902ac57885aecf018516bc72fbab09">copy</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="separator:af2902ac57885aecf018516bc72fbab09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784184338e26686e21bdf43d66c875ac"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename NumericT &gt; </td></tr>
<tr class="memitem:a784184338e26686e21bdf43d66c875ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a784184338e26686e21bdf43d66c875ac">copy</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPUMatrixT &amp;cpu_matrix)</td></tr>
<tr class="separator:a784184338e26686e21bdf43d66c875ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c089715c733e9e42ac80ee5fc99e29"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ae9c089715c733e9e42ac80ee5fc99e29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae9c089715c733e9e42ac80ee5fc99e29">project</a> (MatrixType const &amp;A, <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;r2)</td></tr>
<tr class="separator:ae9c089715c733e9e42ac80ee5fc99e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9683f0ed709a227c267e33b3195ec2"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:afa9683f0ed709a227c267e33b3195ec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#afa9683f0ed709a227c267e33b3195ec2">project</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt; const &amp;A, <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;r2)</td></tr>
<tr class="separator:afa9683f0ed709a227c267e33b3195ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0d5a12b085b5909596f1d754f0c9e3"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a5d0d5a12b085b5909596f1d754f0c9e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5d0d5a12b085b5909596f1d754f0c9e3">project</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt; const &amp;A, <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;r2)</td></tr>
<tr class="separator:a5d0d5a12b085b5909596f1d754f0c9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22338e452cee008bee5e38070ddc611"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename ValueT &gt; </td></tr>
<tr class="memitem:af22338e452cee008bee5e38070ddc611"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; IndexT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af22338e452cee008bee5e38070ddc611">reorder</a> (std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="structviennacl_1_1cuthill__mckee__tag.html">cuthill_mckee_tag</a>)</td></tr>
<tr class="memdesc:af22338e452cee008bee5e38070ddc611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the Cuthill-McKee algorithm.  <a href="#af22338e452cee008bee5e38070ddc611">More...</a><br/></td></tr>
<tr class="separator:af22338e452cee008bee5e38070ddc611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032f691cd245d13b51b951f8a10825f3"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename ValueT &gt; </td></tr>
<tr class="memitem:a032f691cd245d13b51b951f8a10825f3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; IndexT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a032f691cd245d13b51b951f8a10825f3">reorder</a> (std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="classviennacl_1_1advanced__cuthill__mckee__tag.html">advanced_cuthill_mckee_tag</a> const &amp;tag)</td></tr>
<tr class="memdesc:a032f691cd245d13b51b951f8a10825f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the advanced Cuthill-McKee algorithm.  <a href="#a032f691cd245d13b51b951f8a10825f3">More...</a><br/></td></tr>
<tr class="separator:a032f691cd245d13b51b951f8a10825f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec126e71833e0756286cbf8cd036fbd"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:acec126e71833e0756286cbf8cd036fbd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acec126e71833e0756286cbf8cd036fbd">reorder</a> (MatrixType const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="structviennacl_1_1gibbs__poole__stockmeyer__tag.html">gibbs_poole_stockmeyer_tag</a>)</td></tr>
<tr class="memdesc:acec126e71833e0756286cbf8cd036fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for the calculation of a node numbering permutation vector to reduce the bandwidth of a incidence matrix by the Gibbs-Poole-Stockmeyer algorithm.  <a href="#acec126e71833e0756286cbf8cd036fbd">More...</a><br/></td></tr>
<tr class="separator:acec126e71833e0756286cbf8cd036fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd36bb3a442eb6ef1ade2aad14be5ff9"><td class="memTemplParams" colspan="2">template&lt;class NumericT &gt; </td></tr>
<tr class="memitem:acd36bb3a442eb6ef1ade2aad14be5ff9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acd36bb3a442eb6ef1ade2aad14be5ff9">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:acd36bb3a442eb6ef1ade2aad14be5ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to directly print the value of a scalar to an output stream.  <a href="#acd36bb3a442eb6ef1ade2aad14be5ff9">More...</a><br/></td></tr>
<tr class="separator:acd36bb3a442eb6ef1ade2aad14be5ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60033f942852a5e462d920c62eeaced9"><td class="memTemplParams" colspan="2">template&lt;class NumericT &gt; </td></tr>
<tr class="memitem:a60033f942852a5e462d920c62eeaced9"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a60033f942852a5e462d920c62eeaced9">operator&gt;&gt;</a> (std::istream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:a60033f942852a5e462d920c62eeaced9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to directly read a value of a scalar from an input stream.  <a href="#a60033f942852a5e462d920c62eeaced9">More...</a><br/></td></tr>
<tr class="separator:a60033f942852a5e462d920c62eeaced9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fb810a020b6bd780ee1e12e6d02763"><td class="memTemplParams" colspan="2">template&lt;typename CPUMatrixT , typename ScalarT , typename IndexT &gt; </td></tr>
<tr class="memitem:a40fb810a020b6bd780ee1e12e6d02763"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a40fb810a020b6bd780ee1e12e6d02763">copy</a> (CPUMatrixT const &amp;cpu_matrix, <a class="el" href="classviennacl_1_1sliced__ell__matrix.html">sliced_ell_matrix</a>&lt; ScalarT, IndexT &gt; &amp;gpu_matrix)</td></tr>
<tr class="separator:a40fb810a020b6bd780ee1e12e6d02763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bf9bf2d8e0714db63fc999000c1510"><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename NumericT , typename IndexT2 &gt; </td></tr>
<tr class="memitem:ab1bf9bf2d8e0714db63fc999000c1510"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab1bf9bf2d8e0714db63fc999000c1510">copy</a> (std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;cpu_matrix, <a class="el" href="classviennacl_1_1sliced__ell__matrix.html">sliced_ell_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, IndexT2 &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:ab1bf9bf2d8e0714db63fc999000c1510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the compute device. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#ab1bf9bf2d8e0714db63fc999000c1510">More...</a><br/></td></tr>
<tr class="separator:ab1bf9bf2d8e0714db63fc999000c1510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa608856aa45efa0252105174c1e0a63d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:aa608856aa45efa0252105174c1e0a63d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa608856aa45efa0252105174c1e0a63d">copy</a> (std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;cpu_vec, <a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_mat)</td></tr>
<tr class="memdesc:aa608856aa45efa0252105174c1e0a63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Toeplitz matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#aa608856aa45efa0252105174c1e0a63d">More...</a><br/></td></tr>
<tr class="separator:aa608856aa45efa0252105174c1e0a63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7e1dff63f0868e785113fb6553addd"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:aac7e1dff63f0868e785113fb6553addd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aac7e1dff63f0868e785113fb6553addd">copy</a> (<a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;gpu_mat, std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;cpu_vec)</td></tr>
<tr class="memdesc:aac7e1dff63f0868e785113fb6553addd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#aac7e1dff63f0868e785113fb6553addd">More...</a><br/></td></tr>
<tr class="separator:aac7e1dff63f0868e785113fb6553addd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa275ef815673673afe615439a6e7dd"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </td></tr>
<tr class="memitem:affa275ef815673673afe615439a6e7dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#affa275ef815673673afe615439a6e7dd">copy</a> (<a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;tep_src, MatrixT &amp;com_dst)</td></tr>
<tr class="memdesc:affa275ef815673673afe615439a6e7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#affa275ef815673673afe615439a6e7dd">More...</a><br/></td></tr>
<tr class="separator:affa275ef815673673afe615439a6e7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbbb1aee9a7a2b8a0cd85c049cad89a"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </td></tr>
<tr class="memitem:aacbbb1aee9a7a2b8a0cd85c049cad89a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aacbbb1aee9a7a2b8a0cd85c049cad89a">copy</a> (MatrixT const &amp;com_src, <a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;tep_dst)</td></tr>
<tr class="memdesc:aacbbb1aee9a7a2b8a0cd85c049cad89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#aacbbb1aee9a7a2b8a0cd85c049cad89a">More...</a><br/></td></tr>
<tr class="separator:aacbbb1aee9a7a2b8a0cd85c049cad89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece37a39663683a2bf4fe18d6f372e86"><td class="memTemplParams" colspan="2">template&lt;class NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:aece37a39663683a2bf4fe18d6f372e86"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aece37a39663683a2bf4fe18d6f372e86">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:aece37a39663683a2bf4fe18d6f372e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#aece37a39663683a2bf4fe18d6f372e86">More...</a><br/></td></tr>
<tr class="separator:aece37a39663683a2bf4fe18d6f372e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06747c63171a7638f834fd8a6fb3207e"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a06747c63171a7638f834fd8a6fb3207e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a06747c63171a7638f834fd8a6fb3207e">copy</a> (std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;cpu_vec, <a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_mat)</td></tr>
<tr class="memdesc:a06747c63171a7638f834fd8a6fb3207e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Vandermonde matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#a06747c63171a7638f834fd8a6fb3207e">More...</a><br/></td></tr>
<tr class="separator:a06747c63171a7638f834fd8a6fb3207e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e63a1fcca02e42105e4f5c0d7383f3"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a78e63a1fcca02e42105e4f5c0d7383f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a78e63a1fcca02e42105e4f5c0d7383f3">copy</a> (<a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_mat, std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;cpu_vec)</td></tr>
<tr class="memdesc:a78e63a1fcca02e42105e4f5c0d7383f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#a78e63a1fcca02e42105e4f5c0d7383f3">More...</a><br/></td></tr>
<tr class="separator:a78e63a1fcca02e42105e4f5c0d7383f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1646248bf267396ba95ead1854a32a1"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </td></tr>
<tr class="memitem:ab1646248bf267396ba95ead1854a32a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab1646248bf267396ba95ead1854a32a1">copy</a> (<a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;vander_src, MatrixT &amp;com_dst)</td></tr>
<tr class="memdesc:ab1646248bf267396ba95ead1854a32a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#ab1646248bf267396ba95ead1854a32a1">More...</a><br/></td></tr>
<tr class="separator:ab1646248bf267396ba95ead1854a32a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36cc0adb8fc00e408f5ff6286528fb4"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </td></tr>
<tr class="memitem:aa36cc0adb8fc00e408f5ff6286528fb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa36cc0adb8fc00e408f5ff6286528fb4">copy</a> (MatrixT &amp;com_src, <a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;vander_dst)</td></tr>
<tr class="memdesc:aa36cc0adb8fc00e408f5ff6286528fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#aa36cc0adb8fc00e408f5ff6286528fb4">More...</a><br/></td></tr>
<tr class="separator:aa36cc0adb8fc00e408f5ff6286528fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc953b0fbe9aecdf03f3c02f730b1028"><td class="memTemplParams" colspan="2">template&lt;class NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:adc953b0fbe9aecdf03f3c02f730b1028"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#adc953b0fbe9aecdf03f3c02f730b1028">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_matrix)</td></tr>
<tr class="memdesc:adc953b0fbe9aecdf03f3c02f730b1028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#adc953b0fbe9aecdf03f3c02f730b1028">More...</a><br/></td></tr>
<tr class="separator:adc953b0fbe9aecdf03f3c02f730b1028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c575b08038eb6af18fe1b89e4022ba"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr class="memitem:a18c575b08038eb6af18fe1b89e4022ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:a18c575b08038eb6af18fe1b89e4022ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25260434dfe3c4c527fd2a9ae437685"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr class="memitem:ab25260434dfe3c4c527fd2a9ae437685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab25260434dfe3c4c527fd2a9ae437685">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>)</td></tr>
<tr class="separator:ab25260434dfe3c4c527fd2a9ae437685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee58be5508bb77871fc653aa8b33f3e2"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr class="memitem:aee58be5508bb77871fc653aa8b33f3e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aee58be5508bb77871fc653aa8b33f3e2">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="separator:aee58be5508bb77871fc653aa8b33f3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eeda7139441461f48c7303ad1b4b44"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr class="memitem:a56eeda7139441461f48c7303ad1b4b44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a56eeda7139441461f48c7303ad1b4b44">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="separator:a56eeda7139441461f48c7303ad1b4b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d28ebaf25043e36652c5ef210d405a"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr class="memitem:ae7d28ebaf25043e36652c5ef210d405a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae7d28ebaf25043e36652c5ef210d405a">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v3)</td></tr>
<tr class="separator:ae7d28ebaf25043e36652c5ef210d405a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0250b6a52a40df48e3ee18f1db6e4747"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr class="memitem:a0250b6a52a40df48e3ee18f1db6e4747"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0250b6a52a40df48e3ee18f1db6e4747">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v3)</td></tr>
<tr class="separator:a0250b6a52a40df48e3ee18f1db6e4747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e40b38f92dd9f2b23f8fa134da43204"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr class="memitem:a8e40b38f92dd9f2b23f8fa134da43204"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8e40b38f92dd9f2b23f8fa134da43204">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v3, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v4)</td></tr>
<tr class="separator:a8e40b38f92dd9f2b23f8fa134da43204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96d28a81e8e227f2678360fbdd92ae1"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr class="memitem:ac96d28a81e8e227f2678360fbdd92ae1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac96d28a81e8e227f2678360fbdd92ae1">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v3, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v4)</td></tr>
<tr class="separator:ac96d28a81e8e227f2678360fbdd92ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a958e9ed4987dfc5cbd784b84f91d01"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </td></tr>
<tr class="memitem:a5a958e9ed4987dfc5cbd784b84f91d01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5a958e9ed4987dfc5cbd784b84f91d01">fast_copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr class="memdesc:a5a958e9ed4987dfc5cbd784b84f91d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a5a958e9ed4987dfc5cbd784b84f91d01">More...</a><br/></td></tr>
<tr class="separator:a5a958e9ed4987dfc5cbd784b84f91d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18efe971cc5df1ca97ca63bf7565a8ed"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename CPUVECTOR &gt; </td></tr>
<tr class="memitem:a18efe971cc5df1ca97ca63bf7565a8ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a18efe971cc5df1ca97ca63bf7565a8ed">fast_copy</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr class="memdesc:a18efe971cc5df1ca97ca63bf7565a8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#a18efe971cc5df1ca97ca63bf7565a8ed">More...</a><br/></td></tr>
<tr class="separator:a18efe971cc5df1ca97ca63bf7565a8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d7d74290f43e613e35d19e6f522e4f"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </td></tr>
<tr class="memitem:a26d7d74290f43e613e35d19e6f522e4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a26d7d74290f43e613e35d19e6f522e4f">async_copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr class="memdesc:a26d7d74290f43e613e35d19e6f522e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous version of <a class="el" href="namespaceviennacl.html#aaa5c8726b45bc89a523ca2fa8c42107a">fast_copy()</a>, copying data from device to host. The host iterator cpu_begin needs to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a26d7d74290f43e613e35d19e6f522e4f">More...</a><br/></td></tr>
<tr class="separator:a26d7d74290f43e613e35d19e6f522e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad588773086ec291f43d382f023648166"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename CPUVECTOR &gt; </td></tr>
<tr class="memitem:ad588773086ec291f43d382f023648166"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad588773086ec291f43d382f023648166">async_copy</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr class="memdesc:ad588773086ec291f43d382f023648166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#ad588773086ec291f43d382f023648166">More...</a><br/></td></tr>
<tr class="separator:ad588773086ec291f43d382f023648166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c98e44b7ee336fa2eb4a6312b80cd6"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </td></tr>
<tr class="memitem:ad6c98e44b7ee336fa2eb4a6312b80cd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad6c98e44b7ee336fa2eb4a6312b80cd6">copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr class="memdesc:ad6c98e44b7ee336fa2eb4a6312b80cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#ad6c98e44b7ee336fa2eb4a6312b80cd6">More...</a><br/></td></tr>
<tr class="separator:ad6c98e44b7ee336fa2eb4a6312b80cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba314ca5441ee215d3adc77eafe529b"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </td></tr>
<tr class="memitem:abba314ca5441ee215d3adc77eafe529b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abba314ca5441ee215d3adc77eafe529b">copy</a> (const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr class="memdesc:abba314ca5441ee215d3adc77eafe529b"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#abba314ca5441ee215d3adc77eafe529b">More...</a><br/></td></tr>
<tr class="separator:abba314ca5441ee215d3adc77eafe529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d005b9f0d205c14417da3dbdaff0f7"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename CPUVECTOR &gt; </td></tr>
<tr class="memitem:a41d005b9f0d205c14417da3dbdaff0f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a41d005b9f0d205c14417da3dbdaff0f7">copy</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr class="memdesc:a41d005b9f0d205c14417da3dbdaff0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#a41d005b9f0d205c14417da3dbdaff0f7">More...</a><br/></td></tr>
<tr class="separator:a41d005b9f0d205c14417da3dbdaff0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0192b3236f8f4962a208af7e139e22"><td class="memTemplParams" colspan="2">template&lt;typename CPU_ITERATOR , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a6c0192b3236f8f4962a208af7e139e22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6c0192b3236f8f4962a208af7e139e22">fast_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; gpu_begin)</td></tr>
<tr class="memdesc:a6c0192b3236f8f4962a208af7e139e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a6c0192b3236f8f4962a208af7e139e22">More...</a><br/></td></tr>
<tr class="separator:a6c0192b3236f8f4962a208af7e139e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19621895b23c45e932e4ce15d947b311"><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename NumericT &gt; </td></tr>
<tr class="memitem:a19621895b23c45e932e4ce15d947b311"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a19621895b23c45e932e4ce15d947b311">fast_copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;gpu_vec)</td></tr>
<tr class="memdesc:a19621895b23c45e932e4ce15d947b311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#a19621895b23c45e932e4ce15d947b311">More...</a><br/></td></tr>
<tr class="separator:a19621895b23c45e932e4ce15d947b311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78227cb6e54e83e2db36ee870773a87d"><td class="memTemplParams" colspan="2">template&lt;typename CPU_ITERATOR , typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a78227cb6e54e83e2db36ee870773a87d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a78227cb6e54e83e2db36ee870773a87d">async_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; gpu_begin)</td></tr>
<tr class="memdesc:a78227cb6e54e83e2db36ee870773a87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous version of <a class="el" href="namespaceviennacl.html#aaa5c8726b45bc89a523ca2fa8c42107a">fast_copy()</a>, copying data from host to device. The host iterator cpu_begin needs to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a78227cb6e54e83e2db36ee870773a87d">More...</a><br/></td></tr>
<tr class="separator:a78227cb6e54e83e2db36ee870773a87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac9f2de1a2a22c01d1993b2e28f16d9"><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename NumericT &gt; </td></tr>
<tr class="memitem:aaac9f2de1a2a22c01d1993b2e28f16d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaac9f2de1a2a22c01d1993b2e28f16d9">async_copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;gpu_vec)</td></tr>
<tr class="memdesc:aaac9f2de1a2a22c01d1993b2e28f16d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#aaac9f2de1a2a22c01d1993b2e28f16d9">More...</a><br/></td></tr>
<tr class="separator:aaac9f2de1a2a22c01d1993b2e28f16d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d083febe39561a435e4972b2d8db1d"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </td></tr>
<tr class="memitem:a40d083febe39561a435e4972b2d8db1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a40d083febe39561a435e4972b2d8db1d">copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; gpu_begin)</td></tr>
<tr class="memdesc:a40d083febe39561a435e4972b2d8db1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#a40d083febe39561a435e4972b2d8db1d">More...</a><br/></td></tr>
<tr class="separator:a40d083febe39561a435e4972b2d8db1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644f179cf3142e732c3c57155d73609a"><td class="memTemplParams" colspan="2">template&lt;typename HostVectorT , typename T &gt; </td></tr>
<tr class="memitem:a644f179cf3142e732c3c57155d73609a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a644f179cf3142e732c3c57155d73609a">copy</a> (HostVectorT const &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;gpu_vec)</td></tr>
<tr class="memdesc:a644f179cf3142e732c3c57155d73609a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a host vector object to a ViennaCL vector proxy. Requires the vector proxy to have the necessary size. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#a644f179cf3142e732c3c57155d73609a">More...</a><br/></td></tr>
<tr class="separator:a644f179cf3142e732c3c57155d73609a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1180fcee62a05d6ec83caf121ee066a5"><td class="memTemplParams" colspan="2">template&lt;typename HostVectorT , typename T , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a1180fcee62a05d6ec83caf121ee066a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1180fcee62a05d6ec83caf121ee066a5">copy</a> (HostVectorT const &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; T, AlignmentV &gt; &amp;gpu_vec)</td></tr>
<tr class="memdesc:a1180fcee62a05d6ec83caf121ee066a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a host vector object to a ViennaCL vector. Resizes the ViennaCL vector if it has zero size. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#a1180fcee62a05d6ec83caf121ee066a5">More...</a><br/></td></tr>
<tr class="separator:a1180fcee62a05d6ec83caf121ee066a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1255fc3e9f9e4d920310e23e19ac0144"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV_SRC, unsigned int AlignmentV_DEST&gt; </td></tr>
<tr class="memitem:a1255fc3e9f9e4d920310e23e19ac0144"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1255fc3e9f9e4d920310e23e19ac0144">copy</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_DEST &gt; gpu_dest_begin)</td></tr>
<tr class="memdesc:a1255fc3e9f9e4d920310e23e19ac0144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#a1255fc3e9f9e4d920310e23e19ac0144">More...</a><br/></td></tr>
<tr class="separator:a1255fc3e9f9e4d920310e23e19ac0144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2540759a464fce64f568ea509d85e24"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV_SRC, unsigned int AlignmentV_DEST&gt; </td></tr>
<tr class="memitem:af2540759a464fce64f568ea509d85e24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af2540759a464fce64f568ea509d85e24">copy</a> (<a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_DEST &gt; gpu_dest_begin)</td></tr>
<tr class="memdesc:af2540759a464fce64f568ea509d85e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#af2540759a464fce64f568ea509d85e24">More...</a><br/></td></tr>
<tr class="separator:af2540759a464fce64f568ea509d85e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7fbf624c47329c1a37ba7eef778262"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV_SRC, unsigned int AlignmentV_DEST&gt; </td></tr>
<tr class="memitem:a4e7fbf624c47329c1a37ba7eef778262"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4e7fbf624c47329c1a37ba7eef778262">copy</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;gpu_src_vec, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_DEST &gt; &amp;gpu_dest_vec)</td></tr>
<tr class="memdesc:a4e7fbf624c47329c1a37ba7eef778262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a ViennaCL vector to another ViennaCL vector. Convenience wrapper for viennacl::linalg::copy(gpu_src_vec.begin(), gpu_src_vec.end(), gpu_dest_vec.begin());.  <a href="#a4e7fbf624c47329c1a37ba7eef778262">More...</a><br/></td></tr>
<tr class="separator:a4e7fbf624c47329c1a37ba7eef778262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab305fb97f519cb1280277cf830e3dfce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab305fb97f519cb1280277cf830e3dfce"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab305fb97f519cb1280277cf830e3dfce">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;val)</td></tr>
<tr class="memdesc:ab305fb97f519cb1280277cf830e3dfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream. Output format is ublas compatible.  <a href="#ab305fb97f519cb1280277cf830e3dfce">More...</a><br/></td></tr>
<tr class="separator:ab305fb97f519cb1280277cf830e3dfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21669e48cbc9c19811088f65b1162c1c"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a21669e48cbc9c19811088f65b1162c1c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a21669e48cbc9c19811088f65b1162c1c">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr class="separator:a21669e48cbc9c19811088f65b1162c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49233dc20718f52e98e8b06e9711b375"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49233dc20718f52e98e8b06e9711b375"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a49233dc20718f52e98e8b06e9711b375">swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2)</td></tr>
<tr class="memdesc:a49233dc20718f52e98e8b06e9711b375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two vectors, data is copied.  <a href="#a49233dc20718f52e98e8b06e9711b375">More...</a><br/></td></tr>
<tr class="separator:a49233dc20718f52e98e8b06e9711b375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495321f19d07b98a5ba433332cb590da"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int AlignmentV&gt; </td></tr>
<tr class="memitem:a495321f19d07b98a5ba433332cb590da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a495321f19d07b98a5ba433332cb590da">fast_swap</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="memdesc:a495321f19d07b98a5ba433332cb590da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied.  <a href="#a495321f19d07b98a5ba433332cb590da">More...</a><br/></td></tr>
<tr class="separator:a495321f19d07b98a5ba433332cb590da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54c9bbd40b29f875b0068db0fc194a5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr class="memitem:ad54c9bbd40b29f875b0068db0fc194a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad54c9bbd40b29f875b0068db0fc194a5">operator*=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, S1 const &amp;gpu_val)</td></tr>
<tr class="memdesc:ad54c9bbd40b29f875b0068db0fc194a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector by a GPU scalar value.  <a href="#ad54c9bbd40b29f875b0068db0fc194a5">More...</a><br/></td></tr>
<tr class="separator:ad54c9bbd40b29f875b0068db0fc194a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8d4647a330937c4cc44359b8ec8f52"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr class="memitem:a4e8d4647a330937c4cc44359b8ec8f52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4e8d4647a330937c4cc44359b8ec8f52">operator/=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, S1 const &amp;gpu_val)</td></tr>
<tr class="memdesc:a4e8d4647a330937c4cc44359b8ec8f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector by a GPU scalar value.  <a href="#a4e8d4647a330937c4cc44359b8ec8f52">More...</a><br/></td></tr>
<tr class="separator:a4e8d4647a330937c4cc44359b8ec8f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99420063bb11e696007951f6c3208fd"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr class="memitem:ab99420063bb11e696007951f6c3208fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; LHS2, RHS2, OP2 &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab99420063bb11e696007951f6c3208fd">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr class="memdesc:ab99420063bb11e696007951f6c3208fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of two vector expressions.  <a href="#ab99420063bb11e696007951f6c3208fd">More...</a><br/></td></tr>
<tr class="separator:ab99420063bb11e696007951f6c3208fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b8516e207086b374e91ce5ca292dca"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a30b8516e207086b374e91ce5ca292dca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a30b8516e207086b374e91ce5ca292dca">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a30b8516e207086b374e91ce5ca292dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#a30b8516e207086b374e91ce5ca292dca">More...</a><br/></td></tr>
<tr class="separator:a30b8516e207086b374e91ce5ca292dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789f52510dc1628aafde1fe379ca1001"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a789f52510dc1628aafde1fe379ca1001"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, <a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a789f52510dc1628aafde1fe379ca1001">operator+</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr class="memdesc:a789f52510dc1628aafde1fe379ca1001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector with a vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#a789f52510dc1628aafde1fe379ca1001">More...</a><br/></td></tr>
<tr class="separator:a789f52510dc1628aafde1fe379ca1001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2471d058da27c2588866407382060cc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2471d058da27c2588866407382060cc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2471d058da27c2588866407382060cc0">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="memdesc:a2471d058da27c2588866407382060cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template object for adding up two vectors, i.e. v1 + v2.  <a href="#a2471d058da27c2588866407382060cc0">More...</a><br/></td></tr>
<tr class="separator:a2471d058da27c2588866407382060cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9b799cd9d2b4ae4376c5216d5ac93f"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr class="memitem:a0a9b799cd9d2b4ae4376c5216d5ac93f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; LHS2, RHS2, OP2 &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0a9b799cd9d2b4ae4376c5216d5ac93f">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr class="memdesc:a0a9b799cd9d2b4ae4376c5216d5ac93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the subtraction of two vector expressions.  <a href="#a0a9b799cd9d2b4ae4376c5216d5ac93f">More...</a><br/></td></tr>
<tr class="separator:a0a9b799cd9d2b4ae4376c5216d5ac93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dc7568bb713236e55439611520a74d"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:ad7dc7568bb713236e55439611520a74d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad7dc7568bb713236e55439611520a74d">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:ad7dc7568bb713236e55439611520a74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#ad7dc7568bb713236e55439611520a74d">More...</a><br/></td></tr>
<tr class="separator:ad7dc7568bb713236e55439611520a74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d0f226493902ad3c4cf69eb05b3f48"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a46d0f226493902ad3c4cf69eb05b3f48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, <a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a46d0f226493902ad3c4cf69eb05b3f48">operator-</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr class="memdesc:a46d0f226493902ad3c4cf69eb05b3f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#a46d0f226493902ad3c4cf69eb05b3f48">More...</a><br/></td></tr>
<tr class="separator:a46d0f226493902ad3c4cf69eb05b3f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a0eb807884794e795aec5ec78353a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2a0eb807884794e795aec5ec78353a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab2a0eb807884794e795aec5ec78353a4">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="memdesc:ab2a0eb807884794e795aec5ec78353a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template object for subtracting two vectors, i.e. v1 - v2.  <a href="#ab2a0eb807884794e795aec5ec78353a4">More...</a><br/></td></tr>
<tr class="separator:ab2a0eb807884794e795aec5ec78353a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3c224d905d0e584fb72e566ed64977"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename T &gt; </td></tr>
<tr class="memitem:a5f3c224d905d0e584fb72e566ed64977"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5f3c224d905d0e584fb72e566ed64977">operator*</a> (S1 const &amp;value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a5f3c224d905d0e584fb72e566ed64977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector.  <a href="#a5f3c224d905d0e584fb72e566ed64977">More...</a><br/></td></tr>
<tr class="separator:a5f3c224d905d0e584fb72e566ed64977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa648c88a546872e66f73ae6b6f8c84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1aa648c88a546872e66f73ae6b6f8c84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1aa648c88a546872e66f73ae6b6f8c84">operator*</a> (char value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a1aa648c88a546872e66f73ae6b6f8c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a char.  <a href="#a1aa648c88a546872e66f73ae6b6f8c84">More...</a><br/></td></tr>
<tr class="separator:a1aa648c88a546872e66f73ae6b6f8c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6a0765c929401a06741a1c837a7af3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f6a0765c929401a06741a1c837a7af3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5f6a0765c929401a06741a1c837a7af3">operator*</a> (short value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a5f6a0765c929401a06741a1c837a7af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a short.  <a href="#a5f6a0765c929401a06741a1c837a7af3">More...</a><br/></td></tr>
<tr class="separator:a5f6a0765c929401a06741a1c837a7af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f54b5071fc459f13261a08c0ea6ee5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53f54b5071fc459f13261a08c0ea6ee5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a53f54b5071fc459f13261a08c0ea6ee5">operator*</a> (int value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a53f54b5071fc459f13261a08c0ea6ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a int.  <a href="#a53f54b5071fc459f13261a08c0ea6ee5">More...</a><br/></td></tr>
<tr class="separator:a53f54b5071fc459f13261a08c0ea6ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902d3e1f3473a758e15b232f07e7b11e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a902d3e1f3473a758e15b232f07e7b11e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a902d3e1f3473a758e15b232f07e7b11e">operator*</a> (long value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a902d3e1f3473a758e15b232f07e7b11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a long.  <a href="#a902d3e1f3473a758e15b232f07e7b11e">More...</a><br/></td></tr>
<tr class="separator:a902d3e1f3473a758e15b232f07e7b11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b11d21434d517b5c4d8603493932d4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b11d21434d517b5c4d8603493932d4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7b11d21434d517b5c4d8603493932d4a">operator*</a> (float value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a7b11d21434d517b5c4d8603493932d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a float.  <a href="#a7b11d21434d517b5c4d8603493932d4a">More...</a><br/></td></tr>
<tr class="separator:a7b11d21434d517b5c4d8603493932d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c30c728d36beb46da292e2a3aad436"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2c30c728d36beb46da292e2a3aad436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab2c30c728d36beb46da292e2a3aad436">operator*</a> (double value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:ab2c30c728d36beb46da292e2a3aad436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a double.  <a href="#ab2c30c728d36beb46da292e2a3aad436">More...</a><br/></td></tr>
<tr class="separator:ab2c30c728d36beb46da292e2a3aad436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34b0528ba9cb2a8e586a64bafc3a1b1"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:ac34b0528ba9cb2a8e586a64bafc3a1b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac34b0528ba9cb2a8e586a64bafc3a1b1">operator*</a> (<a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a>&lt; LHS, RHS, OP &gt; const &amp;expr, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:ac34b0528ba9cb2a8e586a64bafc3a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a scalar expression and v1 is a ViennaCL vector.  <a href="#ac34b0528ba9cb2a8e586a64bafc3a1b1">More...</a><br/></td></tr>
<tr class="separator:ac34b0528ba9cb2a8e586a64bafc3a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b79b9c7e7b0c0d4e838a6a8727c34e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr class="memitem:a64b79b9c7e7b0c0d4e838a6a8727c34e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a64b79b9c7e7b0c0d4e838a6a8727c34e">operator*</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, S1 const &amp;value)</td></tr>
<tr class="memdesc:a64b79b9c7e7b0c0d4e838a6a8727c34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the vector by a scalar 'alpha' and returns an expression template.  <a href="#a64b79b9c7e7b0c0d4e838a6a8727c34e">More...</a><br/></td></tr>
<tr class="separator:a64b79b9c7e7b0c0d4e838a6a8727c34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595de671ea4e3f2b0bb5eebb01458168"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a595de671ea4e3f2b0bb5eebb01458168"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a595de671ea4e3f2b0bb5eebb01458168">operator*</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T const &amp;value)</td></tr>
<tr class="separator:a595de671ea4e3f2b0bb5eebb01458168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92923ca916177c1864962bfb1443622"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr class="memitem:aa92923ca916177c1864962bfb1443622"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa92923ca916177c1864962bfb1443622">operator*</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr class="memdesc:aa92923ca916177c1864962bfb1443622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector. ">vector_expression</a> and then multiplied with alpha from the right.  <a href="#aa92923ca916177c1864962bfb1443622">More...</a><br/></td></tr>
<tr class="separator:aa92923ca916177c1864962bfb1443622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d86b7600ba400a9c865a5c23093254"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:af9d86b7600ba400a9c865a5c23093254"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af9d86b7600ba400a9c865a5c23093254">operator*</a> (S1 const &amp;val, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr class="memdesc:af9d86b7600ba400a9c865a5c23093254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector. ">vector_expression</a> and then multiplied with alpha from the left.  <a href="#af9d86b7600ba400a9c865a5c23093254">More...</a><br/></td></tr>
<tr class="separator:af9d86b7600ba400a9c865a5c23093254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810958ed96dd36b31993919612fa85d2"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a810958ed96dd36b31993919612fa85d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a810958ed96dd36b31993919612fa85d2">operator/</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr class="memdesc:a810958ed96dd36b31993919612fa85d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector. ">vector_expression</a> and then divided by alpha.  <a href="#a810958ed96dd36b31993919612fa85d2">More...</a><br/></td></tr>
<tr class="separator:a810958ed96dd36b31993919612fa85d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af63f5e1e3c138c901f53562d22ba18"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr class="memitem:a8af63f5e1e3c138c901f53562d22ba18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8af63f5e1e3c138c901f53562d22ba18">operator/</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, S1 const &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="memdesc:a8af63f5e1e3c138c901f53562d22ba18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the vector by a GPU scalar 'alpha'.  <a href="#a8af63f5e1e3c138c901f53562d22ba18">More...</a><br/></td></tr>
<tr class="separator:a8af63f5e1e3c138c901f53562d22ba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fe3d7623af671fc541309f49011a18"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename NumericT &gt; </td></tr>
<tr class="memitem:a86fe3d7623af671fc541309f49011a18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a86fe3d7623af671fc541309f49011a18">copy</a> (const VectorType &amp;cpu_vector, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;gpu_vector_range)</td></tr>
<tr class="separator:a86fe3d7623af671fc541309f49011a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff87e6c12c0c4774fb92fa88e0c44806"><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename VectorType &gt; </td></tr>
<tr class="memitem:aff87e6c12c0c4774fb92fa88e0c44806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aff87e6c12c0c4774fb92fa88e0c44806">fast_copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt; &amp;gpu_vec)</td></tr>
<tr class="memdesc:aff87e6c12c0c4774fb92fa88e0c44806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#aff87e6c12c0c4774fb92fa88e0c44806">More...</a><br/></td></tr>
<tr class="separator:aff87e6c12c0c4774fb92fa88e0c44806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973a57be69fbaeecbf8ea71c749e1a48"><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename VectorType &gt; </td></tr>
<tr class="memitem:a973a57be69fbaeecbf8ea71c749e1a48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a973a57be69fbaeecbf8ea71c749e1a48">copy</a> (<a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;gpu_vector_range, VectorType &amp;cpu_vector)</td></tr>
<tr class="separator:a973a57be69fbaeecbf8ea71c749e1a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9afcfdb40091e366e2160d1e47bd2b"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename CPUVECTOR &gt; </td></tr>
<tr class="memitem:a7f9afcfdb40091e366e2160d1e47bd2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7f9afcfdb40091e366e2160d1e47bd2b">fast_copy</a> (<a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr class="memdesc:a7f9afcfdb40091e366e2160d1e47bd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a GPU vector range to a CPU vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#a7f9afcfdb40091e366e2160d1e47bd2b">More...</a><br/></td></tr>
<tr class="separator:a7f9afcfdb40091e366e2160d1e47bd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ee402303952a729fdd80e43ba7a069"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a89ee402303952a729fdd80e43ba7a069"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a89ee402303952a729fdd80e43ba7a069">project</a> (VectorType const &amp;vec, <a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;r1)</td></tr>
<tr class="separator:a89ee402303952a729fdd80e43ba7a069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212372cdbfca6aa45055ca3249d63649"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a212372cdbfca6aa45055ca3249d63649"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a212372cdbfca6aa45055ca3249d63649">project</a> (<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;vec, <a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;r1)</td></tr>
<tr class="separator:a212372cdbfca6aa45055ca3249d63649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48aab4f03a1cc65d7601f1db982e87f"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename NumericT &gt; </td></tr>
<tr class="memitem:aa48aab4f03a1cc65d7601f1db982e87f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa48aab4f03a1cc65d7601f1db982e87f">copy</a> (const VectorType &amp;cpu_vector, <a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;gpu_vector_slice)</td></tr>
<tr class="separator:aa48aab4f03a1cc65d7601f1db982e87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4171b2d0fb71c42ecdd32c9ed34451"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename NumericT &gt; </td></tr>
<tr class="memitem:adc4171b2d0fb71c42ecdd32c9ed34451"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#adc4171b2d0fb71c42ecdd32c9ed34451">copy</a> (<a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;gpu_vector_slice, VectorType &amp;cpu_vector)</td></tr>
<tr class="separator:adc4171b2d0fb71c42ecdd32c9ed34451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a676db96fd05c12757bde89bec72f5"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ab4a676db96fd05c12757bde89bec72f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab4a676db96fd05c12757bde89bec72f5">project</a> (VectorType const &amp;vec, <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="separator:ab4a676db96fd05c12757bde89bec72f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54949548426c32cb2b7f651e41497ef"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ae54949548426c32cb2b7f651e41497ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae54949548426c32cb2b7f651e41497ef">project</a> (<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;vec, <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="separator:ae54949548426c32cb2b7f651e41497ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecb157ae33461b467d43a6b6eb3edd1"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:abecb157ae33461b467d43a6b6eb3edd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abecb157ae33461b467d43a6b6eb3edd1">project</a> (<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;vec, <a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;r1)</td></tr>
<tr class="separator:abecb157ae33461b467d43a6b6eb3edd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9ebd03331219bc6a77724dab6c2c16"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a6c9ebd03331219bc6a77724dab6c2c16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6c9ebd03331219bc6a77724dab6c2c16">project</a> (<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;vec, <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;<a class="el" href="global__variables_8cpp.html#a24573a2e279db4db9228d18dfbf27eae">s1</a>)</td></tr>
<tr class="separator:a6c9ebd03331219bc6a77724dab6c2c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ae92c62d9fd59870c1f6b881e391d32aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1basic__range.html">basic_range</a> <a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="least-squares_8cpp-example.html#a8">least-squares.cpp</a>, <a class="el" href="matrix-range_8cpp-example.html#a3">matrix-range.cpp</a>, and <a class="el" href="vector-range_8cpp-example.html#a3">vector-range.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="forwards_8h_source.html#l00424">424</a> of file <a class="el" href="forwards_8h_source.html">forwards.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaa84915fbd15d5fb318c41f715c2b337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1basic__slice.html">basic_slice</a> <a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="forwards_8h_source.html#l00429">429</a> of file <a class="el" href="forwards_8h_source.html">forwards.h</a>.</p>

</div>
</div>
<a class="anchor" id="afad612e26a65487b7e747c18c678ffd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="namespaceviennacl.html#afad612e26a65487b7e747c18c678ffd9">viennacl::vcl_ptrdiff_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="forwards_8h_source.html#l00076">76</a> of file <a class="el" href="forwards_8h_source.html">forwards.h</a>.</p>

</div>
</div>
<a class="anchor" id="a98a0afcc513111ffa0bd138f891930df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">viennacl::vcl_size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="forwards_8h_source.html#l00075">75</a> of file <a class="el" href="forwards_8h_source.html">forwards.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a00b40450b6b2fd87aad3527d9b2084b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8">viennacl::memory_types</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a00b40450b6b2fd87aad3527d9b2084b8a020ede27e1975479bce748e0e4ea3c7f"></a>MEMORY_NOT_INITIALIZED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a00b40450b6b2fd87aad3527d9b2084b8a427356f0fb1b8d32b28f37e36b272df4"></a>MAIN_MEMORY&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a00b40450b6b2fd87aad3527d9b2084b8adb37af613f34867568e4f6cf720c68b1"></a>OPENCL_MEMORY&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a00b40450b6b2fd87aad3527d9b2084b8ab58facda25e2c7e20d9fe1b5e62f46d2"></a>CUDA_MEMORY&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="forwards_8h_source.html#l00345">345</a> of file <a class="el" href="forwards_8h_source.html">forwards.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a26d7d74290f43e613e35d19e6f522e4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::async_copy </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous version of <a class="el" href="namespaceviennacl.html#aaa5c8726b45bc89a523ca2fa8c42107a">fast_copy()</a>, copying data from device to host. The host iterator cpu_begin needs to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method allows for overlapping data transfer with host computation and returns immediately if the gpu vector has a unit-stride. In order to wait for the transfer to complete, use <a class="el" href="namespaceviennacl_1_1backend.html#a3707340b27c535438e213e3879b0f0a4" title="Synchronizes the execution. finish() will only return after all compute kernels (CUDA, OpenCL) have completed. ">viennacl::backend::finish()</a>. Note that data pointed to by cpu_begin must not be modified prior to completion of the transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01284">1284</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad588773086ec291f43d382f023648166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename CPUVECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::async_copy </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector. </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator pointing to entries linear in memory can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01309">1309</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78227cb6e54e83e2db36ee870773a87d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPU_ITERATOR , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::async_copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous version of <a class="el" href="namespaceviennacl.html#aaa5c8726b45bc89a523ca2fa8c42107a">fast_copy()</a>, copying data from host to device. The host iterator cpu_begin needs to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method allows for overlapping data transfer with host computation and returns immediately if the gpu vector has a unit-stride. In order to wait for the transfer to complete, use <a class="el" href="namespaceviennacl_1_1backend.html#a3707340b27c535438e213e3879b0f0a4" title="Synchronizes the execution. finish() will only return after all compute kernels (CUDA, OpenCL) have completed. ">viennacl::backend::finish()</a>. Note that data pointed to by cpu_begin must not be modified prior to completion of the transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_begin</td><td>CPU iterator pointing to the beginning of the cpu vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_end</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_begin</td><td>Output iterator for the gpu vector. The gpu iterator must be incrementable (cpu_end - cpu_begin) times, otherwise the result is undefined. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01450">1450</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaac9f2de1a2a22c01d1993b2e28f16d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUVECTOR , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::async_copy </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01475">1475</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7fca08f4a83edffe7f47666d298ca87d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F&gt;, const unsigned int, <a class="el" href="structviennacl_1_1op__column.html">op_column</a>&gt; viennacl::column </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lanczos_8cpp-example.html#a11">lanczos.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00918">918</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3947c4a75b60a14b7051746805e1bc47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU) </p>
<p>For the requirements on the CPUMatrixT type, see the documentation of the function copy(CPUMatrixT, compressed_matrix&lt;&gt;)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="coordinate__matrix_8hpp_source.html#l00047">47</a> of file <a class="el" href="coordinate__matrix_8hpp_source.html">coordinate_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86fe3d7623af671fc541309f49011a18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_range&lt; vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00103">103</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9285f6f62eebc19c0756c5a31f3806f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse square matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="coordinate__matrix_8hpp_source.html#l00110">110</a> of file <a class="el" href="coordinate__matrix_8hpp_source.html">coordinate_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4e5611375f016807a103ff293d3dc8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU) </p>
<p>There are some type requirements on the CPUMatrixT type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.) ">size1()</a> returns the number of rows</li>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">size2()</a> returns the number of columns</li>
<li>const_iterator1 is a type definition for an iterator along increasing row indices</li>
<li>const_iterator2 is a type definition for an iterator along increasing columns indices</li>
<li>The const_iterator1 type provides an iterator of type const_iterator2 via members .begin() and .end() that iterates along column indices in the current row.</li>
<li>The types const_iterator1 and const_iterator2 provide members functions .index1() and .index2() that return the current row and column indices respectively.</li>
<li>Dereferenciation of an object of type const_iterator2 returns the entry.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compressed__matrix_8hpp_source.html#l00112">112</a> of file <a class="el" href="compressed__matrix_8hpp_source.html">compressed_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99c761df7c27ca099b03b46931911648"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU) </p>
<p>There are some type requirements on the CPUMatrixT type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.) ">size1()</a> returns the number of rows</li>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">size2()</a> returns the number of columns</li>
<li>const_iterator1 is a type definition for an iterator along increasing row indices</li>
<li>const_iterator2 is a type definition for an iterator along increasing columns indices</li>
<li>The const_iterator1 type provides an iterator of type const_iterator2 via members .begin() and .end() that iterates along column indices in the current row.</li>
<li>The types const_iterator1 and const_iterator2 provide members functions .index1() and .index2() that return the current row and column indices respectively.</li>
<li>Dereferenciation of an object of type const_iterator2 returns the entry.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows c...">compressed_compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compressed__compressed__matrix_8hpp_source.html#l00115">115</a> of file <a class="el" href="compressed__compressed__matrix_8hpp_source.html">compressed_compressed_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86076cab217f7a739775b848fbb2a58f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ell_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ell__matrix_8hpp_source.html#l00124">124</a> of file <a class="el" href="ell__matrix_8hpp_source.html">ell_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f355f732e924a4233950b0e77a14db5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPUMatrixT type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="coordinate__matrix_8hpp_source.html#l00134">134</a> of file <a class="el" href="coordinate__matrix_8hpp_source.html">coordinate_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a973a57be69fbaeecbf8ea71c749e1a48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vector_range&lt; vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00135">135</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3eccd807b53d2713366addeaf1137bae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyb_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hyb__matrix_8hpp_source.html#l00136">136</a> of file <a class="el" href="hyb__matrix_8hpp_source.html">hyb_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40fb810a020b6bd780ee1e12e6d02763"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename ScalarT , typename IndexT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">CPUMatrixT const &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sliced_ell_matrix&lt; ScalarT, IndexT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sliced__ell__matrix_8hpp_source.html#l00141">141</a> of file <a class="el" href="sliced__ell__matrix_8hpp_source.html">sliced_ell_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a591856f7f277d0cfe1d88f8157b74b7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_range&lt; matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, row_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00147">147</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06747c63171a7638f834fd8a6fb3207e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vandermonde_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a Vandermonde matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class. ">vandermonde_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vandermonde__matrix_8hpp_source.html#l00148">148</a> of file <a class="el" href="vandermonde__matrix_8hpp_source.html">vandermonde_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fc11117a965de33ff004e39dddb4df3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hankel_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a Hankel matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class. ">hankel_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hankel__matrix_8hpp_source.html#l00148">148</a> of file <a class="el" href="hankel__matrix_8hpp_source.html">hankel_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa72783b1449b3eef3fc2d5bab759871"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; SizeT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector<std::map<SizeT, NumericT> > to basic u...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse square matrix on the host using STL types </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compressed__matrix_8hpp_source.html#l00149">149</a> of file <a class="el" href="compressed__matrix_8hpp_source.html">compressed_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10b7f8cf6b8864a7aa196d670481a453"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">circulant_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class. ">circulant_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="amg_8cpp-example.html#a24">amg.cpp</a>, <a class="el" href="armadillo-with-viennacl_8cpp-example.html#a3">armadillo-with-viennacl.cpp</a>, <a class="el" href="blas1_8cpp-example.html#a7">blas1.cpp</a>, <a class="el" href="blas2_8cpp-example.html#a5">blas2.cpp</a>, <a class="el" href="blas3_8cpp-example.html#a15">blas3.cpp</a>, <a class="el" href="eigen-with-viennacl_8cpp-example.html#a3">eigen-with-viennacl.cpp</a>, <a class="el" href="iterative-custom_8cpp-example.html#a6">iterative-custom.cpp</a>, <a class="el" href="iterative_8cpp-example.html#a7">iterative.cpp</a>, <a class="el" href="lanczos_8cpp-example.html#a4">lanczos.cpp</a>, <a class="el" href="least-squares_8cpp-example.html#a5">least-squares.cpp</a>, <a class="el" href="matrix-range_8cpp-example.html#a4">matrix-range.cpp</a>, <a class="el" href="mtl4-with-viennacl_8cpp-example.html#a3">mtl4-with-viennacl.cpp</a>, <a class="el" href="multithreaded_cg_8cpp-example.html#a6">multithreaded_cg.cpp</a>, <a class="el" href="power-iter_8cpp-example.html#a4">power-iter.cpp</a>, <a class="el" href="qr_8cpp-example.html#a4">qr.cpp</a>, <a class="el" href="spai_8cpp-example.html#a17">spai.cpp</a>, <a class="el" href="sparse_8cpp-example.html#a5">sparse.cpp</a>, <a class="el" href="structured-matrices_8cpp-example.html#a8">structured-matrices.cpp</a>, and <a class="el" href="vector-range_8cpp-example.html#a4">vector-range.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="circulant__matrix_8hpp_source.html#l00150">150</a> of file <a class="el" href="circulant__matrix_8hpp_source.html">circulant_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa608856aa45efa0252105174c1e0a63d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">toeplitz_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a Toeplitz matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class. ">toeplitz_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="toeplitz__matrix_8hpp_source.html#l00158">158</a> of file <a class="el" href="toeplitz__matrix_8hpp_source.html">toeplitz_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78e63a1fcca02e42105e4f5c0d7383f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vandermonde_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class. ">vandermonde_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vandermonde__matrix_8hpp_source.html#l00161">161</a> of file <a class="el" href="vandermonde__matrix_8hpp_source.html">vandermonde_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab68ce4636ce26e10fd645b65c30614fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">hankel_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class. ">hankel_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hankel__matrix_8hpp_source.html#l00162">162</a> of file <a class="el" href="hankel__matrix_8hpp_source.html">hankel_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2a8609bb498019d160969fde138a0bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">circulant_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class. ">circulant_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="circulant__matrix_8hpp_source.html#l00163">163</a> of file <a class="el" href="circulant__matrix_8hpp_source.html">circulant_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09970b6d02bfa2dd17a7d63d1fcbe18f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="coordinate__matrix_8hpp_source.html#l00164">164</a> of file <a class="el" href="coordinate__matrix_8hpp_source.html">coordinate_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab83a1719b10d1145a9d7035487c8f2ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; SizeT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector<std::map<SizeT, NumericT> > to basic u...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse square matrix on the host using STL types </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows c...">compressed_compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compressed__compressed__matrix_8hpp_source.html#l00164">164</a> of file <a class="el" href="compressed__compressed__matrix_8hpp_source.html">compressed_compressed_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1646248bf267396ba95ead1854a32a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vandermonde_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>vander_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vander_src</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class. ">vandermonde_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vandermonde__matrix_8hpp_source.html#l00174">174</a> of file <a class="el" href="vandermonde__matrix_8hpp_source.html">vandermonde_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaebed46e25be6371fe5610f75c315afc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">circulant_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>circ_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circ_src</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class. ">circulant_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="circulant__matrix_8hpp_source.html#l00176">176</a> of file <a class="el" href="circulant__matrix_8hpp_source.html">circulant_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9552fa64927a22bd0210e14021d12fe9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">hankel_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>han_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">han_src</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class. ">hankel_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hankel__matrix_8hpp_source.html#l00176">176</a> of file <a class="el" href="hankel__matrix_8hpp_source.html">hankel_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94125a5d77782ecabf9896c4a7378ae6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ell_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the host to the compute device. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host composed of an STL vector and an STL map. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>The sparse <a class="el" href="classviennacl_1_1ell__matrix.html" title="Sparse matrix class using the ELLPACK format for storing the nonzeros. ">ell_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ell__matrix_8hpp_source.html#l00181">181</a> of file <a class="el" href="ell__matrix_8hpp_source.html">ell_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac7e1dff63f0868e785113fb6553addd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">toeplitz_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class. ">toeplitz_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="toeplitz__matrix_8hpp_source.html#l00182">182</a> of file <a class="el" href="toeplitz__matrix_8hpp_source.html">toeplitz_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a8af211ade14d32939de1ab88fbfce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_range&lt; matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, column_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00189">189</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa36cc0adb8fc00e408f5ff6286528fb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vandermonde_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>vander_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a the matrix-like object to the Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">vander_dst</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class. ">vandermonde_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vandermonde__matrix_8hpp_source.html#l00196">196</a> of file <a class="el" href="vandermonde__matrix_8hpp_source.html">vandermonde_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a770c4f5948de36c4c343a608169c25b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hankel_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>han_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a the matrix-like object to the Hankel matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">han_dst</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class. ">hankel_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hankel__matrix_8hpp_source.html#l00197">197</a> of file <a class="el" href="hankel__matrix_8hpp_source.html">hankel_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4513747040c2f4c7951d3e866fbb7fb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const compressed_compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPUMatrixT type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows c...">compressed_compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compressed__compressed__matrix_8hpp_source.html#l00199">199</a> of file <a class="el" href="compressed__compressed__matrix_8hpp_source.html">compressed_compressed_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb9b4abab4a308f6850d8a379ce9d19c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const ell_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ell__matrix_8hpp_source.html#l00200">200</a> of file <a class="el" href="ell__matrix_8hpp_source.html">ell_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd7efd2bd791d1d11894ed488c3751ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">circulant_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>circ_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a the matrix-like object to the circulant matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">circ_dst</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class. ">circulant_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="circulant__matrix_8hpp_source.html#l00203">203</a> of file <a class="el" href="circulant__matrix_8hpp_source.html">circulant_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affa275ef815673673afe615439a6e7dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">toeplitz_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tep_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixT &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tep_src</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class. ">toeplitz_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="toeplitz__matrix_8hpp_source.html#l00204">204</a> of file <a class="el" href="toeplitz__matrix_8hpp_source.html">toeplitz_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1bf9bf2d8e0714db63fc999000c1510"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename NumericT , typename IndexT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sliced_ell_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, IndexT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the host to the compute device. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host composed of an STL vector and an STL map. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>The sparse <a class="el" href="classviennacl_1_1ell__matrix.html" title="Sparse matrix class using the ELLPACK format for storing the nonzeros. ">ell_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sliced__ell__matrix_8hpp_source.html#l00224">224</a> of file <a class="el" href="sliced__ell__matrix_8hpp_source.html">sliced_ell_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aacbbb1aee9a7a2b8a0cd85c049cad89a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename MatrixT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">toeplitz_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>tep_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a the matrix-like object to the Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">tep_dst</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class. ">toeplitz_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="toeplitz__matrix_8hpp_source.html#l00225">225</a> of file <a class="el" href="toeplitz__matrix_8hpp_source.html">toeplitz_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a638aa5c54fe703aac75a9613b6fa992a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, row_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00238">238</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbe5d5ca06633e7eb223bc43df45351d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename IndexT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const ell_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the compute device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>The sparse <a class="el" href="classviennacl_1_1ell__matrix.html" title="Sparse matrix class using the ELLPACK format for storing the nonzeros. ">ell_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host composed of an STL vector and an STL map. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ell__matrix_8hpp_source.html#l00242">242</a> of file <a class="el" href="ell__matrix_8hpp_source.html">ell_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef3fd50d62ce69e229ebdc92f9ddb6a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyb_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the host to the compute device. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host composed of an STL vector and an STL map. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>The sparse <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hyb__matrix_8hpp_source.html#l00243">243</a> of file <a class="el" href="hyb__matrix_8hpp_source.html">hyb_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33af429555220f128281e71d75932ea3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const compressed_compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows c...">compressed_compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compressed__compressed__matrix_8hpp_source.html#l00248">248</a> of file <a class="el" href="compressed__compressed__matrix_8hpp_source.html">compressed_compressed_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee077076d127c528b236cc78ff6b8bbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const hyb_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hyb__matrix_8hpp_source.html#l00260">260</a> of file <a class="el" href="hyb__matrix_8hpp_source.html">hyb_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa48aab4f03a1cc65d7601f1db982e87f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_slice&lt; vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00261">261</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9c1f7718f95bf4ed4cddc264b24c623"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaac6b8ed7edad298388c5936e476f783"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a99b5ce1b764503f97c07405b6a937fc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, column_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00280">280</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9139574d3d99501f0ef6c3fc322e548"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adc4171b2d0fb71c42ecdd32c9ed34451"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vector_slice&lt; vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00285">285</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad947ef8abf3c3cd4f69649b01ffb6d7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename IndexT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const hyb_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the compute device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>The sparse <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host composed of an STL vector and an STL map. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hyb__matrix_8hpp_source.html#l00324">324</a> of file <a class="el" href="hyb__matrix_8hpp_source.html">hyb_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acee17c9f4826a3a7574c6d94fd1946c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPUMatrixT type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compressed__matrix_8hpp_source.html#l00341">341</a> of file <a class="el" href="compressed__matrix_8hpp_source.html">compressed_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeae943c139b8f5faf2ca261c1a919e4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compressed__matrix_8hpp_source.html#l00387">387</a> of file <a class="el" href="compressed__matrix_8hpp_source.html">compressed_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32c2dc32899cf921fc088bb5dd591e3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, row_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00439">439</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8943b9e05480eb6b7bcd11a0061912e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, column_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00468">468</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2902ac57885aecf018516bc72fbab09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, row_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00506">506</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a784184338e26686e21bdf43d66c875ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, column_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00536">536</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa04b51b11118a495d5202f50fadd1576"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , typename F , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A dense matrix on the host. Type requirements: .<a class="el" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.) ">size1()</a> returns number of rows, .<a class="el" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">size2()</a> returns number of columns. Access to entries via operator() </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00934">934</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7f75fa1ed33f5ed4728e49528720999"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename A1 , typename A2 , typename F , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, A1 &gt;, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A dense matrix on the host of type std::vector&lt; std::vector&lt;&gt; &gt;. cpu_matrix[i][j] returns the element in the i-th row and j-th columns (both starting with zero) </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00970">970</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30682f75678f2f807e807e5a46be4010"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUMatrixT , typename NumericT , typename F , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUMatrixT &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A dense memory on the host. Must have at least as many rows and columns as the gpu_matrix! Type requirement: Access to entries via operator() </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01170">1170</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01c5c22fecddcfd850aace4aa231528e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename A1 , typename A2 , typename F , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, A1 &gt;, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A dense memory on the host using STL types, typically std::vector&lt; std::vector&lt;&gt; &gt; Must have at least as many rows and columns as the gpu_matrix! Type requirement: Access to entries via operator() </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01199">1199</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6c98e44b7ee336fa2eb4a6312b80cd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU constant iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU constant iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01322">1322</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abba314ca5441ee215d3adc77eafe529b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01344">1344</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41d005b9f0d205c14417da3dbdaff0f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename CPUVECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01360">1360</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40d083febe39561a435e4972b2d8db1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_begin</td><td>CPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_end</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_begin</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01488">1488</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a644f179cf3142e732c3c57155d73609a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HostVectorT , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">HostVectorT const &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a host vector object to a ViennaCL vector proxy. Requires the vector proxy to have the necessary size. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01510">1510</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1180fcee62a05d6ec83caf121ee066a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HostVectorT , typename T , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">HostVectorT const &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a host vector object to a ViennaCL vector. Resizes the ViennaCL vector if it has zero size. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A host vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu (ViennaCL) vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01521">1521</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1255fc3e9f9e4d920310e23e19ac0144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV_SRC, unsigned int AlignmentV_DEST&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const_vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy (parts of a) GPU vector to another GPU vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_src_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_src_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_dest_begin</td><td>Output iterator for the gpu vector. The gpu_dest vector must be at least as long as the gpu_src vector! </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01557">1557</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2540759a464fce64f568ea509d85e24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV_SRC, unsigned int AlignmentV_DEST&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy (parts of a) GPU vector to another GPU vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_src_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_src_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_dest_begin</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01585">1585</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e7fbf624c47329c1a37ba7eef778262"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV_SRC, unsigned int AlignmentV_DEST&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV_DEST &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_dest_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a ViennaCL vector to another ViennaCL vector. Convenience wrapper for viennacl::linalg::copy(gpu_src_vec.begin(), gpu_src_vec.end(), gpu_dest_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_src_vec</td><td>A gpu vector </td></tr>
    <tr><td class="paramname">gpu_dest_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01600">1600</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7d5db0c2c91be75218db5b52c4d13da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype">scalar&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a ViennaCL scalar. Non-const version. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2tutorial_2libviennacl_8cpp-example.html#a11">examples/tutorial/libviennacl.cpp</a>, and <a class="el" href="matrix-free_8cpp-example.html#a14">matrix-free.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00039">39</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab05a30685bca6711fe6065de6ed76cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype">scalar&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a ViennaCL scalar. Const version. </p>

<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00046">46</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad897d9d77baa2bb290b5957a3906c6c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a ViennaCL vector (through the base class <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a>) with implicit return type deduction. Non-const version. </p>

<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00056">56</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac551bbc38b63d40c61e46b447055fd5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a ViennaCL vector (through the base class <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a>) with implicit return type deduction. Const version. </p>

<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00063">63</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d9a9315dd46da747461f896b61e4c06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnT* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a ViennaCL vector (through the base class <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a>). Return type needs to be explicitly provided as first template argument. Non-const version. </p>

<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00070">70</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af53d32565d6525c3f15e0f115b5fc458"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnT , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ReturnT* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a ViennaCL vector (through the base class <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a>). Return type needs to be explicitly provided as first template argument. Const version. </p>

<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00077">77</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad231fa89c1b2e9bb4354cca72a9db563"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a ViennaCL matrix (through the base class <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>). Non-const version. </p>

<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00087">87</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeab16b276ab2da8dcc9dc2868f7a7202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a ViennaCL matrix (through the base class <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>). Const version. </p>

<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00094">94</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0de94cbf1edc144185fd87a3ec725cdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnT* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">viennacl::backend::mem_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a generic memory handle. Non-const version. </p>

<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00106">106</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a072d41ee21cc657238022f4917b51f64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnT const* viennacl::cuda_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1backend_1_1mem__handle.html">viennacl::backend::mem_handle</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience helper function for extracting the CUDA handle from a generic memory handle. Const-version. </p>

<p>Definition at line <a class="el" href="linalg_2cuda_2common_8hpp_source.html#l00113">113</a> of file <a class="el" href="linalg_2cuda_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a507d2ac469c79997f2bb6e82b37b7483"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const int, <a class="el" href="structviennacl_1_1op__matrix__diag.html">op_matrix_diag</a>&gt; viennacl::diag </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00895">895</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a96df6ab1bb59ee2c6e540694639d27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const int, <a class="el" href="structviennacl_1_1op__vector__diag.html">op_vector_diag</a>&gt; viennacl::diag </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00902">902</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff87e6c12c0c4774fb92fa88e0c44806"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUVECTOR , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_range&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00124">124</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f9afcfdb40091e366e2160d1e47bd2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename CPUVECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">vector_range&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a GPU vector range to a CPU vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector range. </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00157">157</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa5c8726b45bc89a523ca2fa8c42107a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3331c10c42bdec311e4c6b8665b01ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPU_ITERATOR , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af1057a25ff074250d9dc656ebed4c606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename F , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *&#160;</td>
          <td class="paramname"><em>cpu_matrix_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *&#160;</td>
          <td class="paramname"><em>cpu_matrix_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU. </p>
<p>See <a class="el" href="manual-types.html#manual-types-matrix">Dense Matrix Type</a> in the manual for the underlying data layout including padding rows and columns by zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix_begin</td><td>Pointer to the first matrix entry. Cf. iterator concept in STL </td></tr>
    <tr><td class="paramname">cpu_matrix_end</td><td>Pointer past the last matrix entry. Cf. iterator concept in STL </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01010">1010</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92695ea6fa06cb0b9d940bb14080b62a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename F , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> *&#160;</td>
          <td class="paramname"><em>cpu_matrix_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<p>See <a class="el" href="manual-types.html#manual-types-matrix">Dense Matrix Type</a> in the manual for the underlying data layout including padding rows and columns by zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td class="paramname">cpu_matrix_begin</td><td>Pointer to the output memory on the CPU. User must ensure that provided memory is large enough. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01231">1231</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a958e9ed4987dfc5cbd784b84f91d01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV, typename CPU_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) ...">copy()</a> function, because entries are directly written to the cpu vector, starting with &amp;(*cpu.begin()) However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01234">1234</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18efe971cc5df1ca97ca63bf7565a8ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename CPUVECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector. </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator pointing to entries linear in memory can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01267">1267</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c0192b3236f8f4962a208af7e139e22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPU_ITERATOR , typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) ...">copy()</a> function, because entries are directly read from the cpu vector, starting with &amp;(*cpu.begin()). However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_begin</td><td>CPU iterator pointing to the beginning of the cpu vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_end</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_begin</td><td>Output iterator for the gpu vector. The gpu iterator must be incrementable (cpu_end - cpu_begin) times, otherwise the result is undefined. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01400">1400</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19621895b23c45e932e4ce15d947b311"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CPUVECTOR , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01434">1434</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a495321f19d07b98a5ba433332cb590da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV&gt;&amp; viennacl::fast_swap </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="blas1_8cpp-example.html#a14">blas1.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01659">1659</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af61f6e7bfb0b18b8f824d12e7cb36930"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt;&gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m1 is a ViennaCL matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">m1</td><td>A ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01374">1374</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa850e0b2b3ff9bb2647cb536b4fffb90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * m1, where alpha is a char (8-bit integer) </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01382">1382</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a671309a17a97947a8f42b6f4f93d54bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * m1, where alpha is a short integer. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01390">1390</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a416d9ca3d7b57048ef270019eec4c07a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * m1, where alpha is an integer. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01398">1398</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc1015874fe77649ea83df1ae264f623"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * m1, where alpha is a long integer. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01406">1406</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6388159c0090f38d828107ce8c633e27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * m1, where alpha is a single precision floating point value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01414">1414</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a5d72e16ba0b866062e7365332303c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * m1, where alpha is a double precision floating point value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01422">1422</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac58516a40d21e78d01366ebf3f9b5782"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the multiplication of a matrix expression with a scalar from the right, e.g. (beta * m1) * alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side matrix expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01437">1437</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b7640299a65b58b1f08ca11222a972f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the multiplication of a matrix expression with a ViennaCL scalar from the left, e.g. alpha * (beta * m1). Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
    <tr><td class="paramname">proxy</td><td>Left hand side matrix expression </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01452">1452</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ad32571551a61deceaa9624f08e2d2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the matrix by a GPU scalar 'alpha' and returns an expression template. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01463">1463</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a055e2f08b4349d16f9637e86da2eca9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the matrix by a char (8-bit integer) 'alpha' and returns an expression template. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01471">1471</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e42e369bb6ffba830440ba2e3d66552"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the matrix by a short integer 'alpha' and returns an expression template. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01479">1479</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71b950ce150130705567961767bc9f93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the matrix by an integer 'alpha' and returns an expression template. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01487">1487</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a37d6119d11ee3de96a0fb1bad2cd280f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the matrix by a long integer 'alpha' and returns an expression template. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01495">1495</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0879808120c7027251b4abb70e6163d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the matrix by a single precision floating point number 'alpha' and returns an expression template. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01503">1503</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbd254c13a3a3dc4d50df850726bd13d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the matrix by a double precision floating point number 'alpha' and returns an expression template. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01511">1511</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3e47d6dce13c75a6b32d792cd854ffa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a>&gt;,const S1,<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt;&gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01752">1752</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0e1cf3b5bddbb11b2500599ac6343b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__cpu__scalar.html">viennacl::is_cpu_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a>&gt;,const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>,<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt;&gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01766">1766</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a886d3a303d99d70d54820473e1349757"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a>&gt;,const S1,<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt;&gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01781">1781</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0da914c1ab007cc95f3dceed9eedab7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__cpu__scalar.html">viennacl::is_cpu_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a>&gt;,const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>,<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt;&gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01795">1795</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f3c224d905d0e584fb72e566ed64977"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01871">1871</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1aa648c88a546872e66f73ae6b6f8c84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01883">1883</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f6a0765c929401a06741a1c837a7af3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01895">1895</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53f54b5071fc459f13261a08c0ea6ee5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01907">1907</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a902d3e1f3473a758e15b232f07e7b11e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01919">1919</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b11d21434d517b5c4d8603493932d4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01931">1931</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2c30c728d36beb46da292e2a3aad436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01943">1943</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac34b0528ba9cb2a8e586a64bafc3a1b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a>&lt;LHS, RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">scalar_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a scalar expression and v1 is a ViennaCL vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The scalar expression </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01957">1957</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64b79b9c7e7b0c0d4e838a6a8727c34e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the vector by a scalar 'alpha' and returns an expression template. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01967">1967</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a595de671ea4e3f2b0bb5eebb01458168"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01974">1974</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa92923ca916177c1864962bfb1443622"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector. ">vector_expression</a> and then multiplied with alpha from the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01987">1987</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9d86b7600ba400a9c865a5c23093254"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector. ">vector_expression</a> and then multiplied with alpha from the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l02001">2001</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b5f1f57f46bcf1c5949022b1600a229"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; &amp; &gt;::type viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a GPU scalar value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01522">1522</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adff5bcd6a96666051b8e45e9d0cf36a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a char (8-bit) value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01533">1533</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2febf91d5ae8f9034f0bf913ca8f0b17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a short integer value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01543">1543</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc887938113f86149365f506e29ba938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by an integer value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01553">1553</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97d5a2c7b8514856ee97a68dee279ac2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a long integer value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01563">1563</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af4dffb3b912475aa7e25494c8f75e294"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a single precision floating point value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01573">1573</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13520c405e905305b396e3e861c6017a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a double precision floating point value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01583">1583</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad54c9bbd40b29f875b0068db0fc194a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales this vector by a GPU scalar value. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01686">1686</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab85e3912a40d5d479835e7608808f07e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE&gt; &gt;::type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The vector the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class holding v1, A, and v2. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sparse__matrix__operations_8hpp_source.html#l00390">390</a> of file <a class="el" href="sparse__matrix__operations_8hpp_source.html">sparse_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d3a8290e94b15b653b3a0f0a3f80496"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01182">1182</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fb8b80e0a2a0c7ae9d1c6ff0ff88ade"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS1, const RHS1, OP1&gt;,const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS2, const RHS2, OP2&gt;,<a class="el" href="structviennacl_1_1op__add.html">op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01249">1249</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99433d936260c16ae92dad64d2af42d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS1, const RHS1, OP1&gt;,const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;,<a class="el" href="structviennacl_1_1op__add.html">op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01265">1265</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2da44f4931a9c2574fdb8a89c10e252b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01266">1266</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39d38ab31af0e8f442a2e90fa94aed2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename LHS2 , typename RHS2 , typename OP2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;,const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS2, const RHS2, OP2&gt;,<a class="el" href="structviennacl_1_1op__add.html">op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01281">1281</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9dc06bea5c7f930db9ff33f0f06b37ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for m1 + m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01295">1295</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab99420063bb11e696007951f6c3208fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;,const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2&gt;,<a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the addition of two vector expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy1</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">proxy2</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01732">1732</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30b8516e207086b374e91ce5ca292dca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;,const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;,<a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the addition of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01750">1750</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a789f52510dc1628aafde1fe379ca1001"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;,const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;,<a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the addition of a vector with a vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01768">1768</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2471d058da27c2588866407382060cc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template object for adding up two vectors, i.e. v1 + v2. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01781">1781</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59fd323314d8e60ad9cfb710f4ed1c61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation v1 += A * v2, where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector v1 where A * v2 is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01141">1141</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67afbd5c480d44b908d42990d27a2996"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation v1 += A * v2, where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector where the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01223">1223</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad648cd691bb8fa8358f552d00bce2946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;&amp; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const LHS, const RHS, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01280">1280</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5309df539f189a889f45f5e25098930f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE&gt; &gt;::type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The vector the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sparse__matrix__operations_8hpp_source.html#l00408">408</a> of file <a class="el" href="sparse__matrix__operations_8hpp_source.html">sparse_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb3693cfc246adc889875c208ca23aff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01200">1200</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad17b8034f666a89b9852d3752d08e411"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01286">1286</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a073efec32bd595b7620d5ca04a0ae500"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS1, const RHS1, OP1&gt;,const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS2, const RHS2, OP2&gt;,<a class="el" href="structviennacl_1_1op__sub.html">op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01309">1309</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aefaf3038b632cba603d17de16b2a6b95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS1, const RHS1, OP1&gt;,const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;,<a class="el" href="structviennacl_1_1op__sub.html">op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01325">1325</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a302aac58b4a7e6894bff2105159969cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename LHS2 , typename RHS2 , typename OP2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;,const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS2, const RHS2, OP2&gt;,<a class="el" href="structviennacl_1_1op__sub.html">op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01341">1341</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5bfb1e933c577c593814b926ae405e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for m1 - m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01355">1355</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a9b799cd9d2b4ae4376c5216d5ac93f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;,const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2&gt;,<a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the subtraction of two vector expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy1</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">proxy2</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01802">1802</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7dc7568bb713236e55439611520a74d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;,const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;,<a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01821">1821</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46d0f226493902ad3c4cf69eb05b3f48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;,const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;,<a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01839">1839</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2a0eb807884794e795aec5ec78353a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template object for subtracting two vectors, i.e. v1 - v2. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01852">1852</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a077ac0a2f14f1772505f46059ef00b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation v1 -= A * v2, where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector v1 where A * v2 is subtracted from </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01159">1159</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbc9022fc750953ad0ecf8eadd8b1793"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt;, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the operation v1 -= A * v2, where A is a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector where the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__operations_8hpp_source.html#l01244">1244</a> of file <a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e584237e084f29313d487917ceed47e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;&amp; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const LHS, const RHS, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__operations_8hpp_source.html#l01291">1291</a> of file <a class="el" href="vector__operations_8hpp_source.html">vector_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a6c40bbe0d9ca6f3f39d349639247c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS, const RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then divided by alpha. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side matrix expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01603">1603</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa60bf08e0585fc5feea364450e696558"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template for scaling the matrix by a GPU scalar 'alpha'. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01614">1614</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeaca8fd86909b87757f7c1f2ff837092"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template for scaling the matrix by a char (8-bit integer) 'alpha'. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01622">1622</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1bb4021955c62357d76faf3a02e8fae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template for scaling the matrix by a short integer 'alpha'. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01630">1630</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03aa835a6184c0ef7858c4c5ee316b78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template for scaling the matrix by an integer 'alpha'. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01638">1638</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a095183526f991e43f8de21b7305f795e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template for scaling the matrix by a long integer 'alpha'. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01646">1646</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae14d7130f2bf7648805ed09381263928"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template for scaling the matrix by a single precision floating point number 'alpha'. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01654">1654</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5af4240e12b959b38134593d41bb49d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template for scaling the matrix by a double precision floating point number 'alpha'. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01662">1662</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a810958ed96dd36b31993919612fa85d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector. ">vector_expression</a> and then divided by alpha. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l02019">2019</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8af63f5e1e3c138c901f53562d22ba18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template for scaling the vector by a GPU scalar 'alpha'. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l02031">2031</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43ab804469ebfdb77ad70c1cc0d7b2f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt; &amp; &gt;::type viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a GPU scalar value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01674">1674</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1be36347ee913ccefc9d42c9dbdd361"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a char (8-bit integer) value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01684">1684</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a683bc846ab01fff154ca436e3e0af161"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a short integer value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01694">1694</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa29579b205318b44886a3cc868feb064"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by an integer value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01704">1704</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e8d4647a330937c4cc44359b8ec8f52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value,<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp;&gt;::type viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales this vector by a GPU scalar value. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01707">1707</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3dbba4a1bd56d554ffa10e722c22e337"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a long integer value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01714">1714</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40dfc9998c7ae7a39d2c26dc35fb02d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a single precision floating point value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01724">1724</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6b752094b8c244a080136cdd5e2f271"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;&amp; viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by a double precision floating point value. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l01734">1734</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc953b0fbe9aecdf03f3c02f730b1028"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vandermonde_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A ViennaCL Vandermonde matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vandermonde__matrix_8hpp_source.html#l00225">225</a> of file <a class="el" href="vandermonde__matrix_8hpp_source.html">vandermonde_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcc974973c62956db774c398cdc8cd7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hankel_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hankel__matrix_8hpp_source.html#l00226">226</a> of file <a class="el" href="hankel__matrix_8hpp_source.html">hankel_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a620670ffc1049b66b2d51399d2c4c9ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">circulant_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A ViennaCL circulant matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="circulant__matrix_8hpp_source.html#l00241">241</a> of file <a class="el" href="circulant__matrix_8hpp_source.html">circulant_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aece37a39663683a2bf4fe18d6f372e86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">toeplitz_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A ViennaCL Toeplitz matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="toeplitz__matrix_8hpp_source.html#l00267">267</a> of file <a class="el" href="toeplitz__matrix_8hpp_source.html">toeplitz_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8707f526944ee24f12c399234fed56da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00828">828</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd36bb3a442eb6ef1ade2aad14be5ff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to directly print the value of a scalar to an output stream. </p>

<p>Definition at line <a class="el" href="scalar_8hpp_source.html#l00855">855</a> of file <a class="el" href="scalar_8hpp_source.html">scalar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c1627d47e4b494526e0287de3ed8476"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; LHS, RHS, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">expr</td><td>A matrix expression </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00865">865</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e37765605f0b2728573419f0f6e691b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , unsigned int AlignmentV&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, AlignmentV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output stream support for <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a>. Output format is same as MATLAB, Octave, or SciPy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>STL output stream </td></tr>
    <tr><td class="paramname">A</td><td>The compressed matrix to be printed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compressed__matrix_8hpp_source.html#l01059">1059</a> of file <a class="el" href="compressed__matrix_8hpp_source.html">compressed_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab305fb97f519cb1280277cf830e3dfce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output stream. Output format is ublas compatible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>STL output stream </td></tr>
    <tr><td class="paramname">val</td><td>The vector that should be printed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01617">1617</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21669e48cbc9c19811088f65b1162c1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01633">1633</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60033f942852a5e462d920c62eeaced9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; viennacl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to directly read a value of a scalar from an input stream. </p>

<p>Definition at line <a class="el" href="scalar_8hpp_source.html#l00864">864</a> of file <a class="el" href="scalar_8hpp_source.html">scalar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89ee402303952a729fdd80e43ba7a069"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt;VectorType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00169">169</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a212372cdbfca6aa45055ca3249d63649"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt;VectorType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00175">175</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4a676db96fd05c12757bde89bec72f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00308">308</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae54949548426c32cb2b7f651e41497ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00315">315</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abecb157ae33461b467d43a6b6eb3edd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00324">324</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc45a895937fe299100e2b235a442748"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt;MatrixType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00326">326</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c9ebd03331219bc6a77724dab6c2c16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector__proxy_8hpp_source.html#l00331">331</a> of file <a class="el" href="vector__proxy_8hpp_source.html">vector_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d33198f0cc7b3e811381c65dc497632"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt;MatrixType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; MatrixType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00335">335</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9c089715c733e9e42ac80ee5fc99e29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt;MatrixType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00568">568</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa9683f0ed709a227c267e33b3195ec2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt;MatrixType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; MatrixType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00576">576</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d0d5a12b085b5909596f1d754f0c9e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt;MatrixType&gt; viennacl::project </td>
          <td>(</td>
          <td class="paramtype">matrix_slice&lt; MatrixType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__proxy_8hpp_source.html#l00584">584</a> of file <a class="el" href="matrix__proxy_8hpp_source.html">matrix_proxy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acec126e71833e0756286cbf8cd036fbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; viennacl::reorder </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gibbs_poole_stockmeyer_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for the calculation of a node numbering permutation vector to reduce the bandwidth of a incidence matrix by the Gibbs-Poole-Stockmeyer algorithm. </p>
<p>references: Werner Neudorf: "Bandbreitenreduktion - Teil 3. Algorithmus von
  Gibbs-Poole-Stockmeyer. Testbeispiele mit CM und GPS", Preprint No. M 08/02, September 2002. Technische Universität Ilmenau, Fakultät für Mathematik und Naturwissenschaften, Institut für Mathematik. <a href="http://www.db-thueringen.de/servlets/DerivateServlet/Derivate-8673/IfM_Preprint_M_02_08.pdf">http://www.db-thueringen.de/servlets/DerivateServlet/Derivate-8673/IfM_Preprint_M_02_08.pdf</a> (URL taken on June 14, 2011)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>vector of n matrix rows, where each row is a map&lt;int, double&gt; containing only the nonzero elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>permutation vector r. r[l] = i means that the new label of node i will be l. </dd></dl>

<p>Definition at line <a class="el" href="gibbs__poole__stockmeyer_8hpp_source.html#l00150">150</a> of file <a class="el" href="gibbs__poole__stockmeyer_8hpp_source.html">gibbs_poole_stockmeyer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af22338e452cee008bee5e38070ddc611"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename ValueT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;IndexT&gt; viennacl::reorder </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cuthill_mckee_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the Cuthill-McKee algorithm. </p>
<p>references: Algorithm was implemented similary as described in "Tutorial: Bandwidth Reduction - The CutHill-
     McKee Algorithm" posted by Ciprian Zavoianu as weblog at <a href="http://ciprian-zavoianu.blogspot.com/2009/01/project-bandwidth-reduction.html">http://ciprian-zavoianu.blogspot.com/2009/01/project-bandwidth-reduction.html</a> on January 15, 2009 (URL taken on June 14, 2011)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>vector of n matrix rows, where each row is a map&lt;int, double&gt; containing only the nonzero elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>permutation vector r. r[l] = i means that the new label of node i will be l. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bandwidth-reduction_8cpp-example.html#a3">bandwidth-reduction.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="cuthill__mckee_8hpp_source.html#l00367">367</a> of file <a class="el" href="cuthill__mckee_8hpp_source.html">cuthill_mckee.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a032f691cd245d13b51b951f8a10825f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexT , typename ValueT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;IndexT&gt; viennacl::reorder </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">advanced_cuthill_mckee_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the advanced Cuthill-McKee algorithm. </p>
<p>references: see description of original Cuthill McKee implementation, and E. Cuthill and J. McKee: "Reducing the Bandwidth of sparse symmetric Matrices". Naval Ship Research and Development Center, Washington, D. C., 20007 </p>

<p>Definition at line <a class="el" href="cuthill__mckee_8hpp_source.html#l00474">474</a> of file <a class="el" href="cuthill__mckee_8hpp_source.html">cuthill_mckee.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a574e6cd04ca0e42298b4ab845700e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F&gt;, const unsigned int, <a class="el" href="structviennacl_1_1op__row.html">op_row</a>&gt; viennacl::row </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00910">910</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a49233dc20718f52e98e8b06e9711b375"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::swap </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of two vectors, data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="blas1_8cpp-example.html#a13">blas1.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01648">1648</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87d41d517b3d0daca8b1536e15e6659d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::switch_memory_context </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1context.html">viennacl::context</a>&#160;</td>
          <td class="paramname"><em>new_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic convenience routine for migrating data of an object to a new memory domain. </p>

<p>Definition at line <a class="el" href="memory_8hpp_source.html#l00622">622</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18c575b08038eb6af18fe1b89e4022ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; viennacl::tie </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01155">1155</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab25260434dfe3c4c527fd2a9ae437685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; viennacl::tie </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01158">1158</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee58be5508bb77871fc653aa8b33f3e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; viennacl::tie </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01162">1162</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56eeda7139441461f48c7303ad1b4b44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; viennacl::tie </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01165">1165</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7d28ebaf25043e36652c5ef210d405a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; viennacl::tie </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01169">1169</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0250b6a52a40df48e3ee18f1db6e4747"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; viennacl::tie </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01175">1175</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e40b38f92dd9f2b23f8fa134da43204"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; viennacl::tie </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01182">1182</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac96d28a81e8e227f2678360fbdd92ae1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; viennacl::tie </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l01199">1199</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ee5dd77d41040e0a937a60346475b84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt;<a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;M1&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const M1, const M1, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a>&gt; &gt;::type viennacl::trans </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template class representing a transposed matrix. </p>

<p>Definition at line <a class="el" href="sparse__matrix__operations_8hpp_source.html#l00376">376</a> of file <a class="el" href="sparse__matrix__operations_8hpp_source.html">sparse_matrix_operations.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedf958f77e4e8b2f4235675131e391ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;<a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a>&gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a>&gt; viennacl::trans </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template class representing a transposed matrix. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00877">877</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae384d8709f16c158a5974f9eb7d5864"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsT , typename RhsT , typename OpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LhsT, const RhsT, OpT&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LhsT, const RhsT, OpT&gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a>&gt; viennacl::trans </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const LhsT, const RhsT, OpT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression template class representing the transposed matrix expression. </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00885">885</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a></li>
    <li class="footer">Generated on Wed Jan 20 2016 22:32:44 for ViennaCL - The Vienna Computing Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
