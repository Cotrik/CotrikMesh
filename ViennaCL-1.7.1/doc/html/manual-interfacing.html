<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ViennaCL - The Vienna Computing Library: Interfacing Other Libraries</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Free open-source GPU-accelerated linear algebra and solver library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('manual-interfacing.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Interfacing Other Libraries </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ViennaCL aims at compatibility with as many other libraries as possible. This is on the one hand achieved by using generic implementations of the individual algorithms, and on the other hand by providing the necessary wrappers.</p>
<p>The interfaces to third-party libraries provided with ViennaCL are explained in the following subsections. Please feel free to suggest additional libraries for which an interface should be shipped with ViennaCL.</p>
<p>Since it is unlikely that all third-party libraries for which ViennaCL provides interfaces are installed on the target machine, the wrappers are disabled by default. To selectively enable the wrappers, the appropriate preprocessor constants <code>VIENNACL_WITH_XXXX</code> have to be defined <em>prior to any #<code>include</code> statements for ViennaCL headers</em>. This can for example be assured by passing the preprocessor constant directly when launching the compiler. With <code>GCC</code> this is for instance achieved by the <code>-D</code> switch.</p>
<h1><a class="anchor" id="manual-interfacing-ublas"></a>
Boost.uBLAS</h1>
<p>Since all types in ViennaCL have the same interface as their counterparts in Boost.uBLAS, most code written for ViennaCL objects remains valid when using Boost.uBLAS objects. </p>
<div class="fragment"><div class="line"><span class="comment">// Option 1: Using ViennaCL:</span></div>
<div class="line"><span class="keyword">using namespace </span>viennacl;</div>
<div class="line"><span class="keyword">using namespace </span>viennacl::linalg;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Option 2: Using ublas:</span></div>
<div class="line"><span class="comment">//using namespace boost::numeric::ublas;</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classviennacl_1_1matrix.html">matrix&lt;float&gt;</a>            <a class="code" href="classdense__matrix.html">dense_matrix</a>(5,5);</div>
<div class="line"><a class="code" href="classviennacl_1_1vector.html">vector&lt;float&gt;</a>            dense_vector(5,5);</div>
<div class="line"><a class="code" href="classviennacl_1_1compressed__matrix.html">compressed_matrix&lt;float&gt;</a> sparse_matrix(1000, 1000);</div>
<div class="line"></div>
<div class="line"><span class="comment">// fill with data:</span></div>
<div class="line"><a class="code" href="classdense__matrix.html">dense_matrix</a>(0,0) = 2.0;</div>
<div class="line">....</div>
<div class="line"></div>
<div class="line"><span class="comment">// run solvers</span></div>
<div class="line"><a class="code" href="classviennacl_1_1vector.html">vector&lt;float&gt;</a> result1 = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(<a class="code" href="classdense__matrix.html">dense_matrix</a>, dense_vector, <a class="code" href="structviennacl_1_1linalg_1_1upper__tag.html">upper_tag</a>());</div>
<div class="line"><a class="code" href="classviennacl_1_1vector.html">vector&lt;float&gt;</a> result2 = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">viennacl::linalg::solve</a>(sparse_matrix, dense_vector, <a class="code" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a>());</div>
</div><!-- fragment --><p> The above code is valid for either the ViennaCL namespace declarations, or the Boost.uBLAS namespace. Note that the iterative solvers are not part of Boost.uBLAS and therefore the explicit namespace specification is required. More examples for the exchangability of Boost.uBLAS and ViennaCL can be found in the tutorials in the <code>examples/tutorials/</code> folder.</p>
<dl class="section warning"><dt>Warning</dt><dd>When using the iterative solvers, the preprocessor constant <code>VIENNACL_WITH_UBLAS</code> must be defined prior to any other ViennaCL include statements. This is essential for enabling the respective wrappers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Refer in particular to <code><a class="el" href="iterative-ublas_8cpp.html">iterative-ublas.cpp</a></code> for a complete example on iterative solvers using Boost.uBLAS types.</dd></dl>
<h1><a class="anchor" id="manual-interfacing-armadillo"></a>
Armadillo</h1>
<p>To copy data from Armadillo <a class="el" href="citelist.html#CITEREF_armadillo">[1]</a> objects (version 5.x) to ViennaCL, the <code><a class="el" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) ...">copy()</a></code>-functions are used just as for Boost.uBLAS and STL types: </p>
<div class="fragment"><div class="line"><span class="comment">// from Armadillo to ViennaCL</span></div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(arma_vector,       vcl_vector);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(arma_densematrix,  vcl_densematrix);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(arma_sparsematrix, vcl_sparsematrix);</div>
</div><!-- fragment --><p> In addition, the STL-compliant iterator-version of <code><a class="el" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) ...">viennacl::copy()</a></code> taking three arguments can be used for copying vector data. Here, all types prefixed with <code>arma</code> are Armadillo types, the prefix <code>vcl</code> indicates ViennaCL objects. Similarly, the transfer from ViennaCL back to Armadillo is accomplished by </p>
<div class="fragment"><div class="line"><span class="comment">//from ViennaCL to Armadillo</span></div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(vcl_vector,       arma_vector);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(vcl_densematrix,  arma_densematrix);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(vcl_sparsematrix, arma_sparsematrix);</div>
</div><!-- fragment --><p>The iterative solvers in ViennaCL can also be used directly with Armadillo objects: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>viennacl::linalg; <span class="comment">// for brevity of the following lines</span></div>
<div class="line"></div>
<div class="line">arma_result = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(arma_matrix, arma_rhs, <a class="code" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a>());</div>
<div class="line">arma_result = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(arma_matrix, arma_rhs, <a class="code" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a>());</div>
<div class="line">arma_result = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(arma_matrix, arma_rhs, <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a>());</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>When using the iterative solvers with Armadillo, the preprocessor constant <code>VIENNACL_WITH_ARMADILLO</code> must be defined prior to any other ViennaCL include statements. This is essential for enabling the respective wrappers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Refer to <code><a class="el" href="iterative-armadillo_8cpp.html">iterative-armadillo.cpp</a></code> and <code><a class="el" href="armadillo-with-viennacl_8cpp.html">armadillo-with-viennacl.cpp</a></code> for complete examples.</dd></dl>
<h1><a class="anchor" id="manual-interfacing-eigen"></a>
Eigen</h1>
<p>To copy data from Eigen <a class="el" href="citelist.html#CITEREF_eigen">[11]</a> objects (version 3.x.y) to ViennaCL, the <code><a class="el" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) ...">copy()</a></code>-functions are used just as for Boost.uBLAS and STL types: </p>
<div class="fragment"><div class="line"><span class="comment">// from Eigen to ViennaCL</span></div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(eigen_vector,       vcl_vector);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(eigen_densematrix,  vcl_densematrix);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(eigen_sparsematrix, vcl_sparsematrix);</div>
</div><!-- fragment --><p> In addition, the STL-compliant iterator-version of <code><a class="el" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) ...">viennacl::copy()</a></code> taking three arguments can be used for copying vector data. Here, all types prefixed with <code>eigen</code> are Eigen types, the prefix <code>vcl</code> indicates ViennaCL objects. Similarly, the transfer from ViennaCL back to <code>Eigen</code> is accomplished by </p>
<div class="fragment"><div class="line"><span class="comment">//from ViennaCL to Eigen</span></div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(vcl_vector,       eigen_vector);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(vcl_densematrix,  eigen_densematrix);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(vcl_sparsematrix, eigen_sparsematrix);</div>
</div><!-- fragment --><p>The iterative solvers in ViennaCL can also be used directly with Eigen objects: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>viennacl::linalg; <span class="comment">// for brevity of the following lines</span></div>
<div class="line"></div>
<div class="line">eigen_result = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(eigen_matrix, eigen_rhs, <a class="code" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a>());</div>
<div class="line">eigen_result = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(eigen_matrix, eigen_rhs, <a class="code" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a>());</div>
<div class="line">eigen_result = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(eigen_matrix, eigen_rhs, <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a>());</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>When using the iterative solvers with Eigen, the preprocessor constant <code>VIENNACL_WITH_EIGEN</code> must be defined prior to any other ViennaCL include statements. This is essential for enabling the respective wrappers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Refer to <code><a class="el" href="iterative-eigen_8cpp.html">iterative-eigen.cpp</a></code> and <code><a class="el" href="eigen-with-viennacl_8cpp.html">eigen-with-viennacl.cpp</a></code> for complete examples.</dd></dl>
<h1><a class="anchor" id="manual-interfacing-mtl"></a>
MTL 4</h1>
<p>The following lines demonstate how ViennaCL types are filled with data from MTL <a class="el" href="citelist.html#CITEREF_mtl4">[22]</a> objects: </p>
<div class="fragment"><div class="line"><span class="comment">//from MTL 4 to ViennaCL</span></div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(mtl4_vector,       vcl_vector);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(mtl4_densematrix,  vcl_densematrix);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(mtl4_sparsematrix, vcl_sparsematrix);</div>
</div><!-- fragment --><p> In addition, the STL-compliant iterator-version of <code><a class="el" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) ...">viennacl::copy()</a></code> taking three arguments can be used for copying vector data. Here, all types prefixed with <code>mtl4</code> are MTL types, the prefix <code>vcl</code> indicates ViennaCL objects. Similarly, the transfer from ViennaCL back to MTL is accomplished by </p>
<div class="fragment"><div class="line"><span class="comment">//from ViennaCL to MTL4</span></div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(vcl_vector,       mtl4_vector);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(vcl_densematrix,  mtl4_densematrix);</div>
<div class="line"><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(vcl_sparsematrix, mtl4_sparsematrix);</div>
</div><!-- fragment --><p>Even though MTL provides its own set of iterative solvers, the iterative solvers in ViennaCL can also be used: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>viennacl::linalg; <span class="comment">//for brevity of the following lines</span></div>
<div class="line"></div>
<div class="line">mtl4_result = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(mtl4_matrix, mtl4_rhs, <a class="code" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a>());</div>
<div class="line">mtl4_result = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(mtl4_matrix, mtl4_rhs, <a class="code" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a>());</div>
<div class="line">mtl4_result = <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9b329b64ac782e6a5687ad2fc47a2a">solve</a>(mtl4_matrix, mtl4_rhs, <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a>());</div>
</div><!-- fragment --><p> Our internal tests have shown that the execution time of MTL solvers is equal to ViennaCL solvers when using MTL types.</p>
<dl class="section warning"><dt>Warning</dt><dd>When using the iterative solvers with MTL, the preprocessor constant <code>VIENNACL_WITH_MTL4</code> must be defined prior to any other ViennaCL include statements. This is essential for enabling the respective wrappers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Refer to <code><a class="el" href="iterative-mtl4_8cpp.html">iterative-mtl4.cpp</a></code> and <code><a class="el" href="mtl4-with-viennacl_8cpp.html">mtl4-with-viennacl.cpp</a></code> for complete examples. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 20 2016 22:32:44 for ViennaCL - The Vienna Computing Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
