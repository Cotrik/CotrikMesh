<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ViennaCL - The Vienna Computing Library: iterative-custom.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Free open-source GPU-accelerated linear algebra and solver library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('iterative-custom_8cpp-example.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">iterative-custom.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>This tutorial explains the use of iterative solvers in ViennaCL with custom monitors and initial guesses.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="iterative-custom_8cpp.html">iterative-custom.cpp</a> and iterative-custom.cu are identical, the latter being required for compilation using CUDA nvcc</dd></dl>
<p>We start with including the necessary system headers: </p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// include necessary system headers</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// ViennaCL includes</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="scalar_8hpp.html">viennacl/scalar.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="vector_8hpp.html">viennacl/vector.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="compressed__matrix_8hpp.html">viennacl/compressed_matrix.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="prod_8hpp.html">viennacl/linalg/prod.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="jacobi__precond_8hpp.html">viennacl/linalg/jacobi_precond.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cg_8hpp.html">viennacl/linalg/cg.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bicgstab_8hpp.html">viennacl/linalg/bicgstab.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="gmres_8hpp.html">viennacl/linalg/gmres.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix__market_8hpp.html">viennacl/io/matrix_market.hpp</a>&quot;</span></div>
</div><!-- fragment --> <h1>Defining Custom Monitors Functions for Iterative Solvers</h1>
<p>Custom monitors for the iterative solvers require two ingredients: First, a structure holding all the auxiliary data we want to reuse in the monitor. Second, a callback function called by the solver in each iteration.</p>
<p>In this example we define a callback-routine for printing the current estimate for the residual and compare it with the true residual. To do so, we need to pass the system matrix, the right hand side, and the initial guess to the monitor routine, which we achieve by packing pointers to these objects into a struct: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixT, <span class="keyword">typename</span> VectorT&gt;</div>
<div class="line"><span class="keyword">struct </span>monitor_user_data</div>
<div class="line">{</div>
<div class="line">  monitor_user_data(MatrixT <span class="keyword">const</span> &amp; A, VectorT <span class="keyword">const</span> &amp; b, VectorT <span class="keyword">const</span> &amp; guess) : A_ptr(&amp;A), b_ptr(&amp;b), guess_ptr(&amp;guess) {}</div>
<div class="line"></div>
<div class="line">  MatrixT <span class="keyword">const</span> *A_ptr;</div>
<div class="line">  VectorT <span class="keyword">const</span> *b_ptr;</div>
<div class="line">  VectorT <span class="keyword">const</span> *guess_ptr;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The actual callback-routine takes the current approximation to the result as the first parameter, and the current estimate for the relative residual norm as second argument. The third argument is a pointer to our user-data, which in a first step cast to the correct type. If the monitor returns true, the iterative solver stops. This is handy for defining custom termination criteria, e.g. one-norms for the result change. Since we do not want to terminate the iterative solver with a custom criterion here, we always return 'false' at the end of the function.</p>
<p>Note to type-safety evangelists: This void*-interface is designed to be later exposed through a shared library ('libviennacl'). Thus, user types may not be known at the point of compilation, requiring a void*-approach. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VectorT, <span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> MatrixT&gt;</div>
<div class="line"><span class="keywordtype">bool</span> my_custom_monitor(VectorT <span class="keyword">const</span> &amp; current_approx, <a class="code" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> residual_estimate, <span class="keywordtype">void</span> *user_data)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Extract residual:</span></div>
<div class="line">  monitor_user_data&lt;MatrixT, VectorT&gt; <span class="keyword">const</span> *data = <span class="keyword">reinterpret_cast&lt;</span>monitor_user_data&lt;MatrixT, VectorT&gt; const*<span class="keyword">&gt;</span>(user_data);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Form residual r = b - A*x, taking an initial guess into account: r = b - A * (current_approx + x_initial)</span></div>
<div class="line">  VectorT x = current_approx + *data-&gt;guess_ptr;</div>
<div class="line">  VectorT residual = *data-&gt;b_ptr - <a name="a0"></a><a class="code" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a>(*data-&gt;A_ptr, x);</div>
<div class="line">  VectorT initial_residual = *data-&gt;b_ptr - <a class="code" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a>(*data-&gt;A_ptr, *data-&gt;guess_ptr);</div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Residual estimate vs. true residual: &quot;</span> &lt;&lt; residual_estimate &lt;&lt; <span class="stringliteral">&quot; vs. &quot;</span> &lt;&lt; <a name="a1"></a><a class="code" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">viennacl::linalg::norm_2</a>(residual) / <a class="code" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">viennacl::linalg::norm_2</a>(initial_residual) &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// no termination of iteration</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h1>The main Program</h1>
<p>In the <a class="el" href="tests_2src_2bisect_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> routine we create matrices and vectors and fill them with data. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a name="a2"></a><a class="code" href="tests_2src_2bisect_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">float</span>       <a name="a3"></a><a class="code" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>;</div>
</div><!-- fragment --><p> Read system matrix from a matrix-market file </p>
<div class="fragment"><div class="line">std::vector&lt;std::map&lt;unsigned int, ScalarType&gt; &gt; stl_A;</div>
<div class="line"><span class="keywordflow">if</span> (!<a name="a4"></a><a class="code" href="namespaceviennacl_1_1io.html#ad934125ed3dbe661e264bcd7d62b1048">viennacl::io::read_matrix_market_file</a>(stl_A, <span class="stringliteral">&quot;../examples/testdata/mat65k.mtx&quot;</span>))</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Error reading Matrix file&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">}</div>
<div class="line"><a name="_a5"></a><a class="code" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix&lt;ScalarType&gt;</a> A;</div>
<div class="line"><a name="a6"></a><a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(stl_A, A);</div>
</div><!-- fragment --><p> Set up right hand side and reference solution consisting of all ones: </p>
<div class="fragment"><div class="line"><a name="_a7"></a><a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> ref_result = <a name="_a8"></a><a class="code" href="structviennacl_1_1scalar__vector.html">viennacl::scalar_vector&lt;ScalarType&gt;</a>(A.<a name="a9"></a><a class="code" href="classviennacl_1_1compressed__matrix.html#a4fc12fc4abfef4a1426575a2d73f18ab">size2</a>(), <a class="code" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>(1.0));</div>
<div class="line"><a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> result(A.<a class="code" href="classviennacl_1_1compressed__matrix.html#a4fc12fc4abfef4a1426575a2d73f18ab">size2</a>());</div>
<div class="line"></div>
<div class="line"><a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> b = <a class="code" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a>(A, ref_result);</div>
</div><!-- fragment --><p> As initial guess we take a vector consisting of all 0.9s, except for the first entry, which we set to zero: </p>
<div class="fragment"><div class="line"><a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> init_guess = <a class="code" href="structviennacl_1_1scalar__vector.html">viennacl::scalar_vector&lt;ScalarType&gt;</a>(ref_result.<a name="a10"></a><a class="code" href="classviennacl_1_1vector__base.html#a15c47ae4326098aeaa4ed6b91fc6df9b">size</a>(), <a class="code" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>(0.9));</div>
<div class="line">init_guess[0] = 0;</div>
</div><!-- fragment --><p> Set up the monitor data, holding the system matrix, the right hand side, and the initial guess: </p>
<div class="fragment"><div class="line">monitor_user_data&lt;viennacl::compressed_matrix&lt;ScalarType&gt;, <a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> &gt; my_monitor_data(A, b, init_guess);</div>
</div><!-- fragment --><p> set up Jacobi preconditioners (just for demonstration purposes, can be any other preconditioner here): </p>
<div class="fragment"><div class="line"><a name="_a11"></a><a class="code" href="classviennacl_1_1linalg_1_1jacobi__precond.html">viennacl::linalg::jacobi_precond&lt; viennacl::compressed_matrix&lt;ScalarType&gt;</a> &gt; jacobi(A, <a name="_a12"></a><a class="code" href="classviennacl_1_1linalg_1_1jacobi__tag.html">viennacl::linalg::jacobi_tag</a>());</div>
</div><!-- fragment --> <h2>Conjugate Gradient Solver</h2>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;----- CG Method -----&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Run the CG method with a relative tolerance of 1e-5 and a maximum of 20 iterations. We instantiate the CG solver object, register the monitor callback (with data), set the initial guess, and launch the solver. </p>
<div class="fragment"><div class="line"><a name="_a13"></a><a class="code" href="classviennacl_1_1linalg_1_1cg__tag.html">viennacl::linalg::cg_tag</a> my_cg_tag(1e-5, 20);</div>
<div class="line"><a name="_a14"></a><a class="code" href="classviennacl_1_1linalg_1_1cg__solver.html">viennacl::linalg::cg_solver&lt;viennacl::vector&lt;ScalarType&gt;</a> &gt; my_cg_solver(my_cg_tag);</div>
<div class="line"></div>
<div class="line">my_cg_solver.set_monitor(my_custom_monitor&lt;<a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a>, ScalarType, <a class="code" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix&lt;ScalarType&gt;</a> &gt;, &amp;my_monitor_data);</div>
<div class="line">my_cg_solver.set_initial_guess(init_guess);</div>
<div class="line"></div>
<div class="line">my_cg_solver(A, b); <span class="comment">// without preconditioner</span></div>
</div><!-- fragment --> <h2>Stabilized BiConjugate Gradient Solver</h2>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;----- BiCGStab Method -----&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Run the Jacobi-preconditioned BiCGStab method with a relative tolerance of 1e-5 and a maximum of 20 iterations. We instantiate the BiCGStab solver object, register the monitor callback (with data), set the initial guess, and launch the solver. </p>
<div class="fragment"><div class="line"><a name="_a15"></a><a class="code" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">viennacl::linalg::bicgstab_tag</a> my_bicgstab_tag(1e-5, 20);</div>
<div class="line"><a name="_a16"></a><a class="code" href="classviennacl_1_1linalg_1_1bicgstab__solver.html">viennacl::linalg::bicgstab_solver&lt;viennacl::vector&lt;ScalarType&gt;</a> &gt; my_bicgstab_solver(my_bicgstab_tag);</div>
<div class="line"></div>
<div class="line">my_bicgstab_solver.set_monitor(my_custom_monitor&lt;<a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a>, ScalarType, <a class="code" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix&lt;ScalarType&gt;</a> &gt;, &amp;my_monitor_data);</div>
<div class="line">my_bicgstab_solver.set_initial_guess(init_guess);</div>
<div class="line"></div>
<div class="line">my_bicgstab_solver(A, b, jacobi); <span class="comment">// with Jacobi preconditioner</span></div>
</div><!-- fragment --> <h2>GMRES Solver</h2>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;----- GMRES Method -----&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Run the unpreconditioned GMRES method with a relative tolerance of 1e-5 and a maximum of 30 iterations for a Krylov size of 10 (i.e. restart every 10 iterations). We instantiate the GMRES solver object, register the monitor callback (with data), set the initial guess, and launch the solver.</p>
<p>Note that the monitor in the GMRES method is only called after each restart, but not in every (inner) iteration. </p>
<div class="fragment"><div class="line"><a name="_a17"></a><a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html">viennacl::linalg::gmres_tag</a> my_gmres_tag(1e-5, 30, 10);</div>
<div class="line"><a name="_a18"></a><a class="code" href="classviennacl_1_1linalg_1_1gmres__solver.html">viennacl::linalg::gmres_solver&lt;viennacl::vector&lt;ScalarType&gt;</a> &gt; my_gmres_solver(my_gmres_tag);</div>
<div class="line"></div>
<div class="line">my_gmres_solver.set_monitor(my_custom_monitor&lt;<a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a>, ScalarType, <a class="code" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix&lt;ScalarType&gt;</a> &gt;, &amp;my_monitor_data);</div>
<div class="line">my_gmres_solver.set_initial_guess(init_guess);</div>
<div class="line"></div>
<div class="line">my_gmres_solver(A, b);</div>
</div><!-- fragment --><p> That's it, the tutorial is completed. </p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;!!!! TUTORIAL COMPLETED SUCCESSFULLY !!!!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2>Full Example Code</h2>
<div class="fragment"><div class="line"><span class="comment">/* =========================================================================</span></div>
<div class="line"><span class="comment">   Copyright (c) 2010-2016, Institute for Microelectronics,</span></div>
<div class="line"><span class="comment">                            Institute for Analysis and Scientific Computing,</span></div>
<div class="line"><span class="comment">                            TU Wien.</span></div>
<div class="line"><span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">                            -----------------</span></div>
<div class="line"><span class="comment">                  ViennaCL - The Vienna Computing Library</span></div>
<div class="line"><span class="comment">                            -----------------</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span></div>
<div class="line"><span class="comment">============================================================================= */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// include necessary system headers</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// ViennaCL includes</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="scalar_8hpp.html">viennacl/scalar.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="vector_8hpp.html">viennacl/vector.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="compressed__matrix_8hpp.html">viennacl/compressed_matrix.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="prod_8hpp.html">viennacl/linalg/prod.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="jacobi__precond_8hpp.html">viennacl/linalg/jacobi_precond.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cg_8hpp.html">viennacl/linalg/cg.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="bicgstab_8hpp.html">viennacl/linalg/bicgstab.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="gmres_8hpp.html">viennacl/linalg/gmres.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix__market_8hpp.html">viennacl/io/matrix_market.hpp</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixT, <span class="keyword">typename</span> VectorT&gt;</div>
<div class="line"><span class="keyword">struct </span>monitor_user_data</div>
<div class="line">{</div>
<div class="line">  monitor_user_data(MatrixT <span class="keyword">const</span> &amp; A, VectorT <span class="keyword">const</span> &amp; b, VectorT <span class="keyword">const</span> &amp; guess) : A_ptr(&amp;A), b_ptr(&amp;b), guess_ptr(&amp;guess) {}</div>
<div class="line"></div>
<div class="line">  MatrixT <span class="keyword">const</span> *A_ptr;</div>
<div class="line">  VectorT <span class="keyword">const</span> *b_ptr;</div>
<div class="line">  VectorT <span class="keyword">const</span> *guess_ptr;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VectorT, <span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> MatrixT&gt;</div>
<div class="line"><span class="keywordtype">bool</span> my_custom_monitor(VectorT <span class="keyword">const</span> &amp; current_approx, <a class="code" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> residual_estimate, <span class="keywordtype">void</span> *user_data)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Extract residual:</span></div>
<div class="line">  monitor_user_data&lt;MatrixT, VectorT&gt; <span class="keyword">const</span> *data = <span class="keyword">reinterpret_cast&lt;</span>monitor_user_data&lt;MatrixT, VectorT&gt; const*<span class="keyword">&gt;</span>(user_data);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Form residual r = b - A*x, taking an initial guess into account: r = b - A * (current_approx + x_initial)</span></div>
<div class="line">  VectorT x = current_approx + *data-&gt;guess_ptr;</div>
<div class="line">  VectorT residual = *data-&gt;b_ptr - <a class="code" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a>(*data-&gt;A_ptr, x);</div>
<div class="line">  VectorT initial_residual = *data-&gt;b_ptr - <a class="code" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a>(*data-&gt;A_ptr, *data-&gt;guess_ptr);</div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Residual estimate vs. true residual: &quot;</span> &lt;&lt; residual_estimate &lt;&lt; <span class="stringliteral">&quot; vs. &quot;</span> &lt;&lt; <a class="code" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">viennacl::linalg::norm_2</a>(residual) / <a class="code" href="namespaceviennacl_1_1linalg.html#ae46f15d01c01f92a153b3f555a15096b">viennacl::linalg::norm_2</a>(initial_residual) &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// no termination of iteration</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="tests_2src_2bisect_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">float</span>       <a class="code" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  std::vector&lt;std::map&lt;unsigned int, ScalarType&gt; &gt; stl_A;</div>
<div class="line">  <span class="keywordflow">if</span> (!<a class="code" href="namespaceviennacl_1_1io.html#ad934125ed3dbe661e264bcd7d62b1048">viennacl::io::read_matrix_market_file</a>(stl_A, <span class="stringliteral">&quot;../examples/testdata/mat65k.mtx&quot;</span>))</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Error reading Matrix file&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <a class="code" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix&lt;ScalarType&gt;</a> A;</div>
<div class="line">  <a class="code" href="namespaceviennacl.html#a10b7f8cf6b8864a7aa196d670481a453">viennacl::copy</a>(stl_A, A);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> ref_result = <a class="code" href="structviennacl_1_1scalar__vector.html">viennacl::scalar_vector&lt;ScalarType&gt;</a>(A.<a class="code" href="classviennacl_1_1compressed__matrix.html#a4fc12fc4abfef4a1426575a2d73f18ab">size2</a>(), <a class="code" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>(1.0));</div>
<div class="line">  <a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> result(A.<a class="code" href="classviennacl_1_1compressed__matrix.html#a4fc12fc4abfef4a1426575a2d73f18ab">size2</a>());</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> b = <a class="code" href="namespaceviennacl_1_1linalg.html#aa18d10f8a90e38bd9ff43c650fc670ef">viennacl::linalg::prod</a>(A, ref_result);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> init_guess = <a class="code" href="structviennacl_1_1scalar__vector.html">viennacl::scalar_vector&lt;ScalarType&gt;</a>(ref_result.<a class="code" href="classviennacl_1_1vector__base.html#a15c47ae4326098aeaa4ed6b91fc6df9b">size</a>(), <a class="code" href="fft__1d_8cpp.html#ad5c19ca4f47d3f8ec21232a5af2624e5">ScalarType</a>(0.9));</div>
<div class="line">  init_guess[0] = 0;</div>
<div class="line"></div>
<div class="line">  monitor_user_data&lt;viennacl::compressed_matrix&lt;ScalarType&gt;, <a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a> &gt; my_monitor_data(A, b, init_guess);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <a class="code" href="classviennacl_1_1linalg_1_1jacobi__precond.html">viennacl::linalg::jacobi_precond&lt; viennacl::compressed_matrix&lt;ScalarType&gt;</a> &gt; jacobi(A, <a class="code" href="classviennacl_1_1linalg_1_1jacobi__tag.html">viennacl::linalg::jacobi_tag</a>());</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;----- CG Method -----&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classviennacl_1_1linalg_1_1cg__tag.html">viennacl::linalg::cg_tag</a> my_cg_tag(1e-5, 20);</div>
<div class="line">  <a class="code" href="classviennacl_1_1linalg_1_1cg__solver.html">viennacl::linalg::cg_solver&lt;viennacl::vector&lt;ScalarType&gt;</a> &gt; my_cg_solver(my_cg_tag);</div>
<div class="line"></div>
<div class="line">  my_cg_solver.set_monitor(my_custom_monitor&lt;<a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a>, ScalarType, <a class="code" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix&lt;ScalarType&gt;</a> &gt;, &amp;my_monitor_data);</div>
<div class="line">  my_cg_solver.set_initial_guess(init_guess);</div>
<div class="line"></div>
<div class="line">  my_cg_solver(A, b); <span class="comment">// without preconditioner</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;----- BiCGStab Method -----&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">viennacl::linalg::bicgstab_tag</a> my_bicgstab_tag(1e-5, 20);</div>
<div class="line">  <a class="code" href="classviennacl_1_1linalg_1_1bicgstab__solver.html">viennacl::linalg::bicgstab_solver&lt;viennacl::vector&lt;ScalarType&gt;</a> &gt; my_bicgstab_solver(my_bicgstab_tag);</div>
<div class="line"></div>
<div class="line">  my_bicgstab_solver.set_monitor(my_custom_monitor&lt;<a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a>, ScalarType, <a class="code" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix&lt;ScalarType&gt;</a> &gt;, &amp;my_monitor_data);</div>
<div class="line">  my_bicgstab_solver.set_initial_guess(init_guess);</div>
<div class="line"></div>
<div class="line">  my_bicgstab_solver(A, b, jacobi); <span class="comment">// with Jacobi preconditioner</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;----- GMRES Method -----&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html">viennacl::linalg::gmres_tag</a> my_gmres_tag(1e-5, 30, 10);</div>
<div class="line">  <a class="code" href="classviennacl_1_1linalg_1_1gmres__solver.html">viennacl::linalg::gmres_solver&lt;viennacl::vector&lt;ScalarType&gt;</a> &gt; my_gmres_solver(my_gmres_tag);</div>
<div class="line"></div>
<div class="line">  my_gmres_solver.set_monitor(my_custom_monitor&lt;<a class="code" href="classviennacl_1_1vector.html">viennacl::vector&lt;ScalarType&gt;</a>, ScalarType, <a class="code" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix&lt;ScalarType&gt;</a> &gt;, &amp;my_monitor_data);</div>
<div class="line">  my_gmres_solver.set_initial_guess(init_guess);</div>
<div class="line"></div>
<div class="line">  my_gmres_solver(A, b);</div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;!!!! TUTORIAL COMPLETED SUCCESSFULLY !!!!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 20 2016 22:32:38 for ViennaCL - The Vienna Computing Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
