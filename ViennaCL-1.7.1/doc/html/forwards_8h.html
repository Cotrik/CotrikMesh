<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/forwards.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Free open-source GPU-accelerated linear algebra and solver library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('forwards_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">forwards.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file provides the forward declarations for the main types used within ViennaCL.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cstddef&gt;</code><br/>
<code>#include &lt;cassert&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &lt;stdexcept&gt;</code><br/>
<code>#include &quot;<a class="el" href="enable__if_8hpp_source.html">viennacl/meta/enable_if.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="version_8hpp_source.html">viennacl/version.hpp</a>&quot;</code><br/>
</div>
<p><a href="forwards_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__assign.html">viennacl::op_assign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing assignment.  <a href="structviennacl_1_1op__assign.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inplace__add.html">viennacl::op_inplace_add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inplace addition.  <a href="structviennacl_1_1op__inplace__add.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inplace__sub.html">viennacl::op_inplace_sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inplace subtraction.  <a href="structviennacl_1_1op__inplace__sub.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing addition.  <a href="structviennacl_1_1op__add.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing subtraction.  <a href="structviennacl_1_1op__sub.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__mult.html">viennacl::op_mult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing multiplication by a scalar.  <a href="structviennacl_1_1op__mult.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing matrix-vector products and element-wise multiplications.  <a href="structviennacl_1_1op__prod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__mat__mat__prod.html">viennacl::op_mat_mat_prod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing matrix-matrix products.  <a href="structviennacl_1_1op__mat__mat__prod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__div.html">viennacl::op_div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing division.  <a href="structviennacl_1_1op__div.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__pow.html">viennacl::op_pow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the power function.  <a href="structviennacl_1_1op__pow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__eq.html">viennacl::op_eq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing equality.  <a href="structviennacl_1_1op__eq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__neq.html">viennacl::op_neq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inequality.  <a href="structviennacl_1_1op__neq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__greater.html">viennacl::op_greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing greater-than.  <a href="structviennacl_1_1op__greater.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__less.html">viennacl::op_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing less-than.  <a href="structviennacl_1_1op__less.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__geq.html">viennacl::op_geq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing greater-than-or-equal-to.  <a href="structviennacl_1_1op__geq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__leq.html">viennacl::op_leq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing less-than-or-equal-to.  <a href="structviennacl_1_1op__leq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sum.html">viennacl::op_sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the summation of a vector.  <a href="structviennacl_1_1op__sum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__row__sum.html">viennacl::op_row_sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the summation of all rows of a matrix.  <a href="structviennacl_1_1op__row__sum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__col__sum.html">viennacl::op_col_sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the summation of all columns of a matrix.  <a href="structviennacl_1_1op__col__sum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__cast.html">viennacl::op_element_cast&lt; OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise casting operations on vectors and matrices.  <a href="structviennacl_1_1op__element__cast.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__binary.html">viennacl::op_element_binary&lt; OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise binary operations (like multiplication) on vectors or matrices.  <a href="structviennacl_1_1op__element__binary.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__unary.html">viennacl::op_element_unary&lt; OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise unary operations (like sin()) on vectors or matrices.  <a href="structviennacl_1_1op__element__unary.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__abs.html">viennacl::op_abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the modulus function for integers.  <a href="structviennacl_1_1op__abs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__acos.html">viennacl::op_acos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the acos() function.  <a href="structviennacl_1_1op__acos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__asin.html">viennacl::op_asin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the asin() function.  <a href="structviennacl_1_1op__asin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__argmax.html">viennacl::op_argmax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for representing the argmax() function.  <a href="structviennacl_1_1op__argmax.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__argmin.html">viennacl::op_argmin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for representing the argmin() function.  <a href="structviennacl_1_1op__argmin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__atan.html">viennacl::op_atan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the atan() function.  <a href="structviennacl_1_1op__atan.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__atan2.html">viennacl::op_atan2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the atan2() function.  <a href="structviennacl_1_1op__atan2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__ceil.html">viennacl::op_ceil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the ceil() function.  <a href="structviennacl_1_1op__ceil.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__cos.html">viennacl::op_cos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the cos() function.  <a href="structviennacl_1_1op__cos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__cosh.html">viennacl::op_cosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the cosh() function.  <a href="structviennacl_1_1op__cosh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__exp.html">viennacl::op_exp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the exp() function.  <a href="structviennacl_1_1op__exp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fabs.html">viennacl::op_fabs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fabs() function.  <a href="structviennacl_1_1op__fabs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fdim.html">viennacl::op_fdim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fdim() function.  <a href="structviennacl_1_1op__fdim.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__floor.html">viennacl::op_floor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the floor() function.  <a href="structviennacl_1_1op__floor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmax.html">viennacl::op_fmax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmax() function.  <a href="structviennacl_1_1op__fmax.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmin.html">viennacl::op_fmin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmin() function.  <a href="structviennacl_1_1op__fmin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmod.html">viennacl::op_fmod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmod() function.  <a href="structviennacl_1_1op__fmod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__log.html">viennacl::op_log</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the log() function.  <a href="structviennacl_1_1op__log.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__log10.html">viennacl::op_log10</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the log10() function.  <a href="structviennacl_1_1op__log10.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sin.html">viennacl::op_sin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sin() function.  <a href="structviennacl_1_1op__sin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sinh.html">viennacl::op_sinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sinh() function.  <a href="structviennacl_1_1op__sinh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sqrt.html">viennacl::op_sqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sqrt() function.  <a href="structviennacl_1_1op__sqrt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__tan.html">viennacl::op_tan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the tan() function.  <a href="structviennacl_1_1op__tan.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__tanh.html">viennacl::op_tanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the tanh() function.  <a href="structviennacl_1_1op__tanh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__matrix__diag.html">viennacl::op_matrix_diag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the (off-)diagonal of a matrix.  <a href="structviennacl_1_1op__matrix__diag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__vector__diag.html">viennacl::op_vector_diag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a matrix given by a vector placed on a certain (off-)diagonal.  <a href="structviennacl_1_1op__vector__diag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__row.html">viennacl::op_row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the extraction of a matrix row to a vector.  <a href="structviennacl_1_1op__row.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__column.html">viennacl::op_column</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the extraction of a matrix column to a vector.  <a href="structviennacl_1_1op__column.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inner__prod.html">viennacl::op_inner_prod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inner products of two vectors.  <a href="structviennacl_1_1op__inner__prod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__1.html">viennacl::op_norm_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the 1-norm of a vector.  <a href="structviennacl_1_1op__norm__1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__2.html">viennacl::op_norm_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the 2-norm of a vector.  <a href="structviennacl_1_1op__norm__2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__inf.html">viennacl::op_norm_inf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the inf-norm of a vector.  <a href="structviennacl_1_1op__norm__inf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__max.html">viennacl::op_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the maximum of a vector.  <a href="structviennacl_1_1op__max.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__min.html">viennacl::op_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the minimum of a vector.  <a href="structviennacl_1_1op__min.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__frobenius.html">viennacl::op_norm_frobenius</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the Frobenius-norm of a matrix.  <a href="structviennacl_1_1op__norm__frobenius.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing transposed matrices.  <a href="structviennacl_1_1op__trans.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__flip__sign.html">viennacl::op_flip_sign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing sign flips (for scalars only. Vectors and matrices use the standard multiplication by the scalar -1.0)  <a href="structviennacl_1_1op__flip__sign.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar&lt; TYPE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type like float or double.  <a href="classviennacl_1_1scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression&lt; LHS, RHS, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy for scalar expressions (e.g. from inner vector products)  <a href="classviennacl_1_1scalar__expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1entry__proxy.html">viennacl::entry_proxy&lt; SCALARTYPE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1entry__proxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__entry__proxy.html">viennacl::const_entry_proxy&lt; SCALARTYPE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1const__entry__proxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression&lt; LHS, RHS, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression template class that represents a binary operation that yields a vector.  <a href="classviennacl_1_1vector__expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__iterator.html">viennacl::vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!  <a href="classviennacl_1_1vector__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html">viennacl::const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated. VERY SLOW!!  <a href="classviennacl_1_1const__vector__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1implicit__vector__base.html">viennacl::implicit_vector_base&lt; NumericT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for representing vectors where the entries are not all stored explicitly.  <a href="classviennacl_1_1implicit__vector__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1zero__vector.html">viennacl::zero_vector&lt; NumericT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1unit__vector.html">viennacl::unit_vector&lt; NumericT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise.  <a href="structviennacl_1_1unit__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1one__vector.html">viennacl::one_vector&lt; SCALARTYPE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1scalar__vector.html">viennacl::scalar_vector&lt; NumericT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x. ">vector_range</a>, or vector_slize only.  <a href="structviennacl_1_1scalar__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base&lt; NumericT, SizeT, DistanceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for dense vectors, vector ranges, and vector slices.  <a href="classviennacl_1_1vector__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__tuple.html">viennacl::vector_tuple&lt; ScalarT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple class holding pointers to multiple vectors. Mainly used as a temporary object returned from <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie()</a>.  <a href="classviennacl_1_1vector__tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major__tag.html">viennacl::row_major_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for indicating row-major layout of a matrix. Not passed to the matrix directly, see <a class="el" href="structviennacl_1_1row__major.html" title="A tag for row-major storage of a dense matrix. ">row_major</a> type.  <a href="structviennacl_1_1row__major__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major__tag.html">viennacl::column_major_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for indicating column-major layout of a matrix. Not passed to the matrix directly, see <a class="el" href="structviennacl_1_1row__major.html" title="A tag for row-major storage of a dense matrix. ">row_major</a> type.  <a href="structviennacl_1_1column__major__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major.html">viennacl::row_major</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for row-major storage of a dense matrix.  <a href="structviennacl_1_1row__major.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major.html">viennacl::column_major</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for column-major storage of a dense matrix.  <a href="structviennacl_1_1column__major.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression&lt; LHS, RHS, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression template class for representing a tree of expressions which ultimately result in a matrix.  <a href="classviennacl_1_1matrix__expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__iterator.html">viennacl::matrix_iterator&lt; ROWCOL, MATRIXTYPE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base&lt; NumericT, SizeT, DistanceT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1implicit__matrix__base.html">viennacl::implicit_matrix_base&lt; NumericT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representing matrices where the individual entries are not all stored explicitly, e.g. identity_matrix&lt;&gt;  <a href="classviennacl_1_1implicit__matrix__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1identity__matrix.html">viennacl::identity_matrix&lt; NumericT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x. ">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1identity__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__matrix.html">viennacl::zero_matrix&lt; NumericT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of zeros only. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x. ">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1zero__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__matrix.html">viennacl::scalar_matrix&lt; NumericT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x. ">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1scalar__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix&lt; NumericT, AlignmentV &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix in compressed sparse rows format.  <a href="classviennacl_1_1compressed__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">viennacl::compressed_compressed_matrix&lt; NumericT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows carry nonzero entries.  <a href="classviennacl_1_1compressed__compressed__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix&lt; NumericT, AlignmentV &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row and column indices and val denotes the entry.  <a href="classviennacl_1_1coordinate__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix&lt; NumericT, AlignmentV &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix class using the ELLPACK format for storing the nonzeros.  <a href="classviennacl_1_1ell__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1sliced__ell__matrix.html">viennacl::sliced_ell_matrix&lt; ScalarT, IndexT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix class using the sliced ELLPACK with parameters C, <img class="formulaInl" alt="$ \sigma $" src="form_0.png"/>.  <a href="classviennacl_1_1sliced__ell__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix&lt; SCALARTYPE, ALIGNMENT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros.  <a href="classviennacl_1_1hyb__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1circulant__matrix.html">viennacl::circulant_matrix&lt; NumericT, AlignmentV &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Circulant matrix class.  <a href="classviennacl_1_1circulant__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1hankel__matrix.html">viennacl::hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Hankel matrix class.  <a href="classviennacl_1_1hankel__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1toeplitz__matrix.html">viennacl::toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Toeplitz matrix class.  <a href="classviennacl_1_1toeplitz__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vandermonde__matrix.html">viennacl::vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Vandermonde matrix class.  <a href="classviennacl_1_1vandermonde__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1basic__range.html">viennacl::basic_range&lt; SizeType, DistanceType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range class that refers to an interval [start, stop), where 'start' is included, and 'stop' is excluded.  <a href="classviennacl_1_1basic__range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1basic__slice.html">viennacl::basic_slice&lt; SizeType, DistanceType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice class that refers to an interval [start, stop), where 'start' is included, and 'stop' is excluded.  <a href="classviennacl_1_1basic__slice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range&lt; VectorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing non-strided subvectors of a bigger vector x.  <a href="classviennacl_1_1vector__range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice&lt; VectorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing strided subvectors of a bigger vector x.  <a href="classviennacl_1_1vector__slice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__range.html">viennacl::matrix_range&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing non-strided submatrices of a bigger matrix A.  <a href="classviennacl_1_1matrix__range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__slice.html">viennacl::matrix_slice&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing strided submatrices of a bigger matrix A.  <a href="classviennacl_1_1matrix__slice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__cpu__scalar.html">viennacl::is_cpu_scalar&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type is a host scalar type (e.g. float, double)  <a href="structviennacl_1_1is__cpu__scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type is a viennacl::scalar&lt;&gt;  <a href="structviennacl_1_1is__scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__flip__sign__scalar.html">viennacl::is_flip_sign_scalar&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type represents a sign flip on a viennacl::scalar&lt;&gt;  <a href="structviennacl_1_1is__flip__sign__scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether the provided type represents a scalar (either host, from ViennaCL, or a flip-sign proxy)  <a href="structviennacl_1_1is__any__scalar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__vector.html">viennacl::is_any_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for a type being either <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices. ">vector_base</a> or <a class="el" href="classviennacl_1_1implicit__vector__base.html" title="Common base class for representing vectors where the entries are not all stored explicitly. ">implicit_vector_base</a>.  <a href="structviennacl_1_1is__any__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__matrix.html">viennacl::is_any_dense_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for either <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a> or <a class="el" href="classviennacl_1_1implicit__matrix__base.html" title="Base class for representing matrices where the individual entries are not all stored explicitly...">implicit_matrix_base</a>.  <a href="structviennacl_1_1is__any__dense__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__row__major.html">viennacl::is_row_major&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix has a row-major layout.  <a href="structviennacl_1_1is__row__major.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__compressed__matrix.html">viennacl::is_compressed_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a> (CSR format)  <a href="structviennacl_1_1is__compressed__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__coordinate__matrix.html">viennacl::is_coordinate_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> (COO format)  <a href="structviennacl_1_1is__coordinate__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ell__matrix.html">viennacl::is_ell_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is an <a class="el" href="classviennacl_1_1ell__matrix.html" title="Sparse matrix class using the ELLPACK format for storing the nonzeros. ">ell_matrix</a> (ELL format)  <a href="structviennacl_1_1is__ell__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__sliced__ell__matrix.html">viennacl::is_sliced_ell_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1sliced__ell__matrix.html" title="Sparse matrix class using the sliced ELLPACK with parameters C, . ">sliced_ell_matrix</a> (SELL-C- <img class="formulaInl" alt="$ \sigma $" src="form_0.png"/> format)  <a href="structviennacl_1_1is__sliced__ell__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hyb__matrix.html">viennacl::is_hyb_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a> (hybrid format: ELL plus CSR)  <a href="structviennacl_1_1is__hyb__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether the provided type is one of the sparse matrix types (<a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format. ">compressed_matrix</a>, <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>, etc.)  <a href="structviennacl_1_1is__any__sparse__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__circulant__matrix.html">viennacl::is_circulant_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a circulant matrix.  <a href="structviennacl_1_1is__circulant__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hankel__matrix.html">viennacl::is_hankel_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Hankel matrix.  <a href="structviennacl_1_1is__hankel__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__toeplitz__matrix.html">viennacl::is_toeplitz_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Toeplitz matrix.  <a href="structviennacl_1_1is__toeplitz__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__vandermonde__matrix.html">viennacl::is_vandermonde_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Vandermonde matrix.  <a href="structviennacl_1_1is__vandermonde__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__structured__matrix.html">viennacl::is_any_dense_structured_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether the provided type is any of the dense structured matrix types (circulant, Hankel, etc.)  <a href="structviennacl_1_1is__any__dense__structured__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1memory__exception.html">viennacl::memory_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class in case of memory errors.  <a href="classviennacl_1_1memory__exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1cuda__not__available__exception.html">viennacl::cuda_not_available_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__on__diagonal__exception.html">viennacl::zero_on_diagonal_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1unknown__norm__exception.html">viennacl::unknown_norm_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___i_t_e_r_a_t_o_r___i_n_c_r_e_m_e_n_t_e_r.html">viennacl::tools::MATRIX_ITERATOR_INCREMENTER&lt; ROWCOL, MATRIXTYPE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for incrementing an iterator in a dense matrix.  <a href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___i_t_e_r_a_t_o_r___i_n_c_r_e_m_e_n_t_e_r.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix.  <a href="structviennacl_1_1linalg_1_1lower__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix.  <a href="structviennacl_1_1linalg_1_1upper__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__lower__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__upper__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the use of no preconditioner.  <a href="classviennacl_1_1linalg_1_1no__precond.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceviennacl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html">viennacl</a></td></tr>
<tr class="memdesc:namespaceviennacl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1backend"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend.html">viennacl::backend</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1backend"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace providing routines for handling the different memory domains. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1tools"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html">viennacl::tools</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1tools"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for various tools used within ViennaCL. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html">viennacl::linalg</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides all linear algebra operations which are not covered by operator overloads. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html">viennacl::linalg::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace holding implementation details for linear algebra routines. Usually not of interest for a library user. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1backend_1_1cpu__ram"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cpu__ram.html">viennacl::backend::cpu_ram</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1backend_1_1cpu__ram"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides implementations for handling memory buffers in CPU RAM. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1backend_1_1cpu__ram_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cpu__ram_1_1detail.html">viennacl::backend::cpu_ram::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1backend_1_1cpu__ram_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds implementation details for handling memory buffers in CPU RAM. Not intended for direct use by library users. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1backend_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cuda.html">viennacl::backend::cuda</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1backend_1_1cuda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides implementations for handling CUDA memory buffers. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1backend_1_1cuda_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cuda_1_1detail.html">viennacl::backend::cuda::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1backend_1_1cuda_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds implementation details for handling CUDA memory buffers. Not intended for direct use by library users. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1backend_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1detail.html">viennacl::backend::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1backend_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details for the generic memory backend interface. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1backend_1_1opencl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1opencl.html">viennacl::backend::opencl</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1backend_1_1opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides implementations for handling OpenCL memory buffers. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1backend_1_1opencl_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1opencl_1_1detail.html">viennacl::backend::opencl::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1backend_1_1opencl_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds implementation details for handling OpenCL memory buffers. Not intended for direct use by library users. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail.html">viennacl::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds implementation details for functionality in the main viennacl-namespace. Not intended for direct use by library users. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1detail_1_1fft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail_1_1fft.html">viennacl::detail::fft</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1detail_1_1fft"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper namespace for fast Fourier transforms. Not to be used directly by library users. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html">viennacl::detail::fft::FFT_DATA_ORDER</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper namespace for fast-Fourier transformation. Deprecated. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1device__specific"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1device__specific.html">viennacl::device_specific</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1device__specific"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an OpenCL kernel generator. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1device__specific_1_1autotune"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1device__specific_1_1autotune.html">viennacl::device_specific::autotune</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1device__specific_1_1autotune"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the implementation for tuning the kernels for a particular device. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1device__specific_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1device__specific_1_1detail.html">viennacl::device_specific::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1device__specific_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation details of the kernel generator. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1device__specific_1_1profiles"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1device__specific_1_1profiles.html">viennacl::device_specific::profiles</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1device__specific_1_1profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace holding the various device-specific parameters for generating the best kernels. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1device__specific_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1device__specific_1_1utils.html">viennacl::device_specific::utils</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1device__specific_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains various helper routines for kernel generation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io.html">viennacl::io</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides basic input-output functionality. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1io_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io_1_1detail.html">viennacl::io::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1io_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details for IO functionality. Usually not of interest for a library user. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1io_1_1tag"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io_1_1tag.html">viennacl::io::tag</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1io_1_1tag"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace holding the various XML tag definitions for the kernel parameter tuning facility. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1io_1_1val"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io_1_1val.html">viennacl::io::val</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1io_1_1val"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace holding the various XML strings for the kernel parameter tuning facility. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1cuda.html">viennacl::linalg::cuda</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1cuda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds all CUDA compute kernels used by ViennaCL. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1cuda_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1cuda_1_1detail.html">viennacl::linalg::cuda::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1cuda_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for the CUDA linear algebra backend. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1detail_1_1amg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html">viennacl::linalg::detail::amg</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1detail_1_1amg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation namespace for algebraic multigrid preconditioner. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1detail_1_1spai"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html">viennacl::linalg::detail::spai</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1detail_1_1spai"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation namespace for sparse approximate inverse preconditioner. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1host__based"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html">viennacl::linalg::host_based</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1host__based"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds all compute kernels with conventional host-based execution (buffers in CPU RAM). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1host__based_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html">viennacl::linalg::host_based::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1host__based_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for the host-based linear algebra backend. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1kernels"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1kernels.html">viennacl::linalg::kernels</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1kernels"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the OpenCL kernels. Deprecated, will be moved to <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html" title="Holds all routines providing OpenCL linear algebra operations. ">viennacl::linalg::opencl</a> in future releases. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1opencl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html">viennacl::linalg::opencl</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds all routines providing OpenCL linear algebra operations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1opencl_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html">viennacl::linalg::opencl::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1opencl_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for OpenCL-accelerated linear algebra operations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1opencl_1_1kernels"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl_1_1kernels.html">viennacl::linalg::opencl::kernels</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1opencl_1_1kernels"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the OpenCL kernel generation functions for a predefined set of functionality. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1linalg_1_1opencl_1_1kernels_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl_1_1kernels_1_1detail.html">viennacl::linalg::opencl::kernels::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1linalg_1_1opencl_1_1kernels_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details for the predefined OpenCL kernels. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1ocl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1ocl.html">viennacl::ocl</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1ocl"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenCL backend. Manages platforms, contexts, buffers, kernels, etc. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1result__of"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1result__of.html">viennacl::result_of</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1result__of"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing many meta-functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1tools_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools_1_1detail.html">viennacl::tools::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1tools_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation details for the tools. Usually not of interest for the library user. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1traits.html">viennacl::traits</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace providing traits-information as well as generic wrappers to common routines for vectors and matrices such as <a class="el" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.) ">size()</a> or <a class="el" href="namespaceviennacl_1_1traits.html#a22ab64b1df12a9da0423e5cad52ea367" title="Generic routine for setting all entries of a vector to zero. This is the version for non-ViennaCL obj...">clear()</a> <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1scheduler"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1scheduler.html">viennacl::scheduler</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1scheduler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the scheduling functionality which allows for dynamic kernel generation as well as the fusion of multiple statements into a single kernel. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1scheduler_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1scheduler_1_1detail.html">viennacl::scheduler::detail</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1scheduler_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details for the scheduler. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviennacl_1_1scheduler_1_1result__of"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1scheduler_1_1result__of.html">viennacl::scheduler::result_of</a></td></tr>
<tr class="memdesc:namespaceviennacl_1_1scheduler_1_1result__of"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunctions used for the scheduler. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a98a0afcc513111ffa0bd138f891930df"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a98a0afcc513111ffa0bd138f891930df">viennacl::vcl_size_t</a></td></tr>
<tr class="separator:a98a0afcc513111ffa0bd138f891930df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad612e26a65487b7e747c18c678ffd9"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#afad612e26a65487b7e747c18c678ffd9">viennacl::vcl_ptrdiff_t</a></td></tr>
<tr class="separator:afad612e26a65487b7e747c18c678ffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92c62d9fd59870c1f6b881e391d32aa"><td class="memItemLeft" align="right" valign="top">typedef basic_range&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae92c62d9fd59870c1f6b881e391d32aa">viennacl::range</a></td></tr>
<tr class="separator:ae92c62d9fd59870c1f6b881e391d32aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa84915fbd15d5fb318c41f715c2b337"><td class="memItemLeft" align="right" valign="top">typedef basic_slice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaa84915fbd15d5fb318c41f715c2b337">viennacl::slice</a></td></tr>
<tr class="separator:aaa84915fbd15d5fb318c41f715c2b337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a00b40450b6b2fd87aad3527d9b2084b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8">viennacl::memory_types</a> { <a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8a020ede27e1975479bce748e0e4ea3c7f">viennacl::MEMORY_NOT_INITIALIZED</a>, 
<a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8a427356f0fb1b8d32b28f37e36b272df4">viennacl::MAIN_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8adb37af613f34867568e4f6cf720c68b1">viennacl::OPENCL_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#a00b40450b6b2fd87aad3527d9b2084b8ab58facda25e2c7e20d9fe1b5e62f46d2">viennacl::CUDA_MEMORY</a>
 }</td></tr>
<tr class="separator:a00b40450b6b2fd87aad3527d9b2084b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2e9ed3e4d9fb0258840837aaa722ac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#adc2e9ed3e4d9fb0258840837aaa722ac">viennacl::linalg::detail::row_info_types</a> { <a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#adc2e9ed3e4d9fb0258840837aaa722aca2546ac1effa27e3727e38c15fe13cc08">viennacl::linalg::detail::SPARSE_ROW_NORM_INF</a> = 0, 
<a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#adc2e9ed3e4d9fb0258840837aaa722aca4229608063b20108bf18fbf2a166a642">viennacl::linalg::detail::SPARSE_ROW_NORM_1</a>, 
<a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#adc2e9ed3e4d9fb0258840837aaa722aca61e9ff7ddcbf0446b560f94907c24e11">viennacl::linalg::detail::SPARSE_ROW_NORM_2</a>, 
<a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#adc2e9ed3e4d9fb0258840837aaa722aca0750e54730307e2c1d1b6bfaabc7a1dd">viennacl::linalg::detail::SPARSE_ROW_DIAGONAL</a>
 }</td></tr>
<tr class="separator:adc2e9ed3e4d9fb0258840837aaa722ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac9c1f7718f95bf4ed4cddc264b24c623"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr class="memitem:ac9c1f7718f95bf4ed4cddc264b24c623"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9c1f7718f95bf4ed4cddc264b24c623">viennacl::copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr class="separator:ac9c1f7718f95bf4ed4cddc264b24c623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac6b8ed7edad298388c5936e476f783"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr class="memitem:aaac6b8ed7edad298388c5936e476f783"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaac6b8ed7edad298388c5936e476f783">viennacl::copy</a> (const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr class="separator:aaac6b8ed7edad298388c5936e476f783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9139574d3d99501f0ef6c3fc322e548"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr class="memitem:ac9139574d3d99501f0ef6c3fc322e548"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9139574d3d99501f0ef6c3fc322e548">viennacl::copy</a> (const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr class="separator:ac9139574d3d99501f0ef6c3fc322e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5c8726b45bc89a523ca2fa8c42107a"><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr class="memitem:aaa5c8726b45bc89a523ca2fa8c42107a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaa5c8726b45bc89a523ca2fa8c42107a">viennacl::fast_copy</a> (const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr class="separator:aaa5c8726b45bc89a523ca2fa8c42107a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3331c10c42bdec311e4c6b8665b01ac"><td class="memTemplParams" colspan="2">template&lt;typename CPU_ITERATOR , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:ab3331c10c42bdec311e4c6b8665b01ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab3331c10c42bdec311e4c6b8665b01ac">viennacl::fast_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr class="separator:ab3331c10c42bdec311e4c6b8665b01ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b596f98d234d40fe9460d0077d1fcc3"><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:a7b596f98d234d40fe9460d0077d1fcc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7b596f98d234d40fe9460d0077d1fcc3">viennacl::linalg::convolve_i</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;output)</td></tr>
<tr class="separator:a7b596f98d234d40fe9460d0077d1fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ab8924636e24b01c6bad13a7321343"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28ab8924636e24b01c6bad13a7321343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; T &gt;<br class="typebreak"/>
, const vector_base&lt; T &gt;<br class="typebreak"/>
, op_element_binary&lt; op_prod &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a28ab8924636e24b01c6bad13a7321343">viennacl::linalg::element_prod</a> (vector_base&lt; T &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, vector_base&lt; T &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="separator:a28ab8924636e24b01c6bad13a7321343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3207a7759c34cfe4e961aabadd616a13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3207a7759c34cfe4e961aabadd616a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; T &gt;<br class="typebreak"/>
, const vector_base&lt; T &gt;<br class="typebreak"/>
, op_element_binary&lt; op_div &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3207a7759c34cfe4e961aabadd616a13">viennacl::linalg::element_div</a> (vector_base&lt; T &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a1d3b09c2337808223ca760c55bdf5414">v1</a>, vector_base&lt; T &gt; const &amp;<a class="el" href="global__variables_8cpp.html#a9b48d95dbfbe8e26ae8911c753406d37">v2</a>)</td></tr>
<tr class="separator:a3207a7759c34cfe4e961aabadd616a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994b34490c41579a04fbd4f95ce00dd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a994b34490c41579a04fbd4f95ce00dd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a994b34490c41579a04fbd4f95ce00dd4">viennacl::linalg::inner_prod_impl</a> (vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a994b34490c41579a04fbd4f95ce00dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors - dispatcher interface.  <a href="#a994b34490c41579a04fbd4f95ce00dd4">More...</a><br/></td></tr>
<tr class="separator:a994b34490c41579a04fbd4f95ce00dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2674678361df8200d391360dc6b8631c"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a2674678361df8200d391360dc6b8631c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2674678361df8200d391360dc6b8631c">viennacl::linalg::inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a2674678361df8200d391360dc6b8631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c256ba255b9d600f2682f3c10ef1e8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a43c256ba255b9d600f2682f3c10ef1e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a43c256ba255b9d600f2682f3c10ef1e8">viennacl::linalg::inner_prod_impl</a> (vector_base&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a43c256ba255b9d600f2682f3c10ef1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b652a0b60f992dc7c2c89c8305c628"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename T &gt; </td></tr>
<tr class="memitem:a34b652a0b60f992dc7c2c89c8305c628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a34b652a0b60f992dc7c2c89c8305c628">viennacl::linalg::inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a34b652a0b60f992dc7c2c89c8305c628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e24897b81aa448d7ba7bcb4b7c0befa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e24897b81aa448d7ba7bcb4b7c0befa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e24897b81aa448d7ba7bcb4b7c0befa">viennacl::linalg::inner_prod_cpu</a> (vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr class="memdesc:a6e24897b81aa448d7ba7bcb4b7c0befa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors with the final reduction step on the CPU - dispatcher interface.  <a href="#a6e24897b81aa448d7ba7bcb4b7c0befa">More...</a><br/></td></tr>
<tr class="separator:a6e24897b81aa448d7ba7bcb4b7c0befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be57ce7d327b479a4e9dc8bf0cb43ac"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a0be57ce7d327b479a4e9dc8bf0cb43ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0be57ce7d327b479a4e9dc8bf0cb43ac">viennacl::linalg::inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr class="separator:a0be57ce7d327b479a4e9dc8bf0cb43ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e83011f9d11da294199a39c8ca24af9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a6e83011f9d11da294199a39c8ca24af9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e83011f9d11da294199a39c8ca24af9">viennacl::linalg::inner_prod_cpu</a> (vector_base&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr class="separator:a6e83011f9d11da294199a39c8ca24af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592732c3d41ad443d78d8976cdf511e4"><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename S3 &gt; </td></tr>
<tr class="memitem:a592732c3d41ad443d78d8976cdf511e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a592732c3d41ad443d78d8976cdf511e4">viennacl::linalg::inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, S3 &amp;result)</td></tr>
<tr class="separator:a592732c3d41ad443d78d8976cdf511e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126a98d0d6306dcb6079dd242d7570d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6126a98d0d6306dcb6079dd242d7570d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6126a98d0d6306dcb6079dd242d7570d">viennacl::linalg::norm_1_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a6126a98d0d6306dcb6079dd242d7570d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector - dispatcher interface.  <a href="#a6126a98d0d6306dcb6079dd242d7570d">More...</a><br/></td></tr>
<tr class="separator:a6126a98d0d6306dcb6079dd242d7570d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2487c579ee752a9fcc31c12d0bddf604"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a2487c579ee752a9fcc31c12d0bddf604"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2487c579ee752a9fcc31c12d0bddf604">viennacl::linalg::norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a2487c579ee752a9fcc31c12d0bddf604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf0050426d4b7147d50588919f690da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcf0050426d4b7147d50588919f690da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abcf0050426d4b7147d50588919f690da">viennacl::linalg::norm_1_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:abcf0050426d4b7147d50588919f690da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU.  <a href="#abcf0050426d4b7147d50588919f690da">More...</a><br/></td></tr>
<tr class="separator:abcf0050426d4b7147d50588919f690da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215de6e882e7e3ac0b62da887a88b827"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:a215de6e882e7e3ac0b62da887a88b827"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a215de6e882e7e3ac0b62da887a88b827">viennacl::linalg::norm_1_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:a215de6e882e7e3ac0b62da887a88b827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a215de6e882e7e3ac0b62da887a88b827">More...</a><br/></td></tr>
<tr class="separator:a215de6e882e7e3ac0b62da887a88b827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf5182473bb609dedc9c85148553b55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aabf5182473bb609dedc9c85148553b55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aabf5182473bb609dedc9c85148553b55">viennacl::linalg::norm_2_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:aabf5182473bb609dedc9c85148553b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - dispatcher interface.  <a href="#aabf5182473bb609dedc9c85148553b55">More...</a><br/></td></tr>
<tr class="separator:aabf5182473bb609dedc9c85148553b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cab21b7d6b7e0e73c2ca2c20170eafd"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a2cab21b7d6b7e0e73c2ca2c20170eafd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2cab21b7d6b7e0e73c2ca2c20170eafd">viennacl::linalg::norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a2cab21b7d6b7e0e73c2ca2c20170eafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#a2cab21b7d6b7e0e73c2ca2c20170eafd">More...</a><br/></td></tr>
<tr class="separator:a2cab21b7d6b7e0e73c2ca2c20170eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029d42a0d83d6db9f4737ee3443cbeb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a029d42a0d83d6db9f4737ee3443cbeb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a029d42a0d83d6db9f4737ee3443cbeb0">viennacl::linalg::norm_2_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a029d42a0d83d6db9f4737ee3443cbeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - dispatcher interface.  <a href="#a029d42a0d83d6db9f4737ee3443cbeb0">More...</a><br/></td></tr>
<tr class="separator:a029d42a0d83d6db9f4737ee3443cbeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7076e4aae076d5038c880273414dda"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:a6f7076e4aae076d5038c880273414dda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6f7076e4aae076d5038c880273414dda">viennacl::linalg::norm_2_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:a6f7076e4aae076d5038c880273414dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a6f7076e4aae076d5038c880273414dda">More...</a><br/></td></tr>
<tr class="separator:a6f7076e4aae076d5038c880273414dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e31dfc478858db3fc0febbf9bf360d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e31dfc478858db3fc0febbf9bf360d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e31dfc478858db3fc0febbf9bf360d0">viennacl::linalg::norm_inf_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a6e31dfc478858db3fc0febbf9bf360d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a6e31dfc478858db3fc0febbf9bf360d0">More...</a><br/></td></tr>
<tr class="separator:a6e31dfc478858db3fc0febbf9bf360d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2940be20884af6f718f1ef1882e4b09e"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:a2940be20884af6f718f1ef1882e4b09e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2940be20884af6f718f1ef1882e4b09e">viennacl::linalg::norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:a2940be20884af6f718f1ef1882e4b09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#a2940be20884af6f718f1ef1882e4b09e">More...</a><br/></td></tr>
<tr class="separator:a2940be20884af6f718f1ef1882e4b09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5a2876bc65af939fc449ec07f33e6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c5a2876bc65af939fc449ec07f33e6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6c5a2876bc65af939fc449ec07f33e6f">viennacl::linalg::norm_inf_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a6c5a2876bc65af939fc449ec07f33e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector with final reduction on the CPU.  <a href="#a6c5a2876bc65af939fc449ec07f33e6f">More...</a><br/></td></tr>
<tr class="separator:a6c5a2876bc65af939fc449ec07f33e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79e3c0b81933fcd016f62ede5daa94b"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:aa79e3c0b81933fcd016f62ede5daa94b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa79e3c0b81933fcd016f62ede5daa94b">viennacl::linalg::norm_inf_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:aa79e3c0b81933fcd016f62ede5daa94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#aa79e3c0b81933fcd016f62ede5daa94b">More...</a><br/></td></tr>
<tr class="separator:aa79e3c0b81933fcd016f62ede5daa94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ba2d9041f7c09bfb2f0ec65f8cf63c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4ba2d9041f7c09bfb2f0ec65f8cf63c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac4ba2d9041f7c09bfb2f0ec65f8cf63c">viennacl::linalg::max_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:ac4ba2d9041f7c09bfb2f0ec65f8cf63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a454946f278e2e94199871f55c081a"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:ac7a454946f278e2e94199871f55c081a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac7a454946f278e2e94199871f55c081a">viennacl::linalg::max_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:ac7a454946f278e2e94199871f55c081a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c55f3b63164f620aace12af5366cd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94c55f3b63164f620aace12af5366cd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a94c55f3b63164f620aace12af5366cd8">viennacl::linalg::max_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a94c55f3b63164f620aace12af5366cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum of a vector with final reduction on the CPU.  <a href="#a94c55f3b63164f620aace12af5366cd8">More...</a><br/></td></tr>
<tr class="separator:a94c55f3b63164f620aace12af5366cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af754ca05f664675f759aca2de035bc7a"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:af754ca05f664675f759aca2de035bc7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af754ca05f664675f759aca2de035bc7a">viennacl::linalg::max_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:af754ca05f664675f759aca2de035bc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#af754ca05f664675f759aca2de035bc7a">More...</a><br/></td></tr>
<tr class="separator:af754ca05f664675f759aca2de035bc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63df0f54d270c1f43f87f21305500f5e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63df0f54d270c1f43f87f21305500f5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a63df0f54d270c1f43f87f21305500f5e">viennacl::linalg::min_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a63df0f54d270c1f43f87f21305500f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add42dc3329c401285f39cb6d6e0000e2"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:add42dc3329c401285f39cb6d6e0000e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#add42dc3329c401285f39cb6d6e0000e2">viennacl::linalg::min_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:add42dc3329c401285f39cb6d6e0000e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0dc4f1adb29d19e1b55519024eeb4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a0dc4f1adb29d19e1b55519024eeb4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5a0dc4f1adb29d19e1b55519024eeb4f">viennacl::linalg::min_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a5a0dc4f1adb29d19e1b55519024eeb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum of a vector with final reduction on the CPU.  <a href="#a5a0dc4f1adb29d19e1b55519024eeb4f">More...</a><br/></td></tr>
<tr class="separator:a5a0dc4f1adb29d19e1b55519024eeb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f228d570bffac37abb106970b08532"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:ad6f228d570bffac37abb106970b08532"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad6f228d570bffac37abb106970b08532">viennacl::linalg::min_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:ad6f228d570bffac37abb106970b08532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#ad6f228d570bffac37abb106970b08532">More...</a><br/></td></tr>
<tr class="separator:ad6f228d570bffac37abb106970b08532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ec50ed65cf65aac0a0d01706370f39"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98ec50ed65cf65aac0a0d01706370f39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a98ec50ed65cf65aac0a0d01706370f39">viennacl::linalg::sum_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a98ec50ed65cf65aac0a0d01706370f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4727940e3c347e78e154a9df15a8d74"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr class="memitem:ad4727940e3c347e78e154a9df15a8d74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad4727940e3c347e78e154a9df15a8d74">viennacl::linalg::sum_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:ad4727940e3c347e78e154a9df15a8d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45afae73aac6a14d0b5c46053ff3b08b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45afae73aac6a14d0b5c46053ff3b08b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a45afae73aac6a14d0b5c46053ff3b08b">viennacl::linalg::sum_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr class="memdesc:a45afae73aac6a14d0b5c46053ff3b08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of a vector with final reduction on the CPU.  <a href="#a45afae73aac6a14d0b5c46053ff3b08b">More...</a><br/></td></tr>
<tr class="separator:a45afae73aac6a14d0b5c46053ff3b08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd49659a7210abda3960382288a7160"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr class="memitem:a4fd49659a7210abda3960382288a7160"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4fd49659a7210abda3960382288a7160">viennacl::linalg::sum_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr class="memdesc:a4fd49659a7210abda3960382288a7160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a4fd49659a7210abda3960382288a7160">More...</a><br/></td></tr>
<tr class="separator:a4fd49659a7210abda3960382288a7160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d50400363dab7d4edef7d9f67954c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8d50400363dab7d4edef7d9f67954c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af8d50400363dab7d4edef7d9f67954c9">viennacl::linalg::norm_frobenius_impl</a> (matrix_base&lt; T &gt; const &amp;A, scalar&lt; T &gt; &amp;result)</td></tr>
<tr class="memdesc:af8d50400363dab7d4edef7d9f67954c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Frobenius norm of a matrix - dispatcher interface.  <a href="#af8d50400363dab7d4edef7d9f67954c9">More...</a><br/></td></tr>
<tr class="separator:af8d50400363dab7d4edef7d9f67954c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefc10657837355dd686f359e2f2bdd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acefc10657837355dd686f359e2f2bdd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acefc10657837355dd686f359e2f2bdd3">viennacl::linalg::norm_frobenius_cpu</a> (matrix_base&lt; T &gt; const &amp;A, T &amp;result)</td></tr>
<tr class="memdesc:acefc10657837355dd686f359e2f2bdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Frobenius norm of a vector with final reduction on the CPU.  <a href="#acefc10657837355dd686f359e2f2bdd3">More...</a><br/></td></tr>
<tr class="separator:acefc10657837355dd686f359e2f2bdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ca8c9792940a5cf845c844495b2f49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94ca8c9792940a5cf845c844495b2f49"><td class="memTemplItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a94ca8c9792940a5cf845c844495b2f49">viennacl::linalg::index_norm_inf</a> (vector_base&lt; T &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a94ca8c9792940a5cf845c844495b2f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#a94ca8c9792940a5cf845c844495b2f49">More...</a><br/></td></tr>
<tr class="separator:a94ca8c9792940a5cf845c844495b2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561f11b3404e4657b4e8dbc971488836"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr class="memitem:a561f11b3404e4657b4e8dbc971488836"><td class="memTemplItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a561f11b3404e4657b4e8dbc971488836">viennacl::linalg::index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec)</td></tr>
<tr class="memdesc:a561f11b3404e4657b4e8dbc971488836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a561f11b3404e4657b4e8dbc971488836">More...</a><br/></td></tr>
<tr class="separator:a561f11b3404e4657b4e8dbc971488836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc6db8d806f67c24f93eaaded84b853"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aafc6db8d806f67c24f93eaaded84b853"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aafc6db8d806f67c24f93eaaded84b853">viennacl::linalg::prod_impl</a> (const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;mat, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:aafc6db8d806f67c24f93eaaded84b853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#aafc6db8d806f67c24f93eaaded84b853">More...</a><br/></td></tr>
<tr class="separator:aafc6db8d806f67c24f93eaaded84b853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e5d39428cebc0a54a6ba2c10a3f73c"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:ac3e5d39428cebc0a54a6ba2c10a3f73c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac3e5d39428cebc0a54a6ba2c10a3f73c">viennacl::linalg::prod_impl</a> (const matrix_expression&lt; const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt;, op_trans &gt; &amp;mat_trans, const vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;vec, vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ac3e5d39428cebc0a54a6ba2c10a3f73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#ac3e5d39428cebc0a54a6ba2c10a3f73c">More...</a><br/></td></tr>
<tr class="separator:ac3e5d39428cebc0a54a6ba2c10a3f73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a946e478e53f6464d1dedeb3a46c89"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr class="memitem:ae7a946e478e53f6464d1dedeb3a46c89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
vector_expression&lt; const <br class="typebreak"/>
SparseMatrixType, const vector<br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae7a946e478e53f6464d1dedeb3a46c89">viennacl::linalg::prod_impl</a> (const SparseMatrixType &amp;mat, const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)</td></tr>
<tr class="separator:ae7a946e478e53f6464d1dedeb3a46c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989dc9f1224caf70090b16ba7e0caffb"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:a989dc9f1224caf70090b16ba7e0caffb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a989dc9f1224caf70090b16ba7e0caffb">viennacl::linalg::row_sum_impl</a> (const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="separator:a989dc9f1224caf70090b16ba7e0caffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa27d986659389c74adfa0744590afc2"><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr class="memitem:aaa27d986659389c74adfa0744590afc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa27d986659389c74adfa0744590afc2">viennacl::linalg::column_sum_impl</a> (const matrix_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;A, vector_base&lt; <a class="el" href="tests_2src_2bisect_8cpp.html#a52b5d30a2d7b064678644a3bf49b7f6c">NumericT</a> &gt; &amp;result)</td></tr>
<tr class="separator:aaa27d986659389c74adfa0744590afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides the forward declarations for the main types used within ViennaCL. </p>

<p>Definition in file <a class="el" href="forwards_8h_source.html">forwards.h</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_c82e3d11dd171600f4a6e0cab1ec1e0d.html">viennacl</a></li><li class="navelem"><a class="el" href="forwards_8h.html">forwards.h</a></li>
    <li class="footer">Generated on Wed Jan 20 2016 22:32:43 for ViennaCL - The Vienna Computing Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
